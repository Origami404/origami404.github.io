<!DOCTYPE html>
<html lang="zh-hans">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.92.2" />



<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png" />
<link rel="manifest" href="icons/site.webmanifest" />
<link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="icons/favicon.ico" />
<meta name="theme-color" content="#ffffff" />


<title>毕昇杯专用 ARMv7 汇编急救 - Origami404 的 Blog</title>


<meta name="author" content="Origami404" />


<meta name="description" content="有空的话就随便逛逛吧 www" />


<meta name="keywords" content="汇编, ARM, 毕昇杯" />


<meta property="og:title" content="毕昇杯专用 ARMv7 汇编急救" />
<meta name="twitter:title" content="毕昇杯专用 ARMv7 汇编急救" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.origami404.top/compiler-and-type-theory/2022-02-armv7-basic/" /><meta property="og:description" content="总览 主要参考文章: https://thinkingeek.com/arm-assembler-raspberry-pi/ 绝大部分示例代码都是从此文章抄来的 这篇参考文章偏向于使用 ARM 汇编进行开发的入门, 期望读者水平为学过 C, 还教了一些算法啥的. 作者还有一本书, 200来页, 书比网站上的更加系统, 建议看书. 当" />
<meta name="twitter:description" content="总览 主要参考文章: https://thinkingeek.com/arm-assembler-raspberry-pi/ 绝大部分示例代码都是从此文章抄来的 这篇参考文章偏向于使用 ARM 汇编进行开发的入门, 期望读者水平为学过 C, 还教了一些算法啥的. 作者还有一本书, 200来页, 书比网站上的更加系统, 建议看书. 当" /><meta property="og:image" content="https://blog.origami404.top/img/og.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://blog.origami404.top/img/og.png" /><meta property="article:published_time" content="2022-02-13T21:00:00+08:00" /><meta property="article:modified_time" content="2022-02-13T21:00:00+08:00" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>




<link rel="stylesheet" href="https://blog.origami404.top/assets/css/fuji.min.css" />








</head>

<body
  data-theme="auto"
  data-theme-auto='true'
  >
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://blog.origami404.top/">Origami404 的 Blog</a>
            
            <span class="title-sub">有空的话就随便逛逛吧 www</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://blog.origami404.top/compiler-and-type-theory/2022-02-armv7-basic/">毕昇杯专用 ARMv7 汇编急救</a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;2022-02-13</span>

<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;7905 字</span>

<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href="/tags/%E6%B1%87%E7%BC%96">汇编</a>&nbsp;<a href="/tags/arm">ARM</a>&nbsp;<a href="/tags/%E6%AF%95%E6%98%87%E6%9D%AF">毕昇杯</a>&nbsp;</span>

    </div>
    
    <div class="post-content markdown-body">
        <h2 id="总览">总览</h2>
<blockquote>
<p>主要参考文章: <a href="https://thinkingeek.com/arm-assembler-raspberry-pi/" target="_blank">https://thinkingeek.com/arm-assembler-raspberry-pi/</a></p>
<p><strong>绝大部分示例代码都是从此文章抄来的</strong></p>
<p>这篇参考文章偏向于使用 ARM 汇编进行开发的入门, 期望读者水平为学过 C, 还教了一些算法啥的. 作者还有一本书, 200来页, 书比网站上的更加系统, 建议看书.</p>
<p>当然如果我写错了什么, 那当然是我的问题, 不关作者事.</p>
</blockquote>
<p>这是一份对 ARMv7 汇编的急救指南, 目的是以最快速度提供 &ldquo;实现一个 target 到 ARMv7 的 C 编译器&rdquo; 所需要的 ARM 汇编知识. 本文章假设读者熟悉汇编语言与 C, 至少看过 CSAPP 的第 4 章, 并且了解一些编译技术.</p>
<p>本文章 <strong>没有</strong> :</p>
<ul>
<li>任何对 <strong>不同模式</strong> 的介绍与说明 (也就是只考虑 User 模式)</li>
<li>任何对 <strong>浮点运算</strong> 的介绍与说明</li>
<li>对一些指令的完全介绍, 比如 ldm/stm</li>
<li>对规范的完整解释</li>
</ul>
<p>本文章的介绍顺序大体按照那本书里的顺序, 为了方便查阅, 根据主题分类索引如下:</p>
<ul>
<li>总览 &amp; 框架: <a href="#%e5%9f%ba%e6%9c%ac%e6%9e%b6%e6%9e%84">基本架构</a></li>
<li>寄存器: <a href="#%e5%af%84%e5%ad%98%e5%99%a8">寄存器</a></li>
<li>分支: <a href="#%e5%88%86%e6%94%af-branching">分支</a>, <a href="#%e5%ae%9e%e7%8e%b0%e6%8e%a7%e5%88%b6%e6%b5%81">控制结构的翻译</a>, <a href="#%e6%9d%a1%e4%bb%b6%e6%89%a7%e8%a1%8c">条件执行</a></li>
<li>内存与取址模式: <a href="#%e5%86%85%e5%ad%98">内存</a>, <a href="#%e6%9b%b4%e7%b4%a7%e5%87%91%e7%9a%84%e6%8c%87%e4%bb%a4--%e5%8f%96%e5%9d%80%e6%a8%a1%e5%bc%8f">基本取址模式</a>, <a href="#%e6%95%b0%e7%bb%84%e4%b8%8e%e7%bb%93%e6%9e%84%e4%bd%93">load/store 特有的取址</a></li>
<li>函数: <a href="#%e5%87%bd%e6%95%b0">函数, 但不含栈</a>, <a href="#%e6%a0%88">函数, 但不含局部变量</a>, <a href="#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f">函数, 齐活了</a></li>
<li>动手实践: <a href="#gdb">用 GDB 调试汇编程序</a>, <a href="#%e5%8a%a8%e6%89%8b%e8%bf%87%e7%a8%8b">用 GCC 交叉编译 C 代码到 ARMv7 可执行文件并反编译</a></li>
</ul>
<!-- more -->
<h2 id="基本架构">基本架构</h2>
<h3 id="第一个程序--如何运行">第一个程序 &amp; 如何运行</h3>
<p>下面是一个返回值为 <code>2</code> 的简单的汇编程序：</p>
<pre><code class="language-arm">/* -- first.s */
/* 这是注释 */
.global main   /* 一个程序的入口(entry) 必须是全局的(global) */
.func main     /* 标记 label ’main’ 为一个函数  */

main:            /* 这是 label main */
    mov r0, #2   /* 将字面量 2 放入寄存器 r0 中 */
    bx lr        /* 从 main 中 &quot;返回&quot; */
</code></pre>
<p>简单地将其编译, 然后链接为可执行程序:</p>
<pre><code class="language-bash">$ as -g -mfpu=vfpv2 -o first.o first.s
$ gcc -o first first.o
</code></pre>
<p>执行它并查看其返回值:</p>
<pre><code class="language-bash">$ ./first ; echo $?
2
</code></pre>
<p>如果懒得每次都打命令, 可以写一个简单的脚本:</p>
<pre><code class="language-bash">#!/bin/bash
as -g -mfpu=vfpv2 -o $1.o $1.s
gcc -o $1 $1.o
rm $1.o
./$1 ; echo $?
</code></pre>
<h3 id="解释">解释</h3>
<p>注释不可以嵌套.</p>
<p><code>.</code>开头的是给 GNU Assembler (简称 gas 或 as) 的指令(directive), 不是 ARM 汇编. (类比 C 的宏)</p>
<p><code>global</code> 跟 linkage 有关, 是给链接器看的; 由 gcc 负责调用链接器, 就不用我们手动指定库了.</p>
<p>每一行 ARM 汇编都长这样:</p>
<pre><code>    标号: 指令 参数 注释
</code></pre>
<blockquote>
<p>它们的英文是 label: instruction parameters comments</p>
</blockquote>
<p>它们全都是可选的, 不一定都会出现. 特别地, 只有单独标号的一行将标号绑定到下一行, 这样子就可以将多个标号绑定到同一行上:</p>
<pre><code class="language-arm">A:  mov r0, #1 /* 标号 A 绑定到这条指令 */
B: 
    mov r0, #2 /* 标号 B 绑定到这条指令 */
C:
D:
E:
    mov r0, #2 /* 标号 C, D, E 绑定到这条指令 */
</code></pre>
<p>汇编里的空白是无所谓的, 参数依逗号分隔, 立即数(immediate, 类比 C 的字面量(literal)) 以 <code>#</code> 开头, 参数中用作目的地的参数常常在最左边(如这里的 <code>r0</code>).</p>
<p>单行注释一般也可以用 <code>@</code> 打头, 类似 bash/python 里的 <code>#</code> 跟 C++ 里的 <code>//</code>.</p>
<h3 id="直接使用-ld">直接使用 LD</h3>
<p>TODO</p>
<h2 id="寄存器">寄存器</h2>
<p>对树莓派 2B 来说, 除开特殊的寄存器, 共有 16 个通用整数寄存器以及 32 个通用浮点寄存器. 每一个通用整数寄存器(分别叫 <code>r0</code> 到 <code>r15</code>) 都是 32 位长的. 本章只讨论整数寄存器.</p>
<p>汇编里的数据采用补码表示, 立即数同理.</p>
<p>有些通用寄存器并不是真的 &ldquo;通用&rdquo; &ndash; 它们在特定上下文有特定用途:</p>
<ul>
<li><code>r13</code> 也被称为 <code>sp</code> (Stack Pointer)</li>
<li><code>r14</code> 也被称为 <code>lr</code> (Link Register)</li>
<li><code>r15</code> 也被称为 <code>pc</code> (Program Counter)</li>
</ul>
<p>关于 <code>fp</code>, 一般是 <code>r11</code>, 但是官方貌似没有指定, 我看到的也有用 <code>r7</code> 的, 所以你随便挑一个就好了.</p>
<p>下面的例子展示了寄存器的基本用法:</p>
<pre><code class="language-arm">/* -- sum01.s */
.global main

main:
    mov r1, #3      /* r1 ← 3 */
    mov r2, #4      /* r2 ← 4 */
    add r0, r1, r2  /* r0 ← r1 + r2 */
    bx lr
</code></pre>
<h2 id="内存">内存</h2>
<p>对 ARM, 所有指令的参数必须是立即数或者是寄存器, 而不是像 x86 一样还可以直接塞内存地址. 用来将内存特定位置的值读入寄存器的指令是 <code>ldr</code> (load register), 用来写回去的是 <code>str</code> (store register).</p>
<h3 id="地址">地址</h3>
<p>地址是内存里特定位置的名字. 在 ARMv7, 地址是一个 32 位长的整数, 标识内存中每一个字节. 对汇编程序而言, 内存是扁平的.</p>
<p>当从内存读/存数据时, 地址的计算方式(即取址模式, addressing mode)有很多种, 本章只介绍一种: 通过寄存器取址.</p>
<p>汇编里的标号实质上被实现为这行汇编代码对应的二进制码在可执行文件里的地址. 所以我们可以把标号当作 &ldquo;地址的立即数&rdquo; 来看.</p>
<p>我们可以使用汇编器指令来申请大块内存:</p>
<pre><code class="language-arm">.balign 4       @ 对齐到 4 字节, Byte ALIGN
myvar1:         @ 标号, 接下来就可以通过该标号获得数据的地址
    .word 3     @ 留出 1 个 &quot;word&quot; 的空白 (32bit) 并将其设为补码 3
</code></pre>
<p>程序的数据一般会跟代码分开放在内存的不同区域(节, section). 使用 <code>.data</code> 让汇编器把下面的东西放在数据节(data section)里, 使用 <code>.text</code> 让汇编器把下面的东西放在代码节(text section)里.</p>
<h3 id="load">Load</h3>
<p>下面的程序定义两个内存中的变量 <code>myvar1</code> 和 <code>myvar2</code>, 分别赋予其初始值 3 和 4, 然后取其值, 相加, 返回作为错误码.</p>
<pre><code class="language-arm">/* -- load01.s */

/* -- Data section */
.data

/* 确保数据被对齐到 4 字节 */
.balign 4
/* 定义 myvar1 的存储空间(storage) */
myvar1:
    /* 一个值为 3 的 4 byte 整数 */
    .word 3

/* 确保数据被对齐到 4 字节 */
.balign 4
/* 定义 myvar2 的存储空间(storage) */
myvar2:
    /* 一个值为 4 的 4 byte 整数 */
    .word 4

/* -- Code section */
.text

/* 确保代码被对齐到 4 字节 */
.balign 4
.global main
main:
    ldr r1, addr_of_myvar1 /* r1 ← &amp;myvar1 */
    ldr r1, [r1]           /* r1 ← *r1 */
    ldr r2, addr_of_myvar2 /* r2 ← &amp;myvar2 */
    ldr r2, [r2]           /* r2 ← *r2 */
    add r0, r1, r2         /* r0 ← r1 + r2 */
    bx lr

/* 用来访问数据的标号 */
addr_of_myvar1 : .word myvar1
addr_of_myvar2 : .word myvar2
</code></pre>
<p>注意最下面的 <code>addr_of_*</code>. 即使标号 <code>myvar1</code> 已经包含了 myvar1 的地址, 但是因为这个标号在 <code>.data</code> 节里, 所以我们不能跨节, 在 <code>.text</code> 节里使用它. 我们必须在 <code>.text</code> 节里再做两个标号, 分别放它们的地址, 然后用标号来访问这些地址 &ndash; 现在 <code>addr_of_myvar1</code> 是一个 &ldquo;地址&rdquo;, 这个 &ldquo;地址&rdquo; 指着一个 word, 这个 word 的值是 <code>myvar1</code> 的地址, 类似于一个二级指针.</p>
<blockquote>
<p>总结: <strong>标号不能跨节使用</strong>.</p>
</blockquote>
<p>上面的 &ldquo;地址&rdquo; 打了引号: 因为重定位(relocation)的缘故, 它并不是一个真的地址, 而是一个待填的 &ldquo;坑&rdquo;; 这个坑将会在链接时被链接器补上.</p>
<p>要把寄存器里的值当做地址传给 ldr, 我们只要用中括号把它括起来就可以了.</p>
<p>但是这样子很烦人, 所以汇编器可以帮我们自动处理不同节的重定位: 我们不需要像上面一样补上最后两行然后跳两次 &ndash; 我们可以直接使用 <code>=&lt;标号&gt;</code> 的形式来得到不同节里的标号值. 具体使用可见下节</p>
<h3 id="store">Store</h3>
<p>下面的程序定义两个内存中的变量 <code>myvar1</code> 和 <code>myvar2</code>, 赋予其初始值 0, 然后使用 str 指令赋予其值 3, 4, 然后取其值, 相加, 返回作为错误码.</p>
<pre><code class="language-diff">/* -- store01.s */

/* -- Data section */
.data

.balign 4
myvar1:
    .word 0

.balign 4
myvar2:
    .word 0

/* -- Code section */
.text

.balign 4
.global main
main:
+    ldr r1, =myvar1        /* r1 ← &amp;myvar1 */
    mov r3, #3             /* r3 ← 3 */
+    str r3, [r1]           /* *r1 ← r3 */
+    ldr r2, =myvar2        /* r2 ← &amp;myvar2 */
    mov r3, #4             /* r3 ← 4 */
+    str r3, [r2]           /*  *r2 ← r3 */ 

    /* 跟之前一样 */
    ldr r1, =myvar2        /* r1 ← &amp;myvar1 */
    ldr r1, [r1]           /* r1 ← *r1 */
    ldr r2, =myvar2        /* r2 ← &amp;myvar2 */
    ldr r2, [r2]           /* r2 ← *r2 */
    add r0, r1, r2
    bx lr
</code></pre>
<p>注意上面代码的两个 str 指令的参数顺序, 我们写 <code>str A, [B]</code>, 是将 <code>A -&gt; *B</code>, 而不是像普通指令一样目的地在左边.</p>
<h2 id="gdb">GDB</h2>
<blockquote>
<p>If you develop C/C++ in Linux and never used gdb, shame on you.</p>
</blockquote>
<p>本章介绍如何使用 GDB 方便地调试汇编程序.</p>
<p>启动 GDB:</p>
<pre><code>$ gdb --args ./store01
GNU gdb (GDB) 7.4.1-debian
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later 
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;
and &quot;show warranty&quot; for details.
This GDB was configured as &quot;arm-linux-gnueabihf&quot;.
For bug reporting instructions, please see:
...
Reading symbols from /home/roger/asm/chapter03/store01...(no debugging symbols found)...done.
(gdb)
</code></pre>
<p>现在我们进入了 GDB 的交互模式.</p>
<p>退出 GDB:</p>
<pre><code>(gdb) quit
</code></pre>
<p>开始运行程序 &ndash; 这会跳过所有 C 运行时库的初始化, 直接在标号 <code>main</code> 前停住.</p>
<pre><code>(gdb) start
Temporary breakpoint 1 at 0x8390
Starting program: /home/roger/asm/chapter03/store01 

Temporary breakpoint 1, 0x00008390 in main ()
</code></pre>
<p>反汇编:</p>
<blockquote>
<p>使用 disas 作为简写也可</p>
</blockquote>
<pre><code>(gdb) disassemble
Dump of assembler code for function main:
=&gt; 0x00008390 :	ldr	r1, [pc, #40]	; 0x83c0 箭头指向**将要**被执行的指令
   0x00008394 :	mov	r3, #3
   0x00008398 :	str	r3, [r1]
   0x0000839c :	ldr	r2, [pc, #32]	; 0x83c4 
   0x000083a0 :	mov	r3, #4
   0x000083a4 :	str	r3, [r2]
   0x000083a8 :	ldr	r1, [pc, #16]	; 0x83c0 
   0x000083ac :	ldr	r1, [r1]
   0x000083b0 :	ldr	r2, [pc, #12]	; 0x83c4 
   0x000083b4 :	ldr	r2, [r2]
   0x000083b8 :	add	r0, r1, r2
   0x000083bc :	bx	lr
End of assembler dump.
</code></pre>
<p>查看寄存器:</p>
<pre><code>(gdb) info registers r0 r1 r2 r3
r0             0x1	1
r1             0xbefff744	3204446020
r2             0xbefff74c	3204446028
r3             0x8390	33680
</code></pre>
<p>修改寄存器的值:</p>
<blockquote>
<p>p 表示 print</p>
</blockquote>
<pre><code>(gdb) p $r0 = 2
$1 = 2                   $1表示执行 p 时求值求出的第一个结果
(gdb) info registers r0 r1 r2 r3
r0             0x2	2
r1             0xbefff744	3204446020
r2             0xbefff74c	3204446028
r3             0x8390	33680
</code></pre>
<p>引用之前输入的值:</p>
<pre><code>(gdb) p $1
$2 = 2
</code></pre>
<p>执行下一条指令:</p>
<blockquote>
<p>stepi 表示 step instruction</p>
</blockquote>
<pre><code>(gdb) stepi
0x00008394 in main ()
</code></pre>
<p>打印变量/变量地址:</p>
<pre><code>(gdb) p &amp;myvar1
$3 = ( *) 0x10564
</code></pre>
<pre><code>(gdb) p myvar1
$4 = 0
</code></pre>
<p>执行到下一个标号:</p>
<pre><code>(gdb) continue
Continuing.
[Inferior 1 (process 3080) exited with code 07]
</code></pre>
<h2 id="分支-branching">分支 (Branching)</h2>
<p><code>r15</code> 在绝大部分情况下充当 <code>pc</code> 的作用, 寄存器名称 <code>pc</code> 就是 <code>r15</code> 的别名.</p>
<p>ARMv7 指令集定长, 32bit.</p>
<p>改变 pc 的值的过程称为分支(Branching). 中文一般也叫跳转, 虽然跳转对应的英文应该是 jump.</p>
<h3 id="无条件跳转">无条件跳转</h3>
<p>单独使用 <code>b &lt;label&gt;</code> 指令来进行无条件跳转.</p>
<pre><code class="language-arm">/* -- branch01.s */
.text
.global main
main:
    mov r0, #2 /* r0 ← 2 */
    b end      /* 跳转到标号为 'end' 的位置 */
    mov r0, #3 /* r0 ← 3 */
end:
    bx lr
</code></pre>
<h3 id="有条件跳转">有条件跳转</h3>
<p><code>cpsr</code>(Current Program Status Register) 寄存器是一个特殊寄存器, 保存了程序执行过程中一些条件信息. 其保存的四个 flag 分别是:</p>
<ul>
<li><code>N</code>: Negative flag: 上一条指令的结果是否为负数</li>
<li><code>Z</code>: Zero flag: 上一条指令的结果是否为 0</li>
<li><code>C</code>: Carry flag: 上一条指令的结果是否需要第 33 个位才能表示 &ndash; 加法溢出或者非借位减法都会使其为真</li>
<li><code>V</code>: Overflow flag: 上一条指令的结果是否出现了溢出</li>
</ul>
<p>我们可以使用 <code>cmp A B</code> 指令来 &ldquo;做比较&rdquo; &ndash; 它相当于执行 <code>sub ? A B</code>(A - B), 运算中更新 cpsr, 但运算结果并不会保存在任何地方. 所以我们有:</p>
<ul>
<li><code>N</code>: A &lt; B</li>
<li><code>Z</code>: A == B</li>
<li><code>C</code>: A &gt; B    (发生了非借位减法)</li>
<li><code>V</code>: 溢出</li>
</ul>
<p>我们可以透过 cpsr 的状态来判断常见的关系:</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>关系</th>
<th>cpsr 状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>EQ</td>
<td>equal</td>
<td><code>Z == 1</code></td>
</tr>
<tr>
<td>NE</td>
<td>not equal</td>
<td><code>Z == 0</code></td>
</tr>
<tr>
<td>GE</td>
<td>greater or equal than</td>
<td><code>N == V</code></td>
</tr>
<tr>
<td>LT</td>
<td>lower than</td>
<td><code> N != V</code></td>
</tr>
<tr>
<td>GT</td>
<td>greather than</td>
<td><code>N == V &amp;&amp; Z == 0</code></td>
</tr>
<tr>
<td>LE</td>
<td>lower or equal than</td>
<td><code>N != V || Z == 1</code></td>
</tr>
<tr>
<td>MI</td>
<td>minus/negative</td>
<td><code>N == 1</code></td>
</tr>
<tr>
<td>PL</td>
<td>plus/positive or zero</td>
<td><code>N == 0</code></td>
</tr>
<tr>
<td>VS</td>
<td>overflow set</td>
<td><code>V == 1</code></td>
</tr>
<tr>
<td>VC</td>
<td>overflow clear</td>
<td><code>V == 0</code></td>
</tr>
<tr>
<td>HI</td>
<td>higher</td>
<td><code>C == 1 &amp;&amp; Z == 0</code></td>
</tr>
<tr>
<td>LS</td>
<td>lower or same</td>
<td><code>C == 0 || Z == 1</code></td>
</tr>
<tr>
<td>CS/HS</td>
<td>carry set/higher or same</td>
<td><code>C == 1</code></td>
</tr>
<tr>
<td>CC/LO</td>
<td>carry clear/lower</td>
<td><code>C == 0</code></td>
</tr>
</tbody>
</table>
<p>上面的这些缩写可以拿来跟 <code>b</code> 指令组合变成 <code>bXX</code> 指令, 例如下面这个程序:</p>
<pre><code class="language-arm">/* -- compare01.s */
.text
.global main
main:
    mov r1, #2       /* r1 ← 2 */
    mov r2, #2       /* r2 ← 2 */
    cmp r1, r2       /* 用 &quot;r1 - r2&quot; 的伪操作来更新 cpsr 寄存器 */
    beq case_equal   /* cpsr 状态为 EQ, 即 Z == 1 时, 就跳转 */
case_different :
    mov r0, #2       /* r0 ← 2 */
    b end            /* branch to end */
case_equal:
    mov r0, #1       /* r0 ← 1 */
end:
    bx lr
</code></pre>
<h2 id="实现控制流">实现控制流</h2>
<blockquote>
<p>这里描述的实现不是最优的, 只是能行的.</p>
<p>更优的实现(具有更少跳转语句)参见龙书</p>
</blockquote>
<h3 id="ifthenelse">if/then/else</h3>
<pre><code class="language-arm">if_eval: 
    /* 求值条件, 并根据条件生成 cmp */
bXX else /* 合适的 bXX 用于跳转 */
then_part: 
   /* 生成 then 块 */
   b end_of_if
else:
   /* 生成 else 块 */
end_of_if:
</code></pre>
<p>具体实现与短路的实现可以看龙书.</p>
<h3 id="while">while</h3>
<pre><code class="language-arm">while_condition: 
    /* 生成条件 E */
    bXX end_of_loop  /* 如果 E 是假的, 跳转 */
    /* 生成循环体 */
    b while_condition /* 无条件跳回开始 */
end_of_loop:
</code></pre>
<h3 id="for">for</h3>
<h4 id="不带-continue-的">不带 continue 的</h4>
<p>相当于:</p>
<pre><code class="language-c">for (A; B; C)
    S

A;
while (B) {
    S;
    C;
}
</code></pre>
<h4 id="带-continue-的">带 continue 的</h4>
<pre><code class="language-c">A;
while (B) {
    S; // continue 相当于 goto step

step:
    C;
}
</code></pre>
<h2 id="更紧凑的指令--取址模式">更紧凑的指令 / 取址模式</h2>
<h3 id="indexing-modes--指令参数类型">Indexing modes / 指令参数类型</h3>
<p>通过之前的例子, 我们可以发现一条 ARM 汇编指令的参数可以是不同的类型(立即数/寄存器/<code>[寄存器]</code>/标号&hellip;). 这些类型被称为 indexing mode (这个名字没啥意义, 反正你认为是参数类型就是了).</p>
<p>指令的语法可以总结如下:</p>
<pre><code>instruction Rdest, Rsource1, source2
</code></pre>
<p>其中 <code>Rdest</code> 与 <code>Rsource1</code> 都必须是一个寄存器, 而 <code>source2</code> 则可以塞入更多种类的操作数. 本章主要讨论 <code>source2</code> 的其他种类.</p>
<blockquote>
<p>有些指令是不一样的, 但是总的来说就是这么个理, 比如 <code>mov Rdest, source2</code></p>
</blockquote>
<p>至于 ldr 跟 str 的特殊取址模式, 下章再讲.</p>
<h3 id="位移运算数">位移运算数</h3>
<ul>
<li><code>LSL #n/Rsource3</code>: 逻辑左移, 左 n 位会丢, 右 n 位是 0. n 由立即数或者寄存器 Rsource3 里的值决定</li>
<li><code>LSR #n/Rsource3</code>: 逻辑右移, 左 n 位是 0, 右 n 位会丢</li>
<li><code>ASR #n/Rsource3</code>: 算术右移, 左 n 位填充为符号位, 右 n 位会丢</li>
<li><code>ROR #n/Rsource3</code>: 向右旋转, 类似 <code>LSR</code>, 但右 n 位被推到左 n 位去</li>
</ul>
<p>举几个例子:</p>
<pre><code class="language-arm">mov r1, r2, LSL #1      @ r1 &lt;- (r2*2)
mov r1, r2, LSL #2      @ r1 &lt;- (r2*4)
mov r1, r3, ASR #3      @ r1 &lt;- (r3/8)
mov r3, #4
mov r1, r2, LSL r3      @ r1 &lt;- (r2*16)
</code></pre>
<p>更复杂的乘法:</p>
<pre><code class="language-arm">add r1, r2, r2, LSL #1      @ r1 &lt;- r2 + (r2*2) equivalent to r1 &lt;- r1*3
add r1, r2, r2, LSL #2      @ r1 &lt;- r2 + (r2*4) equivalent to r1 &lt;- r1*5
sub r1, r2, r2, LSL #3      /* r1 &lt;- r2 - (r2*8) equivalent to r1 &lt;- r2*(-7) */
rsb r1, r2, r2, LSL #3      /* r1 &lt;- (r2*8) - r2 equivalent to r1 &lt;- r2*7 */
</code></pre>
<p>注意 rsb (Reverse SuBstract)指令, 它就是被减数跟减数顺序反过来的 sub 指令. 因为位移操作数只能在最后一个参数(<code>source2</code>)用, 所以 ARM 提供了这个指令来让我们不用用正常的 sub 减完再取负. (适合于我们想要对被减数使用位移的时候)</p>
<p>这个主要用来做强度约减的.</p>
<h2 id="数组与结构体">数组与结构体</h2>
<h3 id="定义分配空间">定义/分配空间</h3>
<p>C 语言里的数组/结构体定义可以翻译如下:</p>
<pre><code class="language-c">int a[100];
struct my_struct {
    char f0;
    int f1;
} b;
char s[] = &quot;This is a string&quot;;
</code></pre>
<pre><code class="language-arm">/* -- array01.s */
.data
a:
    .skip 400       @ 预留 400 byte 的内存空间, 即 sizeof(a)
b:
    .skip 8         @ 预留 8 byte 的内存空间, 即 sizeof(b), 要考虑对齐

S:
    .asciz &quot;This is a string&quot;   @ ASCIi with Zero terminator, 会自动在最后附加空字符
</code></pre>
<h3 id="indexing-mode--索引模式--取址模式">Indexing mode / 索引模式 / 取址模式</h3>
<h4 id="不更新寄存器-non-updating-indexing-modes">不更新寄存器 (Non-updating indexing modes)</h4>
<ol>
<li><code>[R1, #±n]</code>: 取地址 R1±n</li>
<li><code>[R1, #±R2]</code>: 取地址 R1±R2</li>
<li><code>[R1, ±R2, shift_op #±n]</code>: shift_op 可以是上面提到过的任意位移操作, 取地址 <code>R1 ± shift_op(R2, ±n)</code></li>
</ol>
<p>其中 (1) 适合类似 <code>a[N]</code>, <code>N</code> 为常数的索引, 也适合于结构体里取成员. (3) 适合于 <code>a[i]</code>, <code>i</code> 是变量的索引. 假如 <code>a</code> 是 i32 类型的数组, 那么只要 <code>[a, i, LSL #4]</code> 就可以了.</p>
<p>例子:</p>
<pre><code class="language-arm">str r2, [r1, #+12]          @ *(r1 + 12) &lt;- r2
str r2, [r1, +r3]           @ *(r1 + r3) &lt;- r2
str r2, [r1, +r2, LSL #2]   @ *(r1 + r2*4) &lt;- r2
</code></pre>
<h4 id="取址后更新寄存器-post-indexing-modes">取址后更新寄存器 (Post-indexing modes)</h4>
<p>考虑下面的 C 代码:</p>
<pre><code class="language-c">for (int i = 0; i &lt; n; i++) {
    a[i] = i;
}
</code></pre>
<p>如果正常地按照字面意思来翻译的话, 我们会翻译成这样:</p>
<pre><code class="language-arm">/* 假设 r0 存了 a 的首地址, r1 存了 n 的值 */
/* 用 r2 来当 i */

mov r2, #0
loop:
    cmp r2, r1         
    bge loop_end

    str r2 [r0, +r2, LSL #2]   @ r2 -&gt; *(r0 + r2*4)

    add r2, r2, #1             @ r2 &lt;- r2 + 1
    b loop
loop_end:
</code></pre>
<p>但是仔细想想, 我们并不需要每一次访问元素都算一次地址, 我们可能可以这样实现:</p>
<pre><code class="language-arm">/* 假设 r0 一开始存了 a 的首地址, r1 存了 n 的值 */

mov r2, #0
loop:
    cmp r2, r1     
    bge loop_end

    str r2 [r0]         @ (*) r2 -&gt; *r0
    add r0, r0, #4      @ (*) r0 &lt;- r0 + 4

    add r2, r2, #1      @ r2 &lt;- r2 + 1
    b loop
loop_end:
</code></pre>
<p>而 ARM 为这种情况提供了一个快速的取址模式: &ldquo;取址, 然后更新&rdquo;. (*) 两行可被合并为 <code>str r2 [r0], #+4</code></p>
<ol>
<li><code>[R1], #±n</code>: 取地址 R1, 然后 R1 ±= n</li>
<li><code>[R1], #±R2</code>: 取地址 R1, 然后 R1 ±= R2</li>
<li><code>[R1], ±R2, shift_op #±n</code>: 取地址 R1, 然后 R1 ±= shift_op(R2, ±n)</li>
</ol>
<h4 id="取址前更新寄存器-pre-indexing-modes">取址前更新寄存器 (Pre-indexing modes)</h4>
<p>同样, 也有先更新寄存器, 再取址的取值模式:</p>
<ol>
<li><code>[R1, #±n]!</code>: R1 ±= n, 然后取地址 R1</li>
<li><code>[R1, #±R2]!</code>: R1 ±= R2, 然后取地址 R1</li>
<li><code>[R1, ±R2, shift_op #±n]!</code>: R1 ±= shift_op(R2, ±n), 然后取地址 R1</li>
</ol>
<blockquote>
<p>好怪啊, 为什么不把 pre 和 post 的语法反过来</p>
</blockquote>
<h3 id="访问">访问</h3>
<p>要想访问数组的第 i 个元素, 我们就直接像上面那样使用 <code>[a, #i LSL #2]</code>(<code>*(a+4*i)</code>) 就可以了.</p>
<p>要想访问结构体的域, 我们也像上面那样, 不过这次是计算出偏移量然后加上: <code>[p, #offset]</code> (<code>*(p + offset)</code>)</p>
<h2 id="函数">函数</h2>
<h3 id="基本知识">基本知识</h3>
<p>一段代码要想成为一个 &ldquo;函数&rdquo;, 必须遵守一些约定. 这些约定用来约束函数执行前后的 CPU 状态. 在 Linux 上, 一个 ARM 汇编函数必须遵守 ARM 结构过程调用规范(ARM Architecture Procedure Call Standard, AAPCS).</p>
<p>寄存器 <code>r14</code> 又叫 <code>lr</code> (link register), 保存了调用本函数的指令的下一条指令的地址(可以看作是执行完要返回哪里)</p>
<p>寄存器 <code>r13</code> 又叫 <code>sp</code> (stack pointer), 保存了栈顶的地址.</p>
<h3 id="参数传递">参数传递</h3>
<p>首四个参数必须被按顺序存于 <code>r0</code>, <code>r1</code>, <code>r2</code>, <code>r3</code>.</p>
<p>更多的参数置于栈中 TODO</p>
<h3 id="好函数">&ldquo;好&quot;函数</h3>
<ul>
<li>函数不应该依赖开始执行时 cpsr 的状态</li>
<li>函数可以自由修改 <code>r0</code>, <code>r1</code>, <code>r2</code>, <code>r3</code></li>
<li>除非被用于传递参数, 否则函数不应该依赖于开始执行时 <code>r0</code>, <code>r1</code>, <code>r2</code>, <code>r3</code> 内的值</li>
<li>函数内部可以随意修改 <code>lr</code>, 但离开函数之后 <code>sp</code> 的值总应该是进入函数时 <code>lr</code> 的值</li>
<li>函数内部可以随意修改其他寄存器, 但离开函数时它们的值应该与进入时相同</li>
</ul>
<h3 id="调用函数">调用函数</h3>
<p>直接(立即)调用: <code>bl &lt;标号&gt;</code>, 此标号必须在 <code>.text</code> 节定义.</p>
<p>间接调用: <code>blx Rsource1</code>, 其中 Rsource1 存着该函数的第一条指令的地址</p>
<h3 id="离开函数">离开函数</h3>
<p>直接跳转即可. <code>bx Rsource1</code>, 其中 Rsource1 应该保存着进入函数时 <code>lr</code> 的值.</p>
<blockquote>
<p>blx 指令在跳转的同时还会将 lr 设为 pc + #4, 而函数返回时我们只需要做一个简单跳转就好了, 所以直接用 bx</p>
</blockquote>
<h3 id="返回值">返回值</h3>
<p>对于 32bit 的基础类型, 比如 C 的 char, short, int, long, 返回值存于 <code>r0</code>; 对于 64 位的基础类型, 返回值存于 <code>r0</code> 与 <code>r1</code>; 对于其他任何长度大于 32 bit 的类型, 返回值存于栈上.</p>
<h3 id="实例-hello-world-调用-c-标准库函数">实例: Hello World (调用 C 标准库函数)</h3>
<pre><code class="language-arm">/* -- hello01.s */
.data

greeting:
 .asciz &quot;Hello world&quot;   /* .asciz: 以 0 结尾的字符数组 */

.balign 4
return: .word 0         /* 用于保存 lr 的值, 因为函数调用可能改变 lr        */
                        /* 被调函数只负责能跳回来, **不负责**还原 lr 的值!!! */

.text

.global main
main:
    ldr r1, address_of_return     /*   r1 ← &amp;address_of_return */
    str lr, [r1]                  /*   *r1 ← lr */

    ldr r0, address_of_greeting   /* r0 ← &amp;address_of_greeting */
                                  /* 传给 puts 的第一个参数 */

    bl puts                       /* 调用 puts */
                                  /* lr ← address of next instruction */

    ldr r1, address_of_return     /* r1 ← &amp;address_of_return */
    ldr lr, [r1]                  /* lr ← *r1 */
    bx lr                         /* return from main */
address_of_greeting: .word greeting
address_of_return: .word return

/* 外部函数 External */
.global puts
</code></pre>
<h2 id="栈">栈</h2>
<h3 id="基本理论">基本理论</h3>
<ul>
<li><code>sp</code> 表示当前栈顶. 根据 AAPCS, 其应以 8 字节对齐.</li>
<li>离开函数时, <code>sp</code> 必须被恢复为进入函数时的值</li>
</ul>
<p>在 Linux ARM 上, 栈向低地址方向增长.</p>
<p>入栈/出栈理论上的操作如下:</p>
<pre><code class="language-arm">sub sp, sp, #8  /* sp ← sp - 8. 扩大当前栈帧 8 byte */
str lr, [sp]    /* *sp ← lr */
... // 函数的其他代码 ...
ldr lr, [sp]    /* lr ← *sp */
add sp, sp, #8  /* sp ← sp + 8. /* 减小当前栈帧 8 byte
                                   将 sp 还原 */
bx lr
</code></pre>
<p>使用索引模式, 代码简化如下:</p>
<pre><code class="language-arm">str lr, [sp, #-8]!  /* preindex: sp ← sp - 8; *sp ← lr */
... // Code of the function
ldr lr, [sp], #+8   /* postindex; lr ← *sp; sp ← sp + 8 */
bx lr
</code></pre>
<h3 id="阶乘程序">阶乘程序</h3>
<p>下面的程序实现了阶乘:</p>
<pre><code class="language-arm">/* -- factorial01.s */
.data

message1: .asciz &quot;Type a number: &quot;
format:   .asciz &quot;%d&quot;
message2: .asciz &quot;The factorial of %d is %d\n&quot;

.text

factorial:
    str lr, [sp,#-4]!  /* Push lr onto the top of the stack */
    str r0, [sp,#-4]!  /* Push r0 onto the top of the stack */
                       /* Note that after that, sp is 8 byte aligned */
    cmp r0, #0         /* compare r0 and 0 */
    bne is_nonzero     /* if r0 != 0 then branch */
    mov r0, #1         /* r0 ← 1. This is the return */
    b end
is_nonzero:
                       /* Prepare the call to factorial(n-1) */
    sub r0, r0, #1     /* r0 ← r0 - 1 */
    bl factorial
                       /* After the call r0 contains factorial(n-1) */
                       /* Load r0 (that we kept in th stack) into r1 */
    ldr r1, [sp]       /* r1 ← *sp */
    mul r0, r0, r1     /* r0 ← r0 * r1 */
    
end:
    add sp, sp, #+4    /* Discard the r0 we kept in the stack */
    ldr lr, [sp], #+4  /* Pop the top of the stack and put it in lr */
    bx lr              /* Leave factorial */

.global main
main:
    str lr, [sp,#-4]!            /* Push lr onto the top of the stack */
    sub sp, sp, #4               /* Make room for one 4 byte integer in the stack */
                                 /* In these 4 bytes we will keep the number */
                                 /* entered by the user */
                                 /* Note that after that the stack is 8-byte aligned */
    ldr r0, address_of_message1  /* Set &amp;message1 as the first parameter of printf */
    bl printf                    /* Call printf */

    ldr r0, address_of_format    /* Set &amp;format as the first parameter of scanf */
    mov r1, sp                   /* Set the top of the stack as the second parameter */
                                 /* of scanf */
    bl scanf                     /* Call scanf */

    ldr r0, [sp]                 /* Load the integer read by scanf into r0 */
                                 /* So we set it as the first parameter of factorial */
    bl factorial                 /* Call factorial */

    mov r2, r0                   /* Get the result of factorial and move it to r2 */
                                 /* So we set it as the third parameter of printf */
    ldr r1, [sp]                 /* Load the integer read by scanf into r1 */
                                 /* So we set it as the second parameter of printf */
    ldr r0, address_of_message2  /* Set &amp;message2 as the first parameter of printf */
    bl printf                    /* Call printf */


    add sp, sp, #+4              /* Discard the integer read by scanf */
    ldr lr, [sp], #+4            /* Pop the top of the stack and put it in lr */
    bx lr                        /* Leave main */

address_of_message1: .word message1
address_of_message2: .word message2
address_of_format: .word format
</code></pre>
<h3 id="快速保存各种寄存器-ldm--stm">快速保存各种寄存器: ldm &amp; stm</h3>
<p>TODO 详细介绍</p>
<p>使用 <code>stmdb sp!, {r4, lr}</code> 将 r4, lr 推入栈中; 使用 <code>ldmia sp!, {r4, lr}</code> 将 r4, lr 弹出栈(并且把对应寄存器的值设回去).</p>
<p>GNU as 给我们提供了两个助记符: <code>push {r4, lr}</code> 与 <code>pop {r4, lr}</code></p>
<h2 id="条件执行">条件执行</h2>
<p>对大部分指令, 在它后面加条件后缀(<code>eq</code>, <code>ne</code>, &hellip;)即可:</p>
<pre><code class="language-arm">mp r2, #0                   @ Compare r2 and 0
moveq r1, r1, ASR #1        @ if r2 == 0, r1 &lt;- r1 &gt;&gt; 1. [r1 &lt;- r1/2]
addne r1, r1, r1, LSL #1    @ if r2 != 0, r1&lt;-r1+(r1&lt;&lt;1). [r1 &lt;- 3*r1]
addne r1, r1, #1            @ if r2 != 0, r1 &lt;- r1 + 1
</code></pre>
<p>需要注意的是, 一般的指令并不会改变 cpsr 的状态, 只有 <code>cmp</code> 跟加了后缀 <code>s</code> 的指令会改变 cpsr.</p>
<pre><code class="language-arm">/* for (int i = 100 ; i &gt;= 0; i--) */
mov r1, #100
loop:
    /* do something */
    subs r1, r1, #1     @ r1 &lt;- r1 - 1, update cpsr with the final r1
    bpl loop            @ branch if the previous sub computed a positive
                        @ number (N flag in cpsr is 0)
</code></pre>
<h2 id="局部变量">局部变量</h2>
<h3 id="快速总结">快速总结</h3>
<blockquote>
<p>关于栈帧, 那本书里教的貌似不是 gcc 的做法, 注意对比</p>
</blockquote>
<p>标准没有规定 <code>fp</code> 是哪个寄存器, 但通行做法是用 <code>r11</code>, GNU as 也支持使用 <code>fp</code> 作为 <code>r11</code> 的简写.</p>
<p>标准对栈帧结构没啥要求, 只要你能符合 AAPCS 就可以了. 反汇编 <code>arm-linux-gnueabihf-gcc</code> 的编译结果可以看到 GCC 对栈帧的处理方式, 总结一下就是下面这样子(对应下面动手实践的星号行的时候的机器状态):</p>
<pre><code>         |                                      | Low address
         |                                      |
         |                                      |
         |                                      |
         |                                      |&lt;----------+
       + |......................................|           |
       + |                                      |           |
       + |                                      |           |
       + |  Local variable                      |           |
       + |                                      |           |
       + |......................................|           |
       + |                                      |           |
       + |                                      |           |
       + |  Local variable                      |           |
       + |                                      |           |
       + |......................................|           |
       + |                                      |           |
       + |                                      |           |
       + |  Local variable                      |           |
       + |                                      |           |
       + +--------------------------------------+           |
         |                                      |           |
         |                                      |           |
         |  (Last) Other registers(R4)          |           |
         |                                      |           |
         +--------------------------------------+           |
         |                                      |           |
         |                                      |           |
         |  (Last) FP                           |           | +----------------+
+--------+                                      |&lt;---+      | |                |
|        +--------------------------------------+    |      +-+ Stack Pointer  |
|        |                                      |    |        |                |
|        |                                      |    |        +----------------+
|        |  (last) LR                           |    |
|        |                                      |    |        +----------------+
|        +--------------------------------------+    |        |                |
|        |                                      |    +--------+ Frame Pointer  |
|        |                                      |             |                |
|        |                                      |             +----------------+
|        |                                      |
|        |                                      |
|        |                                      |
|
|                                                   High address
+------&gt;
</code></pre>
<p>一直通过 <code>fp = *fp</code> 就可以遍历当前整个栈, 看起来就好像用 fp 把栈帧都串起来了一样.</p>
<h3 id="动手过程">动手过程</h3>
<pre><code class="language-c">int fib(int x) {
    if (x == 1 || x == 2) {
        return 1;
    } else {
        return fib(x - 1) + fib(x - 2);
    }
}
</code></pre>
<p>使用下面的命令反汇编: (我知道 gcc 可以直接出汇编, 但貌似 objdump 出来的格式好看点)(输出经过了美化, 可能你的原始输出会不太一样)</p>
<pre><code>arm-linux-gnueabihf-gcc -march=armv7-a -O0 -static -g -c arm_stackframe.c -o arm_stackframe.O0.armv7.o
arm-linux-gnueabihf-objdump -drwCS arm_stackframe.armv7.O0.o &gt; arm_stackframe.armv7.O0.s
</code></pre>
<blockquote>
<p>参数解释参见: <a href="https://stackoverflow.com/a/1289907" target="_blank">https://stackoverflow.com/a/1289907</a></p>
</blockquote>
<pre><code class="language-arm">
arm_stackframe.armv7.O0.o:     file format elf32-littlearm


Disassembly of section .text:

00000000 &lt;fib&gt;:
@int fib(int x) {
    /* ==================== 进入函数的处理 ====================== */
   0:	e92d4810 	push	{r4, fp, lr}            @ 存 r4, 因为后面会用
   4:	e28db008 	add	fp, sp, #8                  @ 让 fp 指向栈里存着的 fp
   8:	e24dd00c 	sub	sp, sp, #12                 @ 栈空间保留 3 * i32
    /* *************************************** 上面的示意图就是现在的状态 *************************************** */   

   c:	e50b0010 	str	r0, [fp, #-16]              @ 根据 AAPCS, r0 里是第一个参数, 这里把输入参数放到栈上 (可能是因为开了 O0, 默认假设参数都在栈上方便 codegen)
@    if (x == 1 || x == 2) {
  10:	e51b3010 	ldr	r3, [fp, #-16]              @ 读取输入参数
  14:	e3530001 	cmp	r3, #1                      @ 短路比较
  18:	0a000002 	beq	28 &lt;fib+0x28&gt;
  1c:	e51b3010 	ldr	r3, [fp, #-16]
  20:	e3530002 	cmp	r3, #2
  24:	1a000001 	bne	30 &lt;fib+0x30&gt;
@        return 1;
  28:	e3a03001 	mov	r3, #1                     @ 返回值存 r3 里, 跳转到返回
  2c:	ea00000a 	b	5c &lt;fib+0x5c&gt;
@    } else {
@        return fib(x - 1) + fib(x - 2);
  30:	e51b3010 	ldr	r3, [fp, #-16]             @ r3 读取第一个, 输入参数
  34:	e2433001 	sub	r3, r3, #1                 @ 减一
  38:	e1a00003 	mov	r0, r3                     @ 设好参数
  3c:	ebfffffe 	bl	0 &lt;fib&gt;	3c: R_ARM_CALL	fib @ 调函数
  40:	e1a04000 	mov	r4, r0                     @ r4 存返回值

  44:	e51b3010 	ldr	r3, [fp, #-16]
  48:	e2433002 	sub	r3, r3, #2
  4c:	e1a00003 	mov	r0, r3
  50:	ebfffffe 	bl	0 &lt;fib&gt;	50: R_ARM_CALL	fib
  54:	e1a03000 	mov	r3, r0                     @ r3 存返回值
  
  58:	e0843003 	add	r3, r4, r3                 @ r3 = r3 + r4
@    }

    /* ==================== 返回的处理 ====================== */
  5c:	e1a00003 	mov	r0, r3
  60:	e24bd008 	sub	sp, fp, #8                 @ 局部变量退栈
  64:	e8bd8810 	pop	{r4, fp, pc}               @ 直接把存着 lr 的内存格子给 pc (相当于 bx lr)

</code></pre>
<p>顺带一提 <code>O1</code> 优化的版本如下:</p>
<pre><code class="language-arm">
arm_stackframe.armv7.O1.o:     file format elf32-littlearm


Disassembly of section .text:

00000000 &lt;fib&gt;:
int fib(int x) {
    if (x == 1 || x == 2) {                    @ 对基本情况直接原地返回, 不操作栈
   0:	e2403001 	sub	r3, r0, #1
   4:	e3530001 	cmp	r3, #1
   8:	8a000001 	bhi	14 &lt;fib+0x14&gt;
        return 1;
   c:	e3a00001 	mov	r0, #1
    } else {
        return fib(x - 1) + fib(x - 2);
    }
  10:	e12fff1e 	bx	lr
int fib(int x) {
  14:	e92d4070 	push	{r4, r5, r6, lr}
  18:	e1a04000 	mov	r4, r0                        @ 这下没干存栈里再读回来的蠢事了
        return fib(x - 1) + fib(x - 2);
  1c:	e1a00003 	mov	r0, r3
  20:	ebfffffe 	bl	0 &lt;fib&gt;	20: R_ARM_CALL	fib
  24:	e1a05000 	mov	r5, r0
  28:	e2440002 	sub	r0, r4, #2
  2c:	ebfffffe 	bl	0 &lt;fib&gt;	2c: R_ARM_CALL	fib
  30:	e0850000 	add	r0, r5, r0
  34:	e8bd8070 	pop	{r4, r5, r6, pc}

</code></pre>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>除特殊注明部分，本站内容采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a> 进行许可。</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/Origami404" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://wiki.hitsz.org" target="_blank"><span>HITsz LUG wiki</span></a>
            </li>
            
            <li>
                <a href="https://space.bilibili.com/1124374292" target="_blank"><span>bilibili</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/arch/">Arch</a>
            </span>
            
            <span>
                <a href="/tags/arm/">ARM</a>
            </span>
            
            <span>
                <a href="/tags/c/">C</a>
            </span>
            
            <span>
                <a href="/tags/docker/">Docker</a>
            </span>
            
            <span>
                <a href="/tags/git/">Git</a>
            </span>
            
            <span>
                <a href="/tags/haskell/">Haskell</a>
            </span>
            
            <span>
                <a href="/tags/https/">HTTPS</a>
            </span>
            
            <span>
                <a href="/tags/linux-%E5%B7%A5%E5%85%B7/">linux 工具</a>
            </span>
            
            <span>
                <a href="/tags/llvm/">LLVM</a>
            </span>
            
            <span>
                <a href="/tags/mgit/">mgit</a>
            </span>
            
            <span>
                <a href="/tags/python/">Python</a>
            </span>
            
            <span>
                <a href="/tags/windows/">Windows</a>
            </span>
            
            <span>
                <a href="/tags/%E5%8F%98%E5%88%86%E6%B3%95/">变分法</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9F%9F%E5%90%8D/">域名</a>
            </span>
            
            <span>
                <a href="/tags/%E5%AF%BC%E8%AE%BA/">导论</a>
            </span>
            
            <span>
                <a href="/tags/%E6%88%91%E4%BC%9A%E7%86%9F%E7%BB%83%E5%9C%B0%E5%AE%89%E8%A3%85xxx%E7%B3%BB%E5%88%97/">我会熟练地安装xxx系列</a>
            </span>
            
            <span>
                <a href="/tags/%E6%8A%98%E8%85%BE/">折腾</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E5%AD%A6/">数学</a>
            </span>
            
            <span>
                <a href="/tags/%E6%96%B0%E8%A7%82%E7%82%B9/">新观点</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/">服务器管理</a>
            </span>
            
            <span>
                <a href="/tags/%E6%AF%95%E6%98%87%E6%9D%AF/">毕昇杯</a>
            </span>
            
            <span>
                <a href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
            </span>
            
            <span>
                <a href="/tags/%E7%90%86%E8%AE%BA%E7%89%A9%E7%90%86/">理论物理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%B3%9F%E7%B3%95%E4%BD%86%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E4%B8%9C%E8%A5%BF/">糟糕但值得纪念的东西</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BA%BF%E4%BB%A3/">线代</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E7%A8%8B/">编程</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF/">编译前端</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E7%95%99%E5%9C%B0/">自留地</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/">自言自语</a>
            </span>
            
            <span>
                <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
            </span>
            
            <span>
                <a href="/tags/%E8%BD%AE%E5%AD%90/">轮子</a>
            </span>
            
            <span>
                <a href="/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/">非技术</a>
            </span>
            
        </div>
    </div>
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#总览">总览</a></li>
    <li><a href="#基本架构">基本架构</a>
      <ul>
        <li><a href="#第一个程序--如何运行">第一个程序 &amp; 如何运行</a></li>
        <li><a href="#解释">解释</a></li>
        <li><a href="#直接使用-ld">直接使用 LD</a></li>
      </ul>
    </li>
    <li><a href="#寄存器">寄存器</a></li>
    <li><a href="#内存">内存</a>
      <ul>
        <li><a href="#地址">地址</a></li>
        <li><a href="#load">Load</a></li>
        <li><a href="#store">Store</a></li>
      </ul>
    </li>
    <li><a href="#gdb">GDB</a></li>
    <li><a href="#分支-branching">分支 (Branching)</a>
      <ul>
        <li><a href="#无条件跳转">无条件跳转</a></li>
        <li><a href="#有条件跳转">有条件跳转</a></li>
      </ul>
    </li>
    <li><a href="#实现控制流">实现控制流</a>
      <ul>
        <li><a href="#ifthenelse">if/then/else</a></li>
        <li><a href="#while">while</a></li>
        <li><a href="#for">for</a></li>
      </ul>
    </li>
    <li><a href="#更紧凑的指令--取址模式">更紧凑的指令 / 取址模式</a>
      <ul>
        <li><a href="#indexing-modes--指令参数类型">Indexing modes / 指令参数类型</a></li>
        <li><a href="#位移运算数">位移运算数</a></li>
      </ul>
    </li>
    <li><a href="#数组与结构体">数组与结构体</a>
      <ul>
        <li><a href="#定义分配空间">定义/分配空间</a></li>
        <li><a href="#indexing-mode--索引模式--取址模式">Indexing mode / 索引模式 / 取址模式</a></li>
        <li><a href="#访问">访问</a></li>
      </ul>
    </li>
    <li><a href="#函数">函数</a>
      <ul>
        <li><a href="#基本知识">基本知识</a></li>
        <li><a href="#参数传递">参数传递</a></li>
        <li><a href="#好函数">&ldquo;好&quot;函数</a></li>
        <li><a href="#调用函数">调用函数</a></li>
        <li><a href="#离开函数">离开函数</a></li>
        <li><a href="#返回值">返回值</a></li>
        <li><a href="#实例-hello-world-调用-c-标准库函数">实例: Hello World (调用 C 标准库函数)</a></li>
      </ul>
    </li>
    <li><a href="#栈">栈</a>
      <ul>
        <li><a href="#基本理论">基本理论</a></li>
        <li><a href="#阶乘程序">阶乘程序</a></li>
        <li><a href="#快速保存各种寄存器-ldm--stm">快速保存各种寄存器: ldm &amp; stm</a></li>
      </ul>
    </li>
    <li><a href="#条件执行">条件执行</a></li>
    <li><a href="#局部变量">局部变量</a>
      <ul>
        <li><a href="#快速总结">快速总结</a></li>
        <li><a href="#动手过程">动手过程</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/Origami404" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://wiki.hitsz.org" target="_blank"><span>HITsz LUG wiki</span></a>
            </li>
            
            <li>
                <a href="https://space.bilibili.com/1124374292" target="_blank"><span>bilibili</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/arch/">Arch</a>
            </span>
            
            <span>
                <a href="/tags/arm/">ARM</a>
            </span>
            
            <span>
                <a href="/tags/c/">C</a>
            </span>
            
            <span>
                <a href="/tags/docker/">Docker</a>
            </span>
            
            <span>
                <a href="/tags/git/">Git</a>
            </span>
            
            <span>
                <a href="/tags/haskell/">Haskell</a>
            </span>
            
            <span>
                <a href="/tags/https/">HTTPS</a>
            </span>
            
            <span>
                <a href="/tags/linux-%E5%B7%A5%E5%85%B7/">linux 工具</a>
            </span>
            
            <span>
                <a href="/tags/llvm/">LLVM</a>
            </span>
            
            <span>
                <a href="/tags/mgit/">mgit</a>
            </span>
            
            <span>
                <a href="/tags/python/">Python</a>
            </span>
            
            <span>
                <a href="/tags/windows/">Windows</a>
            </span>
            
            <span>
                <a href="/tags/%E5%8F%98%E5%88%86%E6%B3%95/">变分法</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9F%9F%E5%90%8D/">域名</a>
            </span>
            
            <span>
                <a href="/tags/%E5%AF%BC%E8%AE%BA/">导论</a>
            </span>
            
            <span>
                <a href="/tags/%E6%88%91%E4%BC%9A%E7%86%9F%E7%BB%83%E5%9C%B0%E5%AE%89%E8%A3%85xxx%E7%B3%BB%E5%88%97/">我会熟练地安装xxx系列</a>
            </span>
            
            <span>
                <a href="/tags/%E6%8A%98%E8%85%BE/">折腾</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E5%AD%A6/">数学</a>
            </span>
            
            <span>
                <a href="/tags/%E6%96%B0%E8%A7%82%E7%82%B9/">新观点</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/">服务器管理</a>
            </span>
            
            <span>
                <a href="/tags/%E6%AF%95%E6%98%87%E6%9D%AF/">毕昇杯</a>
            </span>
            
            <span>
                <a href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
            </span>
            
            <span>
                <a href="/tags/%E7%90%86%E8%AE%BA%E7%89%A9%E7%90%86/">理论物理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%B3%9F%E7%B3%95%E4%BD%86%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E4%B8%9C%E8%A5%BF/">糟糕但值得纪念的东西</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BA%BF%E4%BB%A3/">线代</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E7%A8%8B/">编程</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF/">编译前端</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E7%95%99%E5%9C%B0/">自留地</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/">自言自语</a>
            </span>
            
            <span>
                <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
            </span>
            
            <span>
                <a href="/tags/%E8%BD%AE%E5%AD%90/">轮子</a>
            </span>
            
            <span>
                <a href="/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/">非技术</a>
            </span>
            
        </div>
    </div>
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#总览">总览</a></li>
    <li><a href="#基本架构">基本架构</a>
      <ul>
        <li><a href="#第一个程序--如何运行">第一个程序 &amp; 如何运行</a></li>
        <li><a href="#解释">解释</a></li>
        <li><a href="#直接使用-ld">直接使用 LD</a></li>
      </ul>
    </li>
    <li><a href="#寄存器">寄存器</a></li>
    <li><a href="#内存">内存</a>
      <ul>
        <li><a href="#地址">地址</a></li>
        <li><a href="#load">Load</a></li>
        <li><a href="#store">Store</a></li>
      </ul>
    </li>
    <li><a href="#gdb">GDB</a></li>
    <li><a href="#分支-branching">分支 (Branching)</a>
      <ul>
        <li><a href="#无条件跳转">无条件跳转</a></li>
        <li><a href="#有条件跳转">有条件跳转</a></li>
      </ul>
    </li>
    <li><a href="#实现控制流">实现控制流</a>
      <ul>
        <li><a href="#ifthenelse">if/then/else</a></li>
        <li><a href="#while">while</a></li>
        <li><a href="#for">for</a></li>
      </ul>
    </li>
    <li><a href="#更紧凑的指令--取址模式">更紧凑的指令 / 取址模式</a>
      <ul>
        <li><a href="#indexing-modes--指令参数类型">Indexing modes / 指令参数类型</a></li>
        <li><a href="#位移运算数">位移运算数</a></li>
      </ul>
    </li>
    <li><a href="#数组与结构体">数组与结构体</a>
      <ul>
        <li><a href="#定义分配空间">定义/分配空间</a></li>
        <li><a href="#indexing-mode--索引模式--取址模式">Indexing mode / 索引模式 / 取址模式</a></li>
        <li><a href="#访问">访问</a></li>
      </ul>
    </li>
    <li><a href="#函数">函数</a>
      <ul>
        <li><a href="#基本知识">基本知识</a></li>
        <li><a href="#参数传递">参数传递</a></li>
        <li><a href="#好函数">&ldquo;好&quot;函数</a></li>
        <li><a href="#调用函数">调用函数</a></li>
        <li><a href="#离开函数">离开函数</a></li>
        <li><a href="#返回值">返回值</a></li>
        <li><a href="#实例-hello-world-调用-c-标准库函数">实例: Hello World (调用 C 标准库函数)</a></li>
      </ul>
    </li>
    <li><a href="#栈">栈</a>
      <ul>
        <li><a href="#基本理论">基本理论</a></li>
        <li><a href="#阶乘程序">阶乘程序</a></li>
        <li><a href="#快速保存各种寄存器-ldm--stm">快速保存各种寄存器: ldm &amp; stm</a></li>
      </ul>
    </li>
    <li><a href="#条件执行">条件执行</a></li>
    <li><a href="#局部变量">局部变量</a>
      <ul>
        <li><a href="#快速总结">快速总结</a></li>
        <li><a href="#动手过程">动手过程</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2019-2022
                <a href="https://blog.origami404.top/">Origami404</a>
                
                | 基于 <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 构建
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>



<script defer src="/assets/js/fuji.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" />
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"></script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"
></script>




</body>

</html>
