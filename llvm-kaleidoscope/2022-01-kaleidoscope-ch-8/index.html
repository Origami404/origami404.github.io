<!DOCTYPE html>
<html lang="zh-hans">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.92.2" />



<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png" />
<link rel="manifest" href="icons/site.webmanifest" />
<link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="icons/favicon.ico" />
<meta name="theme-color" content="#ffffff" />


<title>LLVM Kaleidoscope 第 8 章：编译到目标文件 - Origami404 的 Blog</title>


<meta name="author" content="Origami404" />


<meta name="description" content="有空的话就随便逛逛吧 www" />


<meta name="keywords" content="编译原理, 编译前端, LLVM, 翻译" />


<meta property="og:title" content="LLVM Kaleidoscope 第 8 章：编译到目标文件" />
<meta name="twitter:title" content="LLVM Kaleidoscope 第 8 章：编译到目标文件" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-8/" /><meta property="og:description" content="8.1 前言
欢迎来到 我的第一个基于 LLVM 的语言前端 教程第八章。本章将描述如何将我们实现的语言编译到目标文件 (object file)。" />
<meta name="twitter:description" content="8.1 前言
欢迎来到 我的第一个基于 LLVM 的语言前端 教程第八章。本章将描述如何将我们实现的语言编译到目标文件 (object file)。" /><meta property="og:image" content="https://blog.origami404.top/img/og.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://blog.origami404.top/img/og.png" /><meta property="article:published_time" content="2022-01-18T22:00:00+08:00" /><meta property="article:modified_time" content="2022-01-18T22:00:00+08:00" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>




<link rel="stylesheet" href="https://blog.origami404.top/assets/css/fuji.min.css" />








</head>

<body
  data-theme="auto"
  data-theme-auto='true'
  >
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://blog.origami404.top/">Origami404 的 Blog</a>
            
            <span class="title-sub">有空的话就随便逛逛吧 www</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-8/">LLVM Kaleidoscope 第 8 章：编译到目标文件</a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;2022-01-18</span>

<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;5184 字</span>

<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86">编译原理</a>&nbsp;<a href="/tags/%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF">编译前端</a>&nbsp;<a href="/tags/llvm">LLVM</a>&nbsp;<a href="/tags/%E7%BF%BB%E8%AF%91">翻译</a>&nbsp;</span>

    </div>
    
    <div class="post-content markdown-body">
        <h2 id="81-前言">8.1 前言</h2>
<p>欢迎来到 <a href="/llvm-kaleidoscope/2022-01-kaleidoscope-ch-0">我的第一个基于 LLVM 的语言前端</a> 教程第八章。本章将描述如何将我们实现的语言编译到目标文件 (object file)。</p>
<h2 id="82-选择目标平台">8.2 选择目标平台</h2>
<p>LLVM 对交叉编译 (cross-compilation) 有原生支持，你既可以编译到你当前的机器架构上，也可以很轻松地编译到其他架构上。在本章，我们将为当前机器生成目标文件。</p>
<p>为了指定目标平台，我们使用一种名为 &ldquo;目标三元组 (target triple)&rdquo; 的字符串，其形如 <code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>. (参见<a href="https://clang.llvm.org/docs/CrossCompilation.html#target-triple" target="_blank">交叉编译的文档</a>)</p>
<p>作为示例，我们可以看看 clang 认定的当前平台的目标三元组：</p>
<pre><code class="language-bash">$ clang --version | grep Target
Target: x86_64-unknown-linux-gnu
</code></pre>
<p>如果你使用不同架构的计算机或者不同的操作系统，那么上面的输出有可能会不一样。</p>
<p>幸运的是，我们并不需要将当前平台的目标三元组硬编码到我们的代码里。LLVM 提供了函数 <code>sys::getDefaultTargetTriple</code>, 可以获得当前机器的目标三元组。</p>
<pre><code class="language-cpp">auto TargetTriple = sys::getDefaultTargetTriple();
</code></pre>
<p>LLVM 并不要求我们链接上目标平台的所有功能 (target functionality)。比如说，假设我们只想运行 JIT，我们并不需要汇编输出函数 (assembly printers) 支持。同样，假如我们只关心某个特定目标架构，我们也可以只为那些架构链接功能。</p>
<p>对于本章，我们将为目标代码的生成初始化所有的目标平台。</p>
<pre><code class="language-cpp">InitializeAllTargetInfos();
InitializeAllTargets();
InitializeAllTargetMCs();
InitializeAllAsmParsers();
InitializeAllAsmPrinters();
</code></pre>
<p>现在我们可以通过目标三元组获得到目标平台的信息了：</p>
<pre><code class="language-cpp">std::string Error;
auto Target = TargetRegistry::lookupTarget(TargetTriple, Error);

// Print an error and exit if we couldn't find the requested target.
// This generally occurs if we've forgotten to initialise the
// TargetRegistry or we have a bogus target triple.
// 如果找不到目标平台，那么就报错
// 当我们忘记初始化 TargetRegistry 或者传入了不合法的目标三元组的时候
// 这就会发生
if (!Target) {
  errs() &lt;&lt; Error;
  return 1;
}
</code></pre>
<h2 id="83-目标机器-targetmachine">8.3 目标机器 (<code>TargetMachine</code>)</h2>
<p>我们还需要创建一个 <code>TargetMachine</code>. 这个类提供了对目标机器完整的机器级信息描述。如果我们需要生成某个目标机器上特定的功能 (比如 SSE) 或者是对特定 CPU 生成代码 (比如对 Intel Sandylake), 那么现在就是指定这些的时候了。</p>
<p>如果想知道 LLVM 支持哪些 CPU 或者是哪些特性，我们可以使用 <code>llc</code> 命令。比如说，对于 <code>x86</code>:</p>
<pre><code class="language-bash">$ llvm-as &lt; /dev/null | llc -march=x86 -mattr=help
Available CPUs for this target:

  amdfam10      - Select the amdfam10 processor.
  athlon        - Select the athlon processor.
  athlon-4      - Select the athlon-4 processor.
  ...

Available features for this target:

  16bit-mode            - 16-bit mode (i8086).
  32bit-mode            - 32-bit mode (80386).
  3dnow                 - Enable 3DNow! instructions.
  3dnowa                - Enable 3DNow! Athlon instructions.
  ...
</code></pre>
<p>对于本章，我们将为通用的 CPU 生成代码，并且不指定任何特定功能、选项或重定位模型。</p>
<pre><code class="language-cpp">auto CPU = &quot;generic&quot;;
auto Features = &quot;&quot;;

TargetOptions opt;
auto RM = Optional&lt;Reloc::Model&gt;();
auto TargetMachine = Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);
</code></pre>
<h2 id="84-配置模块">8.4 配置模块</h2>
<p>我们现在可以开始配置我们的模块使其适应于特定的目标平台和数据布局 (data layout) 了。事实上，这一步并非必须，但<a href="https://llvm.org/docs/tutorial/Frontend/PerformanceTips.html" target="_blank">前端性能指南</a>推荐我们这样做。优化过程将受益于知道更多目标平台的信息。</p>
<pre><code class="language-cpp">TheModule-&gt;setDataLayout(TargetMachine-&gt;createDataLayout());
TheModule-&gt;setTargetTriple(TargetTriple);
</code></pre>
<h2 id="85-生成的目标代码的指针并将其转换为合适的类型">8.5 生成的目标代码的指针并将其转换为合适的类型</h2>
<p>终于，我们可以开始生成目标代码了。首先让我们设定输出文件：</p>
<pre><code class="language-cpp">auto Filename = &quot;output.o&quot;;
std::error_code EC;
raw_fd_ostream dest(Filename, EC, sys::fs::OF_None);

if (EC) {
  errs() &lt;&lt; &quot;Could not open file: &quot; &lt;&lt; EC.message();
  return 1;
}
</code></pre>
<p>随后，我们为生成目标文件定义一个过程 (pass), 然后运行它：</p>
<pre><code class="language-cpp">legacy::PassManager pass;
auto FileType = CGFT_ObjectFile;

if (TargetMachine-&gt;addPassesToEmitFile(pass, dest, nullptr, FileType)) {
  errs() &lt;&lt; &quot;TargetMachine can't emit a file of this type&quot;;
  return 1;
}

pass.run(*TheModule);
dest.flush();
</code></pre>
<h2 id="86-最后组装">8.6 最后组装</h2>
<p>我们成功了吗？让我们来测试一下。首先我们编译我们的代码，注意此处 <code>llvm-config</code> 的参数与前几章不同：</p>
<pre><code class="language-bash">$ clang++ -g -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs all` -o toy
</code></pre>
<p>然后运行我们的程序，然后定义一个简单的 <code>average</code> (求平均值) 函数。输入完成后键入 Ctrl+D.</p>
<pre><code class="language-bash">$ ./toy
ready&gt; def average(x y) (x + y) * 0.5;
^D
Wrote output.o
</code></pre>
<p>现在我们有一个目标文件了。为了测试它，我们来写一个简单的程序并将目标文件链接到其上：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

extern &quot;C&quot; {
    double average(double, double);
}

int main() {
    std::cout &lt;&lt; &quot;average of 3.0 and 4.0: &quot; &lt;&lt; average(3.0, 4.0) &lt;&lt; std::endl;
}
</code></pre>
<p>在编译并链接好程序之后，我们就可以检查输出是否符合我们的预期了：</p>
<pre><code class="language-bash">$ clang++ main.cpp output.o -o main
$ ./main
average of 3.0 and 4.0: 3.5
</code></pre>
<h2 id="87-完整代码">8.7 完整代码</h2>
<pre><code class="language-cpp">#include &quot;llvm/ADT/APFloat.h&quot;
#include &quot;llvm/ADT/Optional.h&quot;
#include &quot;llvm/ADT/STLExtras.h&quot;
#include &quot;llvm/IR/BasicBlock.h&quot;
#include &quot;llvm/IR/Constants.h&quot;
#include &quot;llvm/IR/DerivedTypes.h&quot;
#include &quot;llvm/IR/Function.h&quot;
#include &quot;llvm/IR/IRBuilder.h&quot;
#include &quot;llvm/IR/Instructions.h&quot;
#include &quot;llvm/IR/LLVMContext.h&quot;
#include &quot;llvm/IR/LegacyPassManager.h&quot;
#include &quot;llvm/IR/Module.h&quot;
#include &quot;llvm/IR/Type.h&quot;
#include &quot;llvm/IR/Verifier.h&quot;
#include &quot;llvm/MC/TargetRegistry.h&quot;
#include &quot;llvm/Support/FileSystem.h&quot;
#include &quot;llvm/Support/Host.h&quot;
#include &quot;llvm/Support/TargetSelect.h&quot;
#include &quot;llvm/Support/raw_ostream.h&quot;
#include &quot;llvm/Target/TargetMachine.h&quot;
#include &quot;llvm/Target/TargetOptions.h&quot;
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;system_error&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

using namespace llvm;
using namespace llvm::sys;

//===----------------------------------------------------------------------===//
// Lexer
//===----------------------------------------------------------------------===//

// The lexer returns tokens [0-255] if it is an unknown character, otherwise one
// of these for known things.
enum Token {
  tok_eof = -1,

  // commands
  tok_def = -2,
  tok_extern = -3,

  // primary
  tok_identifier = -4,
  tok_number = -5,

  // control
  tok_if = -6,
  tok_then = -7,
  tok_else = -8,
  tok_for = -9,
  tok_in = -10,

  // operators
  tok_binary = -11,
  tok_unary = -12,

  // var definition
  tok_var = -13
};

static std::string IdentifierStr; // Filled in if tok_identifier
static double NumVal;             // Filled in if tok_number

/// gettok - Return the next token from standard input.
static int gettok() {
  static int LastChar = ' ';

  // Skip any whitespace.
  while (isspace(LastChar))
    LastChar = getchar();

  if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]*
    IdentifierStr = LastChar;
    while (isalnum((LastChar = getchar())))
      IdentifierStr += LastChar;

    if (IdentifierStr == &quot;def&quot;)
      return tok_def;
    if (IdentifierStr == &quot;extern&quot;)
      return tok_extern;
    if (IdentifierStr == &quot;if&quot;)
      return tok_if;
    if (IdentifierStr == &quot;then&quot;)
      return tok_then;
    if (IdentifierStr == &quot;else&quot;)
      return tok_else;
    if (IdentifierStr == &quot;for&quot;)
      return tok_for;
    if (IdentifierStr == &quot;in&quot;)
      return tok_in;
    if (IdentifierStr == &quot;binary&quot;)
      return tok_binary;
    if (IdentifierStr == &quot;unary&quot;)
      return tok_unary;
    if (IdentifierStr == &quot;var&quot;)
      return tok_var;
    return tok_identifier;
  }

  if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+
    std::string NumStr;
    do {
      NumStr += LastChar;
      LastChar = getchar();
    } while (isdigit(LastChar) || LastChar == '.');

    NumVal = strtod(NumStr.c_str(), nullptr);
    return tok_number;
  }

  if (LastChar == '#') {
    // Comment until end of line.
    do
      LastChar = getchar();
    while (LastChar != EOF &amp;&amp; LastChar != '\n' &amp;&amp; LastChar != '\r');

    if (LastChar != EOF)
      return gettok();
  }

  // Check for end of file.  Don't eat the EOF.
  if (LastChar == EOF)
    return tok_eof;

  // Otherwise, just return the character as its ascii value.
  int ThisChar = LastChar;
  LastChar = getchar();
  return ThisChar;
}

//===----------------------------------------------------------------------===//
// Abstract Syntax Tree (aka Parse Tree)
//===----------------------------------------------------------------------===//

namespace {

/// ExprAST - Base class for all expression nodes.
class ExprAST {
public:
  virtual ~ExprAST() = default;

  virtual Value *codegen() = 0;
};

/// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;.
class NumberExprAST : public ExprAST {
  double Val;

public:
  NumberExprAST(double Val) : Val(Val) {}

  Value *codegen() override;
};

/// VariableExprAST - Expression class for referencing a variable, like &quot;a&quot;.
class VariableExprAST : public ExprAST {
  std::string Name;

public:
  VariableExprAST(const std::string &amp;Name) : Name(Name) {}

  Value *codegen() override;
  const std::string &amp;getName() const { return Name; }
};

/// UnaryExprAST - Expression class for a unary operator.
class UnaryExprAST : public ExprAST {
  char Opcode;
  std::unique_ptr&lt;ExprAST&gt; Operand;

public:
  UnaryExprAST(char Opcode, std::unique_ptr&lt;ExprAST&gt; Operand)
      : Opcode(Opcode), Operand(std::move(Operand)) {}

  Value *codegen() override;
};

/// BinaryExprAST - Expression class for a binary operator.
class BinaryExprAST : public ExprAST {
  char Op;
  std::unique_ptr&lt;ExprAST&gt; LHS, RHS;

public:
  BinaryExprAST(char Op, std::unique_ptr&lt;ExprAST&gt; LHS,
                std::unique_ptr&lt;ExprAST&gt; RHS)
      : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {}

  Value *codegen() override;
};

/// CallExprAST - Expression class for function calls.
class CallExprAST : public ExprAST {
  std::string Callee;
  std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;

public:
  CallExprAST(const std::string &amp;Callee,
              std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args)
      : Callee(Callee), Args(std::move(Args)) {}

  Value *codegen() override;
};

/// IfExprAST - Expression class for if/then/else.
class IfExprAST : public ExprAST {
  std::unique_ptr&lt;ExprAST&gt; Cond, Then, Else;

public:
  IfExprAST(std::unique_ptr&lt;ExprAST&gt; Cond, std::unique_ptr&lt;ExprAST&gt; Then,
            std::unique_ptr&lt;ExprAST&gt; Else)
      : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {}

  Value *codegen() override;
};

/// ForExprAST - Expression class for for/in.
class ForExprAST : public ExprAST {
  std::string VarName;
  std::unique_ptr&lt;ExprAST&gt; Start, End, Step, Body;

public:
  ForExprAST(const std::string &amp;VarName, std::unique_ptr&lt;ExprAST&gt; Start,
             std::unique_ptr&lt;ExprAST&gt; End, std::unique_ptr&lt;ExprAST&gt; Step,
             std::unique_ptr&lt;ExprAST&gt; Body)
      : VarName(VarName), Start(std::move(Start)), End(std::move(End)),
        Step(std::move(Step)), Body(std::move(Body)) {}

  Value *codegen() override;
};

/// VarExprAST - Expression class for var/in
class VarExprAST : public ExprAST {
  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames;
  std::unique_ptr&lt;ExprAST&gt; Body;

public:
  VarExprAST(
      std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames,
      std::unique_ptr&lt;ExprAST&gt; Body)
      : VarNames(std::move(VarNames)), Body(std::move(Body)) {}

  Value *codegen() override;
};

/// PrototypeAST - This class represents the &quot;prototype&quot; for a function,
/// which captures its name, and its argument names (thus implicitly the number
/// of arguments the function takes), as well as if it is an operator.
class PrototypeAST {
  std::string Name;
  std::vector&lt;std::string&gt; Args;
  bool IsOperator;
  unsigned Precedence; // Precedence if a binary op.

public:
  PrototypeAST(const std::string &amp;Name, std::vector&lt;std::string&gt; Args,
               bool IsOperator = false, unsigned Prec = 0)
      : Name(Name), Args(std::move(Args)), IsOperator(IsOperator),
        Precedence(Prec) {}

  Function *codegen();
  const std::string &amp;getName() const { return Name; }

  bool isUnaryOp() const { return IsOperator &amp;&amp; Args.size() == 1; }
  bool isBinaryOp() const { return IsOperator &amp;&amp; Args.size() == 2; }

  char getOperatorName() const {
    assert(isUnaryOp() || isBinaryOp());
    return Name[Name.size() - 1];
  }

  unsigned getBinaryPrecedence() const { return Precedence; }
};

/// FunctionAST - This class represents a function definition itself.
class FunctionAST {
  std::unique_ptr&lt;PrototypeAST&gt; Proto;
  std::unique_ptr&lt;ExprAST&gt; Body;

public:
  FunctionAST(std::unique_ptr&lt;PrototypeAST&gt; Proto,
              std::unique_ptr&lt;ExprAST&gt; Body)
      : Proto(std::move(Proto)), Body(std::move(Body)) {}

  Function *codegen();
};

} // end anonymous namespace

//===----------------------------------------------------------------------===//
// Parser
//===----------------------------------------------------------------------===//

/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current
/// token the parser is looking at.  getNextToken reads another token from the
/// lexer and updates CurTok with its results.
static int CurTok;
static int getNextToken() { return CurTok = gettok(); }

/// BinopPrecedence - This holds the precedence for each binary operator that is
/// defined.
static std::map&lt;char, int&gt; BinopPrecedence;

/// GetTokPrecedence - Get the precedence of the pending binary operator token.
static int GetTokPrecedence() {
  if (!isascii(CurTok))
    return -1;

  // Make sure it's a declared binop.
  int TokPrec = BinopPrecedence[CurTok];
  if (TokPrec &lt;= 0)
    return -1;
  return TokPrec;
}

/// LogError* - These are little helper functions for error handling.
std::unique_ptr&lt;ExprAST&gt; LogError(const char *Str) {
  fprintf(stderr, &quot;Error: %s\n&quot;, Str);
  return nullptr;
}

std::unique_ptr&lt;PrototypeAST&gt; LogErrorP(const char *Str) {
  LogError(Str);
  return nullptr;
}

static std::unique_ptr&lt;ExprAST&gt; ParseExpression();

/// numberexpr ::= number
static std::unique_ptr&lt;ExprAST&gt; ParseNumberExpr() {
  auto Result = std::make_unique&lt;NumberExprAST&gt;(NumVal);
  getNextToken(); // consume the number
  return std::move(Result);
}

/// parenexpr ::= '(' expression ')'
static std::unique_ptr&lt;ExprAST&gt; ParseParenExpr() {
  getNextToken(); // eat (.
  auto V = ParseExpression();
  if (!V)
    return nullptr;

  if (CurTok != ')')
    return LogError(&quot;expected ')'&quot;);
  getNextToken(); // eat ).
  return V;
}

/// identifierexpr
///   ::= identifier
///   ::= identifier '(' expression* ')'
static std::unique_ptr&lt;ExprAST&gt; ParseIdentifierExpr() {
  std::string IdName = IdentifierStr;

  getNextToken(); // eat identifier.

  if (CurTok != '(') // Simple variable ref.
    return std::make_unique&lt;VariableExprAST&gt;(IdName);

  // Call.
  getNextToken(); // eat (
  std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;
  if (CurTok != ')') {
    while (true) {
      if (auto Arg = ParseExpression())
        Args.push_back(std::move(Arg));
      else
        return nullptr;

      if (CurTok == ')')
        break;

      if (CurTok != ',')
        return LogError(&quot;Expected ')' or ',' in argument list&quot;);
      getNextToken();
    }
  }

  // Eat the ')'.
  getNextToken();

  return std::make_unique&lt;CallExprAST&gt;(IdName, std::move(Args));
}

/// ifexpr ::= 'if' expression 'then' expression 'else' expression
static std::unique_ptr&lt;ExprAST&gt; ParseIfExpr() {
  getNextToken(); // eat the if.

  // condition.
  auto Cond = ParseExpression();
  if (!Cond)
    return nullptr;

  if (CurTok != tok_then)
    return LogError(&quot;expected then&quot;);
  getNextToken(); // eat the then

  auto Then = ParseExpression();
  if (!Then)
    return nullptr;

  if (CurTok != tok_else)
    return LogError(&quot;expected else&quot;);

  getNextToken();

  auto Else = ParseExpression();
  if (!Else)
    return nullptr;

  return std::make_unique&lt;IfExprAST&gt;(std::move(Cond), std::move(Then),
                                      std::move(Else));
}

/// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression
static std::unique_ptr&lt;ExprAST&gt; ParseForExpr() {
  getNextToken(); // eat the for.

  if (CurTok != tok_identifier)
    return LogError(&quot;expected identifier after for&quot;);

  std::string IdName = IdentifierStr;
  getNextToken(); // eat identifier.

  if (CurTok != '=')
    return LogError(&quot;expected '=' after for&quot;);
  getNextToken(); // eat '='.

  auto Start = ParseExpression();
  if (!Start)
    return nullptr;
  if (CurTok != ',')
    return LogError(&quot;expected ',' after for start value&quot;);
  getNextToken();

  auto End = ParseExpression();
  if (!End)
    return nullptr;

  // The step value is optional.
  std::unique_ptr&lt;ExprAST&gt; Step;
  if (CurTok == ',') {
    getNextToken();
    Step = ParseExpression();
    if (!Step)
      return nullptr;
  }

  if (CurTok != tok_in)
    return LogError(&quot;expected 'in' after for&quot;);
  getNextToken(); // eat 'in'.

  auto Body = ParseExpression();
  if (!Body)
    return nullptr;

  return std::make_unique&lt;ForExprAST&gt;(IdName, std::move(Start), std::move(End),
                                       std::move(Step), std::move(Body));
}

/// varexpr ::= 'var' identifier ('=' expression)?
//                    (',' identifier ('=' expression)?)* 'in' expression
static std::unique_ptr&lt;ExprAST&gt; ParseVarExpr() {
  getNextToken(); // eat the var.

  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames;

  // At least one variable name is required.
  if (CurTok != tok_identifier)
    return LogError(&quot;expected identifier after var&quot;);

  while (true) {
    std::string Name = IdentifierStr;
    getNextToken(); // eat identifier.

    // Read the optional initializer.
    std::unique_ptr&lt;ExprAST&gt; Init = nullptr;
    if (CurTok == '=') {
      getNextToken(); // eat the '='.

      Init = ParseExpression();
      if (!Init)
        return nullptr;
    }

    VarNames.push_back(std::make_pair(Name, std::move(Init)));

    // End of var list, exit loop.
    if (CurTok != ',')
      break;
    getNextToken(); // eat the ','.

    if (CurTok != tok_identifier)
      return LogError(&quot;expected identifier list after var&quot;);
  }

  // At this point, we have to have 'in'.
  if (CurTok != tok_in)
    return LogError(&quot;expected 'in' keyword after 'var'&quot;);
  getNextToken(); // eat 'in'.

  auto Body = ParseExpression();
  if (!Body)
    return nullptr;

  return std::make_unique&lt;VarExprAST&gt;(std::move(VarNames), std::move(Body));
}

/// primary
///   ::= identifierexpr
///   ::= numberexpr
///   ::= parenexpr
///   ::= ifexpr
///   ::= forexpr
///   ::= varexpr
static std::unique_ptr&lt;ExprAST&gt; ParsePrimary() {
  switch (CurTok) {
  default:
    return LogError(&quot;unknown token when expecting an expression&quot;);
  case tok_identifier:
    return ParseIdentifierExpr();
  case tok_number:
    return ParseNumberExpr();
  case '(':
    return ParseParenExpr();
  case tok_if:
    return ParseIfExpr();
  case tok_for:
    return ParseForExpr();
  case tok_var:
    return ParseVarExpr();
  }
}

/// unary
///   ::= primary
///   ::= '!' unary
static std::unique_ptr&lt;ExprAST&gt; ParseUnary() {
  // If the current token is not an operator, it must be a primary expr.
  if (!isascii(CurTok) || CurTok == '(' || CurTok == ',')
    return ParsePrimary();

  // If this is a unary operator, read it.
  int Opc = CurTok;
  getNextToken();
  if (auto Operand = ParseUnary())
    return std::make_unique&lt;UnaryExprAST&gt;(Opc, std::move(Operand));
  return nullptr;
}

/// binoprhs
///   ::= ('+' unary)*
static std::unique_ptr&lt;ExprAST&gt; ParseBinOpRHS(int ExprPrec,
                                              std::unique_ptr&lt;ExprAST&gt; LHS) {
  // If this is a binop, find its precedence.
  while (true) {
    int TokPrec = GetTokPrecedence();

    // If this is a binop that binds at least as tightly as the current binop,
    // consume it, otherwise we are done.
    if (TokPrec &lt; ExprPrec)
      return LHS;

    // Okay, we know this is a binop.
    int BinOp = CurTok;
    getNextToken(); // eat binop

    // Parse the unary expression after the binary operator.
    auto RHS = ParseUnary();
    if (!RHS)
      return nullptr;

    // If BinOp binds less tightly with RHS than the operator after RHS, let
    // the pending operator take RHS as its LHS.
    int NextPrec = GetTokPrecedence();
    if (TokPrec &lt; NextPrec) {
      RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS));
      if (!RHS)
        return nullptr;
    }

    // Merge LHS/RHS.
    LHS =
        std::make_unique&lt;BinaryExprAST&gt;(BinOp, std::move(LHS), std::move(RHS));
  }
}

/// expression
///   ::= unary binoprhs
///
static std::unique_ptr&lt;ExprAST&gt; ParseExpression() {
  auto LHS = ParseUnary();
  if (!LHS)
    return nullptr;

  return ParseBinOpRHS(0, std::move(LHS));
}

/// prototype
///   ::= id '(' id* ')'
///   ::= binary LETTER number? (id, id)
///   ::= unary LETTER (id)
static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() {
  std::string FnName;

  unsigned Kind = 0; // 0 = identifier, 1 = unary, 2 = binary.
  unsigned BinaryPrecedence = 30;

  switch (CurTok) {
  default:
    return LogErrorP(&quot;Expected function name in prototype&quot;);
  case tok_identifier:
    FnName = IdentifierStr;
    Kind = 0;
    getNextToken();
    break;
  case tok_unary:
    getNextToken();
    if (!isascii(CurTok))
      return LogErrorP(&quot;Expected unary operator&quot;);
    FnName = &quot;unary&quot;;
    FnName += (char)CurTok;
    Kind = 1;
    getNextToken();
    break;
  case tok_binary:
    getNextToken();
    if (!isascii(CurTok))
      return LogErrorP(&quot;Expected binary operator&quot;);
    FnName = &quot;binary&quot;;
    FnName += (char)CurTok;
    Kind = 2;
    getNextToken();

    // Read the precedence if present.
    if (CurTok == tok_number) {
      if (NumVal &lt; 1 || NumVal &gt; 100)
        return LogErrorP(&quot;Invalid precedence: must be 1..100&quot;);
      BinaryPrecedence = (unsigned)NumVal;
      getNextToken();
    }
    break;
  }

  if (CurTok != '(')
    return LogErrorP(&quot;Expected '(' in prototype&quot;);

  std::vector&lt;std::string&gt; ArgNames;
  while (getNextToken() == tok_identifier)
    ArgNames.push_back(IdentifierStr);
  if (CurTok != ')')
    return LogErrorP(&quot;Expected ')' in prototype&quot;);

  // success.
  getNextToken(); // eat ')'.

  // Verify right number of names for operator.
  if (Kind &amp;&amp; ArgNames.size() != Kind)
    return LogErrorP(&quot;Invalid number of operands for operator&quot;);

  return std::make_unique&lt;PrototypeAST&gt;(FnName, ArgNames, Kind != 0,
                                         BinaryPrecedence);
}

/// definition ::= 'def' prototype expression
static std::unique_ptr&lt;FunctionAST&gt; ParseDefinition() {
  getNextToken(); // eat def.
  auto Proto = ParsePrototype();
  if (!Proto)
    return nullptr;

  if (auto E = ParseExpression())
    return std::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E));
  return nullptr;
}

/// toplevelexpr ::= expression
static std::unique_ptr&lt;FunctionAST&gt; ParseTopLevelExpr() {
  if (auto E = ParseExpression()) {
    // Make an anonymous proto.
    auto Proto = std::make_unique&lt;PrototypeAST&gt;(&quot;__anon_expr&quot;,
                                                 std::vector&lt;std::string&gt;());
    return std::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E));
  }
  return nullptr;
}

/// external ::= 'extern' prototype
static std::unique_ptr&lt;PrototypeAST&gt; ParseExtern() {
  getNextToken(); // eat extern.
  return ParsePrototype();
}

//===----------------------------------------------------------------------===//
// Code Generation
//===----------------------------------------------------------------------===//

static std::unique_ptr&lt;LLVMContext&gt; TheContext;
static std::unique_ptr&lt;Module&gt; TheModule;
static std::unique_ptr&lt;IRBuilder&lt;&gt;&gt; Builder;
static std::map&lt;std::string, AllocaInst *&gt; NamedValues;
static std::map&lt;std::string, std::unique_ptr&lt;PrototypeAST&gt;&gt; FunctionProtos;
static ExitOnError ExitOnErr;

Value *LogErrorV(const char *Str) {
  LogError(Str);
  return nullptr;
}

Function *getFunction(std::string Name) {
  // First, see if the function has already been added to the current module.
  if (auto *F = TheModule-&gt;getFunction(Name))
    return F;

  // If not, check whether we can codegen the declaration from some existing
  // prototype.
  auto FI = FunctionProtos.find(Name);
  if (FI != FunctionProtos.end())
    return FI-&gt;second-&gt;codegen();

  // If no existing prototype exists, return null.
  return nullptr;
}

/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of
/// the function.  This is used for mutable variables etc.
static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction,
                                          StringRef VarName) {
  IRBuilder&lt;&gt; TmpB(&amp;TheFunction-&gt;getEntryBlock(),
                   TheFunction-&gt;getEntryBlock().begin());
  return TmpB.CreateAlloca(Type::getDoubleTy(*TheContext), nullptr, VarName);
}

Value *NumberExprAST::codegen() {
  return ConstantFP::get(*TheContext, APFloat(Val));
}

Value *VariableExprAST::codegen() {
  // Look this variable up in the function.
  Value *V = NamedValues[Name];
  if (!V)
    return LogErrorV(&quot;Unknown variable name&quot;);

  // Load the value.
  return Builder-&gt;CreateLoad(Type::getDoubleTy(*TheContext), V, Name.c_str());
}

Value *UnaryExprAST::codegen() {
  Value *OperandV = Operand-&gt;codegen();
  if (!OperandV)
    return nullptr;

  Function *F = getFunction(std::string(&quot;unary&quot;) + Opcode);
  if (!F)
    return LogErrorV(&quot;Unknown unary operator&quot;);

  return Builder-&gt;CreateCall(F, OperandV, &quot;unop&quot;);
}

Value *BinaryExprAST::codegen() {
  // Special case '=' because we don't want to emit the LHS as an expression.
  if (Op == '=') {
    // Assignment requires the LHS to be an identifier.
    // This assume we're building without RTTI because LLVM builds that way by
    // default.  If you build LLVM with RTTI this can be changed to a
    // dynamic_cast for automatic error checking.
    VariableExprAST *LHSE = static_cast&lt;VariableExprAST *&gt;(LHS.get());
    if (!LHSE)
      return LogErrorV(&quot;destination of '=' must be a variable&quot;);
    // Codegen the RHS.
    Value *Val = RHS-&gt;codegen();
    if (!Val)
      return nullptr;

    // Look up the name.
    Value *Variable = NamedValues[LHSE-&gt;getName()];
    if (!Variable)
      return LogErrorV(&quot;Unknown variable name&quot;);

    Builder-&gt;CreateStore(Val, Variable);
    return Val;
  }

  Value *L = LHS-&gt;codegen();
  Value *R = RHS-&gt;codegen();
  if (!L || !R)
    return nullptr;

  switch (Op) {
  case '+':
    return Builder-&gt;CreateFAdd(L, R, &quot;addtmp&quot;);
  case '-':
    return Builder-&gt;CreateFSub(L, R, &quot;subtmp&quot;);
  case '*':
    return Builder-&gt;CreateFMul(L, R, &quot;multmp&quot;);
  case '&lt;':
    L = Builder-&gt;CreateFCmpULT(L, R, &quot;cmptmp&quot;);
    // Convert bool 0/1 to double 0.0 or 1.0
    return Builder-&gt;CreateUIToFP(L, Type::getDoubleTy(*TheContext), &quot;booltmp&quot;);
  default:
    break;
  }

  // If it wasn't a builtin binary operator, it must be a user defined one. Emit
  // a call to it.
  Function *F = getFunction(std::string(&quot;binary&quot;) + Op);
  assert(F &amp;&amp; &quot;binary operator not found!&quot;);

  Value *Ops[] = {L, R};
  return Builder-&gt;CreateCall(F, Ops, &quot;binop&quot;);
}

Value *CallExprAST::codegen() {
  // Look up the name in the global module table.
  Function *CalleeF = getFunction(Callee);
  if (!CalleeF)
    return LogErrorV(&quot;Unknown function referenced&quot;);

  // If argument mismatch error.
  if (CalleeF-&gt;arg_size() != Args.size())
    return LogErrorV(&quot;Incorrect # arguments passed&quot;);

  std::vector&lt;Value *&gt; ArgsV;
  for (unsigned i = 0, e = Args.size(); i != e; ++i) {
    ArgsV.push_back(Args[i]-&gt;codegen());
    if (!ArgsV.back())
      return nullptr;
  }

  return Builder-&gt;CreateCall(CalleeF, ArgsV, &quot;calltmp&quot;);
}

Value *IfExprAST::codegen() {
  Value *CondV = Cond-&gt;codegen();
  if (!CondV)
    return nullptr;

  // Convert condition to a bool by comparing non-equal to 0.0.
  CondV = Builder-&gt;CreateFCmpONE(
      CondV, ConstantFP::get(*TheContext, APFloat(0.0)), &quot;ifcond&quot;);

  Function *TheFunction = Builder-&gt;GetInsertBlock()-&gt;getParent();

  // Create blocks for the then and else cases.  Insert the 'then' block at the
  // end of the function.
  BasicBlock *ThenBB = BasicBlock::Create(*TheContext, &quot;then&quot;, TheFunction);
  BasicBlock *ElseBB = BasicBlock::Create(*TheContext, &quot;else&quot;);
  BasicBlock *MergeBB = BasicBlock::Create(*TheContext, &quot;ifcont&quot;);

  Builder-&gt;CreateCondBr(CondV, ThenBB, ElseBB);

  // Emit then value.
  Builder-&gt;SetInsertPoint(ThenBB);

  Value *ThenV = Then-&gt;codegen();
  if (!ThenV)
    return nullptr;

  Builder-&gt;CreateBr(MergeBB);
  // Codegen of 'Then' can change the current block, update ThenBB for the PHI.
  ThenBB = Builder-&gt;GetInsertBlock();

  // Emit else block.
  TheFunction-&gt;getBasicBlockList().push_back(ElseBB);
  Builder-&gt;SetInsertPoint(ElseBB);

  Value *ElseV = Else-&gt;codegen();
  if (!ElseV)
    return nullptr;

  Builder-&gt;CreateBr(MergeBB);
  // Codegen of 'Else' can change the current block, update ElseBB for the PHI.
  ElseBB = Builder-&gt;GetInsertBlock();

  // Emit merge block.
  TheFunction-&gt;getBasicBlockList().push_back(MergeBB);
  Builder-&gt;SetInsertPoint(MergeBB);
  PHINode *PN = Builder-&gt;CreatePHI(Type::getDoubleTy(*TheContext), 2, &quot;iftmp&quot;);

  PN-&gt;addIncoming(ThenV, ThenBB);
  PN-&gt;addIncoming(ElseV, ElseBB);
  return PN;
}

// Output for-loop as:
//   var = alloca double
//   ...
//   start = startexpr
//   store start -&gt; var
//   goto loop
// loop:
//   ...
//   bodyexpr
//   ...
// loopend:
//   step = stepexpr
//   endcond = endexpr
//
//   curvar = load var
//   nextvar = curvar + step
//   store nextvar -&gt; var
//   br endcond, loop, endloop
// outloop:
Value *ForExprAST::codegen() {
  Function *TheFunction = Builder-&gt;GetInsertBlock()-&gt;getParent();

  // Create an alloca for the variable in the entry block.
  AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);

  // Emit the start code first, without 'variable' in scope.
  Value *StartVal = Start-&gt;codegen();
  if (!StartVal)
    return nullptr;

  // Store the value into the alloca.
  Builder-&gt;CreateStore(StartVal, Alloca);

  // Make the new basic block for the loop header, inserting after current
  // block.
  BasicBlock *LoopBB = BasicBlock::Create(*TheContext, &quot;loop&quot;, TheFunction);

  // Insert an explicit fall through from the current block to the LoopBB.
  Builder-&gt;CreateBr(LoopBB);

  // Start insertion in LoopBB.
  Builder-&gt;SetInsertPoint(LoopBB);

  // Within the loop, the variable is defined equal to the PHI node.  If it
  // shadows an existing variable, we have to restore it, so save it now.
  AllocaInst *OldVal = NamedValues[VarName];
  NamedValues[VarName] = Alloca;

  // Emit the body of the loop.  This, like any other expr, can change the
  // current BB.  Note that we ignore the value computed by the body, but don't
  // allow an error.
  if (!Body-&gt;codegen())
    return nullptr;

  // Emit the step value.
  Value *StepVal = nullptr;
  if (Step) {
    StepVal = Step-&gt;codegen();
    if (!StepVal)
      return nullptr;
  } else {
    // If not specified, use 1.0.
    StepVal = ConstantFP::get(*TheContext, APFloat(1.0));
  }

  // Compute the end condition.
  Value *EndCond = End-&gt;codegen();
  if (!EndCond)
    return nullptr;

  // Reload, increment, and restore the alloca.  This handles the case where
  // the body of the loop mutates the variable.
  Value *CurVar = Builder-&gt;CreateLoad(Type::getDoubleTy(*TheContext), Alloca,
                                      VarName.c_str());
  Value *NextVar = Builder-&gt;CreateFAdd(CurVar, StepVal, &quot;nextvar&quot;);
  Builder-&gt;CreateStore(NextVar, Alloca);

  // Convert condition to a bool by comparing non-equal to 0.0.
  EndCond = Builder-&gt;CreateFCmpONE(
      EndCond, ConstantFP::get(*TheContext, APFloat(0.0)), &quot;loopcond&quot;);

  // Create the &quot;after loop&quot; block and insert it.
  BasicBlock *AfterBB =
      BasicBlock::Create(*TheContext, &quot;afterloop&quot;, TheFunction);

  // Insert the conditional branch into the end of LoopEndBB.
  Builder-&gt;CreateCondBr(EndCond, LoopBB, AfterBB);

  // Any new code will be inserted in AfterBB.
  Builder-&gt;SetInsertPoint(AfterBB);

  // Restore the unshadowed variable.
  if (OldVal)
    NamedValues[VarName] = OldVal;
  else
    NamedValues.erase(VarName);

  // for expr always returns 0.0.
  return Constant::getNullValue(Type::getDoubleTy(*TheContext));
}

Value *VarExprAST::codegen() {
  std::vector&lt;AllocaInst *&gt; OldBindings;

  Function *TheFunction = Builder-&gt;GetInsertBlock()-&gt;getParent();

  // Register all variables and emit their initializer.
  for (unsigned i = 0, e = VarNames.size(); i != e; ++i) {
    const std::string &amp;VarName = VarNames[i].first;
    ExprAST *Init = VarNames[i].second.get();

    // Emit the initializer before adding the variable to scope, this prevents
    // the initializer from referencing the variable itself, and permits stuff
    // like this:
    //  var a = 1 in
    //    var a = a in ...   # refers to outer 'a'.
    Value *InitVal;
    if (Init) {
      InitVal = Init-&gt;codegen();
      if (!InitVal)
        return nullptr;
    } else { // If not specified, use 0.0.
      InitVal = ConstantFP::get(*TheContext, APFloat(0.0));
    }

    AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);
    Builder-&gt;CreateStore(InitVal, Alloca);

    // Remember the old variable binding so that we can restore the binding when
    // we unrecurse.
    OldBindings.push_back(NamedValues[VarName]);

    // Remember this binding.
    NamedValues[VarName] = Alloca;
  }

  // Codegen the body, now that all vars are in scope.
  Value *BodyVal = Body-&gt;codegen();
  if (!BodyVal)
    return nullptr;

  // Pop all our variables from scope.
  for (unsigned i = 0, e = VarNames.size(); i != e; ++i)
    NamedValues[VarNames[i].first] = OldBindings[i];

  // Return the body computation.
  return BodyVal;
}

Function *PrototypeAST::codegen() {
  // Make the function type:  double(double,double) etc.
  std::vector&lt;Type *&gt; Doubles(Args.size(), Type::getDoubleTy(*TheContext));
  FunctionType *FT =
      FunctionType::get(Type::getDoubleTy(*TheContext), Doubles, false);

  Function *F =
      Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());

  // Set names for all arguments.
  unsigned Idx = 0;
  for (auto &amp;Arg : F-&gt;args())
    Arg.setName(Args[Idx++]);

  return F;
}

Function *FunctionAST::codegen() {
  // Transfer ownership of the prototype to the FunctionProtos map, but keep a
  // reference to it for use below.
  auto &amp;P = *Proto;
  FunctionProtos[Proto-&gt;getName()] = std::move(Proto);
  Function *TheFunction = getFunction(P.getName());
  if (!TheFunction)
    return nullptr;

  // If this is an operator, install it.
  if (P.isBinaryOp())
    BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence();

  // Create a new basic block to start insertion into.
  BasicBlock *BB = BasicBlock::Create(*TheContext, &quot;entry&quot;, TheFunction);
  Builder-&gt;SetInsertPoint(BB);

  // Record the function arguments in the NamedValues map.
  NamedValues.clear();
  for (auto &amp;Arg : TheFunction-&gt;args()) {
    // Create an alloca for this variable.
    AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());

    // Store the initial value into the alloca.
    Builder-&gt;CreateStore(&amp;Arg, Alloca);

    // Add arguments to variable symbol table.
    NamedValues[std::string(Arg.getName())] = Alloca;
  }

  if (Value *RetVal = Body-&gt;codegen()) {
    // Finish off the function.
    Builder-&gt;CreateRet(RetVal);

    // Validate the generated code, checking for consistency.
    verifyFunction(*TheFunction);

    return TheFunction;
  }

  // Error reading body, remove function.
  TheFunction-&gt;eraseFromParent();

  if (P.isBinaryOp())
    BinopPrecedence.erase(P.getOperatorName());
  return nullptr;
}

//===----------------------------------------------------------------------===//
// Top-Level parsing and JIT Driver
//===----------------------------------------------------------------------===//

static void InitializeModuleAndPassManager() {
  // Open a new module.
  TheContext = std::make_unique&lt;LLVMContext&gt;();
  TheModule = std::make_unique&lt;Module&gt;(&quot;my cool jit&quot;, *TheContext);

  // Create a new builder for the module.
  Builder = std::make_unique&lt;IRBuilder&lt;&gt;&gt;(*TheContext);
}

static void HandleDefinition() {
  if (auto FnAST = ParseDefinition()) {
    if (auto *FnIR = FnAST-&gt;codegen()) {
      fprintf(stderr, &quot;Read function definition:&quot;);
      FnIR-&gt;print(errs());
      fprintf(stderr, &quot;\n&quot;);
    }
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}

static void HandleExtern() {
  if (auto ProtoAST = ParseExtern()) {
    if (auto *FnIR = ProtoAST-&gt;codegen()) {
      fprintf(stderr, &quot;Read extern: &quot;);
      FnIR-&gt;print(errs());
      fprintf(stderr, &quot;\n&quot;);
      FunctionProtos[ProtoAST-&gt;getName()] = std::move(ProtoAST);
    }
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}

static void HandleTopLevelExpression() {
  // Evaluate a top-level expression into an anonymous function.
  if (auto FnAST = ParseTopLevelExpr()) {
    FnAST-&gt;codegen();
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}

/// top ::= definition | external | expression | ';'
static void MainLoop() {
  while (true) {
    switch (CurTok) {
    case tok_eof:
      return;
    case ';': // ignore top-level semicolons.
      getNextToken();
      break;
    case tok_def:
      HandleDefinition();
      break;
    case tok_extern:
      HandleExtern();
      break;
    default:
      HandleTopLevelExpression();
      break;
    }
  }
}

//===----------------------------------------------------------------------===//
// &quot;Library&quot; functions that can be &quot;extern'd&quot; from user code.
//===----------------------------------------------------------------------===//

#ifdef _WIN32
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT
#endif

/// putchard - putchar that takes a double and returns 0.
extern &quot;C&quot; DLLEXPORT double putchard(double X) {
  fputc((char)X, stderr);
  return 0;
}

/// printd - printf that takes a double prints it as &quot;%f\n&quot;, returning 0.
extern &quot;C&quot; DLLEXPORT double printd(double X) {
  fprintf(stderr, &quot;%f\n&quot;, X);
  return 0;
}

//===----------------------------------------------------------------------===//
// Main driver code.
//===----------------------------------------------------------------------===//

int main() {
  // Install standard binary operators.
  // 1 is lowest precedence.
  BinopPrecedence['&lt;'] = 10;
  BinopPrecedence['+'] = 20;
  BinopPrecedence['-'] = 20;
  BinopPrecedence['*'] = 40; // highest.

  // Prime the first token.
  fprintf(stderr, &quot;ready&gt; &quot;);
  getNextToken();

  InitializeModuleAndPassManager();

  // Run the main &quot;interpreter loop&quot; now.
  MainLoop();

  // Initialize the target registry etc.
  InitializeAllTargetInfos();
  InitializeAllTargets();
  InitializeAllTargetMCs();
  InitializeAllAsmParsers();
  InitializeAllAsmPrinters();

  auto TargetTriple = sys::getDefaultTargetTriple();
  TheModule-&gt;setTargetTriple(TargetTriple);

  std::string Error;
  auto Target = TargetRegistry::lookupTarget(TargetTriple, Error);

  // Print an error and exit if we couldn't find the requested target.
  // This generally occurs if we've forgotten to initialise the
  // TargetRegistry or we have a bogus target triple.
  if (!Target) {
    errs() &lt;&lt; Error;
    return 1;
  }

  auto CPU = &quot;generic&quot;;
  auto Features = &quot;&quot;;

  TargetOptions opt;
  auto RM = Optional&lt;Reloc::Model&gt;();
  auto TheTargetMachine =
      Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);

  TheModule-&gt;setDataLayout(TheTargetMachine-&gt;createDataLayout());

  auto Filename = &quot;output.o&quot;;
  std::error_code EC;
  raw_fd_ostream dest(Filename, EC, sys::fs::OF_None);

  if (EC) {
    errs() &lt;&lt; &quot;Could not open file: &quot; &lt;&lt; EC.message();
    return 1;
  }

  legacy::PassManager pass;
  auto FileType = CGFT_ObjectFile;

  if (TheTargetMachine-&gt;addPassesToEmitFile(pass, dest, nullptr, FileType)) {
    errs() &lt;&lt; &quot;TheTargetMachine can't emit a file of this type&quot;;
    return 1;
  }

  pass.run(*TheModule);
  dest.flush();

  outs() &lt;&lt; &quot;Wrote &quot; &lt;&lt; Filename &lt;&lt; &quot;\n&quot;;

  return 0;
}
</code></pre>
    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>除特殊注明部分，本站内容采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a> 进行许可。</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/Origami404" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://wiki.hitsz.org" target="_blank"><span>HITsz LUG wiki</span></a>
            </li>
            
            <li>
                <a href="https://space.bilibili.com/1124374292" target="_blank"><span>bilibili</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/arch/">Arch</a>
            </span>
            
            <span>
                <a href="/tags/arm/">ARM</a>
            </span>
            
            <span>
                <a href="/tags/c/">C</a>
            </span>
            
            <span>
                <a href="/tags/docker/">Docker</a>
            </span>
            
            <span>
                <a href="/tags/git/">Git</a>
            </span>
            
            <span>
                <a href="/tags/haskell/">Haskell</a>
            </span>
            
            <span>
                <a href="/tags/https/">HTTPS</a>
            </span>
            
            <span>
                <a href="/tags/linux-%E5%B7%A5%E5%85%B7/">linux 工具</a>
            </span>
            
            <span>
                <a href="/tags/llvm/">LLVM</a>
            </span>
            
            <span>
                <a href="/tags/mgit/">mgit</a>
            </span>
            
            <span>
                <a href="/tags/python/">Python</a>
            </span>
            
            <span>
                <a href="/tags/windows/">Windows</a>
            </span>
            
            <span>
                <a href="/tags/%E5%8F%98%E5%88%86%E6%B3%95/">变分法</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9F%9F%E5%90%8D/">域名</a>
            </span>
            
            <span>
                <a href="/tags/%E5%AF%BC%E8%AE%BA/">导论</a>
            </span>
            
            <span>
                <a href="/tags/%E6%88%91%E4%BC%9A%E7%86%9F%E7%BB%83%E5%9C%B0%E5%AE%89%E8%A3%85xxx%E7%B3%BB%E5%88%97/">我会熟练地安装xxx系列</a>
            </span>
            
            <span>
                <a href="/tags/%E6%8A%98%E8%85%BE/">折腾</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E5%AD%A6/">数学</a>
            </span>
            
            <span>
                <a href="/tags/%E6%96%B0%E8%A7%82%E7%82%B9/">新观点</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/">服务器管理</a>
            </span>
            
            <span>
                <a href="/tags/%E6%AF%95%E6%98%87%E6%9D%AF/">毕昇杯</a>
            </span>
            
            <span>
                <a href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
            </span>
            
            <span>
                <a href="/tags/%E7%90%86%E8%AE%BA%E7%89%A9%E7%90%86/">理论物理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%B3%9F%E7%B3%95%E4%BD%86%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E4%B8%9C%E8%A5%BF/">糟糕但值得纪念的东西</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BA%BF%E4%BB%A3/">线代</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E7%A8%8B/">编程</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF/">编译前端</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E7%95%99%E5%9C%B0/">自留地</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/">自言自语</a>
            </span>
            
            <span>
                <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
            </span>
            
            <span>
                <a href="/tags/%E8%BD%AE%E5%AD%90/">轮子</a>
            </span>
            
            <span>
                <a href="/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/">非技术</a>
            </span>
            
        </div>
    </div>
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#81-前言">8.1 前言</a></li>
    <li><a href="#82-选择目标平台">8.2 选择目标平台</a></li>
    <li><a href="#83-目标机器-targetmachine">8.3 目标机器 (<code>TargetMachine</code>)</a></li>
    <li><a href="#84-配置模块">8.4 配置模块</a></li>
    <li><a href="#85-生成的目标代码的指针并将其转换为合适的类型">8.5 生成的目标代码的指针并将其转换为合适的类型</a></li>
    <li><a href="#86-最后组装">8.6 最后组装</a></li>
    <li><a href="#87-完整代码">8.7 完整代码</a></li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/Origami404" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://wiki.hitsz.org" target="_blank"><span>HITsz LUG wiki</span></a>
            </li>
            
            <li>
                <a href="https://space.bilibili.com/1124374292" target="_blank"><span>bilibili</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/arch/">Arch</a>
            </span>
            
            <span>
                <a href="/tags/arm/">ARM</a>
            </span>
            
            <span>
                <a href="/tags/c/">C</a>
            </span>
            
            <span>
                <a href="/tags/docker/">Docker</a>
            </span>
            
            <span>
                <a href="/tags/git/">Git</a>
            </span>
            
            <span>
                <a href="/tags/haskell/">Haskell</a>
            </span>
            
            <span>
                <a href="/tags/https/">HTTPS</a>
            </span>
            
            <span>
                <a href="/tags/linux-%E5%B7%A5%E5%85%B7/">linux 工具</a>
            </span>
            
            <span>
                <a href="/tags/llvm/">LLVM</a>
            </span>
            
            <span>
                <a href="/tags/mgit/">mgit</a>
            </span>
            
            <span>
                <a href="/tags/python/">Python</a>
            </span>
            
            <span>
                <a href="/tags/windows/">Windows</a>
            </span>
            
            <span>
                <a href="/tags/%E5%8F%98%E5%88%86%E6%B3%95/">变分法</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9F%9F%E5%90%8D/">域名</a>
            </span>
            
            <span>
                <a href="/tags/%E5%AF%BC%E8%AE%BA/">导论</a>
            </span>
            
            <span>
                <a href="/tags/%E6%88%91%E4%BC%9A%E7%86%9F%E7%BB%83%E5%9C%B0%E5%AE%89%E8%A3%85xxx%E7%B3%BB%E5%88%97/">我会熟练地安装xxx系列</a>
            </span>
            
            <span>
                <a href="/tags/%E6%8A%98%E8%85%BE/">折腾</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E5%AD%A6/">数学</a>
            </span>
            
            <span>
                <a href="/tags/%E6%96%B0%E8%A7%82%E7%82%B9/">新观点</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/">服务器管理</a>
            </span>
            
            <span>
                <a href="/tags/%E6%AF%95%E6%98%87%E6%9D%AF/">毕昇杯</a>
            </span>
            
            <span>
                <a href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
            </span>
            
            <span>
                <a href="/tags/%E7%90%86%E8%AE%BA%E7%89%A9%E7%90%86/">理论物理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%B3%9F%E7%B3%95%E4%BD%86%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E4%B8%9C%E8%A5%BF/">糟糕但值得纪念的东西</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BA%BF%E4%BB%A3/">线代</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E7%A8%8B/">编程</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF/">编译前端</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E7%95%99%E5%9C%B0/">自留地</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/">自言自语</a>
            </span>
            
            <span>
                <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
            </span>
            
            <span>
                <a href="/tags/%E8%BD%AE%E5%AD%90/">轮子</a>
            </span>
            
            <span>
                <a href="/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/">非技术</a>
            </span>
            
        </div>
    </div>
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#81-前言">8.1 前言</a></li>
    <li><a href="#82-选择目标平台">8.2 选择目标平台</a></li>
    <li><a href="#83-目标机器-targetmachine">8.3 目标机器 (<code>TargetMachine</code>)</a></li>
    <li><a href="#84-配置模块">8.4 配置模块</a></li>
    <li><a href="#85-生成的目标代码的指针并将其转换为合适的类型">8.5 生成的目标代码的指针并将其转换为合适的类型</a></li>
    <li><a href="#86-最后组装">8.6 最后组装</a></li>
    <li><a href="#87-完整代码">8.7 完整代码</a></li>
  </ul>
</nav>
    </div>
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2019-2022
                <a href="https://blog.origami404.top/">Origami404</a>
                
                | 基于 <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 构建
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js"></script>



<script defer src="/assets/js/fuji.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" />
<script src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"></script>
<script>
  renderMathInElement(document.querySelector('div.content'), {
    delimiters: [
      { left: '$$', right: '$$', display: true },
      { left: '\\[', right: '\\]', display: true },
      { left: '$', right: '$', display: false },
      { left: '\\(', right: '\\)', display: false },
    ],
  });
</script>




</body>

</html>
