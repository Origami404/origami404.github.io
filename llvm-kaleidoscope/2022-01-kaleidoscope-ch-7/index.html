<!DOCTYPE html>
<html lang="zh-hans">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.92.2" />



<link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png" />
<link rel="manifest" href="icons/site.webmanifest" />
<link rel="mask-icon" href="icons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="icons/favicon.ico" />
<meta name="theme-color" content="#ffffff" />


<title>LLVM Kaleidoscope 第 7 章：可变量 - Origami404 的 Blog</title>


<meta name="author" content="Origami404" />


<meta name="description" content="有空的话就随便逛逛吧 www" />


<meta name="keywords" content="编译原理, 编译前端, LLVM, 翻译" />


<meta property="og:title" content="LLVM Kaleidoscope 第 7 章：可变量" />
<meta name="twitter:title" content="LLVM Kaleidoscope 第 7 章：可变量" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-7/" /><meta property="og:description" content="7.1 前言 欢迎来到 我的第一个基于 LLVM 的语言前端 教程第七章。在前六章我们构建了一门小而强的函数式编程语言, 从中我们学到了如何去解析程序文本，构建与表示 AST，生成 LLVM IR 以及优化冗余代码和实现即时编译。 尽管 Kaleidoscope 作为" />
<meta name="twitter:description" content="7.1 前言 欢迎来到 我的第一个基于 LLVM 的语言前端 教程第七章。在前六章我们构建了一门小而强的函数式编程语言, 从中我们学到了如何去解析程序文本，构建与表示 AST，生成 LLVM IR 以及优化冗余代码和实现即时编译。 尽管 Kaleidoscope 作为" /><meta property="og:image" content="https://blog.origami404.top/img/og.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://blog.origami404.top/img/og.png" /><meta property="article:published_time" content="2022-01-21T22:00:00+08:00" /><meta property="article:modified_time" content="2022-01-21T22:00:00+08:00" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>




<link rel="stylesheet" href="https://blog.origami404.top/assets/css/fuji.min.css" />








</head>

<body
  data-theme="auto"
  data-theme-auto='true'
  >
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://blog.origami404.top/">Origami404 的 Blog</a>
            
            <span class="title-sub">有空的话就随便逛逛吧 www</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-7/">LLVM Kaleidoscope 第 7 章：可变量</a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;2022-01-21</span>

<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;11807 字</span>

<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86">编译原理</a>&nbsp;<a href="/tags/%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF">编译前端</a>&nbsp;<a href="/tags/llvm">LLVM</a>&nbsp;<a href="/tags/%E7%BF%BB%E8%AF%91">翻译</a>&nbsp;</span>

    </div>
    
    <div class="post-content markdown-body">
        <h2 id="71-前言">7.1 前言</h2>
<p>欢迎来到 <a href="/llvm-kaleidoscope/2022-01-kaleidoscope-ch-0">我的第一个基于 LLVM 的语言前端</a> 教程第七章。在前六章我们构建了一门小而强的<a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank">函数式编程语言</a>, 从中我们学到了如何去解析程序文本，构建与表示 AST，生成 LLVM IR 以及优化冗余代码和实现即时编译。</p>
<p>尽管 Kaleidoscope 作为一门函数式语言已经足够优秀，但事实上其函数式特性使得为其生成 LLVM IR 显得 &ldquo;过于简单&rdquo; 了。特别是，函数式的风格令我们特别容易直接构建出 SSA 形式的 LLVM IR &ndash; 而 SSA 经常将那些想用 LLVM 实现一门包含变量的命令式语言的初学者挡在门外。</p>
<p>幸运的是，你并不需要直接在前端生成 SSA form: 尽管偶尔结果出人意料，但 LLVM 提供了非常健壮的 SSA 构建支持。</p>
<h2 id="72-那么问题是什么">7.2 那么问题是什么？</h2>
<p>为了理解为什么变量会阻碍我们生成 SSA form，考虑下面一段 C 语言代码：</p>
<pre><code class="language-c">int G, H;
int test(_Bool Condition) {
  int X;
  if (Condition)
    X = G;
  else
    X = H;
  return X;
}
</code></pre>
<p>在这里，我们有一个变量 <code>X</code>, 它的值依赖于程序的执行路径。对于返回指令而言，<code>X</code> 的值有两种可能，所以我们需要插入一个 phi 节点来合并这两个值。大体上，我们希望编译器生成这样的 LLVM IR:</p>
<pre><code class="language-llvm">@G = weak global i32 0   ; type of @G is i32*
@H = weak global i32 0   ; type of @H is i32*

define i32 @test(i1 %Condition) {
entry:
  br i1 %Condition, label %cond_true, label %cond_false

cond_true:
  %X.0 = load i32, i32* @G
  br label %cond_next

cond_false:
  %X.1 = load i32, i32* @H
  br label %cond_next

cond_next:
  %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]
  ret i32 %X.2
}
</code></pre>
<blockquote>
<p>译者注：关于上面的 LLVM 的一些解释</p>
<p>LLVM IR 作为一种中间表示，其本身很少见地是强类型的。LLVM IR 内的所有 &ldquo;变量&rdquo; 依 SSA 定义只能被赋值 (&ldquo;定义&rdquo;) 一次且仅一次。而如果我们想要实现真实的 &ldquo;变量&rdquo;, 我们需要一块内存和一个指向该内存的指针，随后通过指针修改/读取内存的内容到变量中去。对于 C 的全局变量而言，其本身就不可能符合 LLVM IR 关于变量的 SSA 约束，于是 C 的全局变量在翻译成 LLVM IR 的 &ldquo;变量&rdquo; 的时候只能是作为一个指向它的指针。</p>
<p>关于 LLVM IR 指针的快速介绍：</p>
<ul>
<li>一个指针的类型是 <code>&lt;type&gt;*</code></li>
<li>使用 <code>alloca &lt;类型&gt;</code> 来分配空间</li>
<li>使用 <code>load &lt;想读取的值的类型&gt;, &lt;指针类型&gt; &lt;指针变量&gt;</code> 指令来读取</li>
<li>使用 <code>store &lt;想写入的值的类型&gt; &lt;想写入的变量&gt;, &lt;指针类型&gt; &lt;指针变量&gt;</code> 来写入。</li>
</ul>
<p>在随后对 LLVM IR 的优化过程中，LLVM 负责将对 &ldquo;内存&rdquo; 的读取优化为局部变量，同时构造出合适的 SSA Form. 这样做便避免了要求前端生成 SSA Form，极大地减轻了前端的工作量。</p>
</blockquote>
<p>在上面的例子里，对全局变量 <code>G</code> 和 <code>H</code> 的求值需要显式加载 (load), 随后它们分别存活于 (live in) if 语句的 then 与 else 分支之中。为了合并两个分支中 <code>X</code> 的不同值，在 <code>cond_next</code> 块内的 <code>X.2</code> 使用了 phi 节点来依控制流选择值。当控制流经过 <code>cond_false</code> 块时，<code>X.2</code> 获得 <code>X.1</code> 的值; 当控制流经过 <code>cond_true</code> 块时，<code>X.2</code> 获得 <code>X.1</code> 的值。本章的主要目的不在于讲解 SSA Form 的细节，如需更多信息，请参阅此 <a href="http://en.wikipedia.org/wiki/Static_single_assignment_form" target="_blank">参考</a>.</p>
<blockquote>
<p>译者注: SSA 术语解释：定义 (definition)，存活 (live) 与杀死 (kill)</p>
<p>在 SSA 里，我们将对某变量的一次赋值称为该变量的定义。所谓一个变量的某个值在程序的某个位置存活，是指从那个值的某个赋值出发，经过所有可能的控制流到达该点时，其路径上都没有该变量的其他定义。一个变量的某个值被杀死，如果该变量被赋予了另外一个值。</p>
</blockquote>
<hr>
<blockquote>
<p>译者注: SSA 术语解释: phi &ldquo;节点&rdquo; (phi node)</p>
<p>一件值得注意的事情是，为什么 phi 指令要叫 &ldquo;phi 节点&rdquo;?</p>
<p>事实上，LLVM IR 中基本块与其跳转组成了一张图 (称为 CFG，控制流图)，而图中控制流交会的那个节点 (即基本块) 一般都是要插入 phi 的，名词顺用下来就叫 phi 节点了。</p>
</blockquote>
<p>本章的主要问题是，&ldquo;谁在变量的赋值之前放下 phi 节点？&rdquo; LLVM IR 要求中间代码必须满足 SSA，但构造 SSA Form 需要实现比较难的算法与数据结构，让所有前端都去被折磨一遍显然是得不偿失的。</p>
<h2 id="73-llvm-中的内存">7.3 LLVM 中的内存</h2>
<p>LLVM 虽然要求所有的寄存器变量 (就是普通的 LLVM IR 中的变量) 满足 SSA，但并不要求所有的内存对象满足 SSA. 在上面的例子中，我们通过对 <code>G</code> 和 <code>H</code> 的 Load 指令直接访问了它们 &ndash; <code>G</code> 和 <code>H</code> 并不需要被 <strong>重命名/版本化</strong>。与其他编译系统不同，LLVM 不强制要求版本化内存中的对象，而是将对内存的数据流分析综合进 LLVM IR 里 &ndash; 它将在<a href="https://llvm.org/docs/WritingAnLLVMPass.html" target="_blank">分析类优化过程</a>中被按需计算，随后处理。</p>
<blockquote>
<p>译者注：粗体小句英文原文：they are not <strong>renamed or versioned</strong>.</p>
</blockquote>
<hr>
<blockquote>
<p>译者注: SSA 术语解释：重命名 (rename)/版本化 (version)</p>
<p>在普通的命令式程序中，我们经常对一个变量多次赋值。在 SSA 中，我们需要区别这多次赋值。比如说上面例子中的 <code>X</code> 变量，我们就将其重命名为 <code>X.0</code>, <code>X.1</code>, <code>X.2</code> 等来区分其包含不同值的时候。这种重命名有时候又叫版本化 (version，作动词), 指的是类似这种直接在变量名后面加数字的重命名方法。</p>
</blockquote>
<hr>
<blockquote>
<p>译者注: LLVM 中的寄存器变量 (register variable) 与内存对象 (memory object)</p>
<p>所谓寄存器变量，就是指正常的那些 <code>%</code> 开头的，可以被赋值的变量。在 LLVM IR 中我们拥有无限多的寄存器。寄存器变量要求满足 SSA 约束，可以直接塞进各种指令里当参数，或者是存放指令的结果。</p>
<p>所谓内存对象，就是通过指针指向的某个对象。内存对象可以在堆上或者在栈上，需要使用 load/store 指令来访问/写入，不能直接作为指令参数/存放指令结果。</p>
<p>正如上文所提到的，所有的全局变量 (以 <code>@</code> 开头) 都是指针，指向某个内存对象。</p>
</blockquote>
<p>知道了这个，我们就有实现变量的基本思路了：我们把所有变量都放在函数的栈里 (从而使其是一个内存对象), 然后我们就可以 &ldquo;绕过&rdquo; SSA 的约束了。为了实现它，我们需要了解 LLVM 是如何处理栈变量 (stack variable) 的。</p>
<p>在 LLVM，所有的内存访问 (包括读取和写入) 都需要显式使用 <code>load</code> / <code>store</code> 指令。归功于 LLVM 的优秀设计，我们并不需要一个 &ldquo;取地址&rdquo; 运算符。注意全局变量 <code>@G</code> / <code>@H</code> 的实际类型是 <code>i32*</code>, 即便我们在声明它们的时候写的是 <code>i32</code>. <code>@G</code> 声明中的 <code>i32</code> 实际上意味着 <code>@G</code> 为全局数据区保留了一个大小为 <code>i32</code> 的内存空间，而名字 <code>@G</code> 实际上只是对那个空间的地址的一个引用。我们的栈变量以相同方式工作，除了我们这次使用 <a href="https://llvm.org/docs/LangRef.html#alloca-instruction" target="_blank">alloca 指令</a>来声明它们：</p>
<pre><code class="language-llvm">define i32 @example() {
entry:
  %X = alloca i32           ; type of %X is i32*.
  ...
  %tmp = load i32, i32* %X  ; load the stack value %X from the stack.
  %tmp2 = add i32 %tmp, 1   ; increment it
  store i32 %tmp2, i32* %X  ; store it back
  ...
</code></pre>
<p>上面的例子展示了如何在 LLVM IR 中声明与维护栈变量。被 alloca 指令分配的栈内存可以被任意使用：你可以将该地址传递给其他函数，或者用它储存另一个变量。对于我们之前的实例代码，我们可以用 alloca 指令重写它以避免使用 phi 节点：</p>
<pre><code class="language-llvm">@G = weak global i32 0   ; type of @G is i32*
@H = weak global i32 0   ; type of @H is i32*

define i32 @test(i1 %Condition) {
entry:
  %X = alloca i32           ; type of %X is i32*.
  br i1 %Condition, label %cond_true, label %cond_false

cond_true:
  %X.0 = load i32, i32* @G
  store i32 %X.0, i32* %X   ; Update X
  br label %cond_next

cond_false:
  %X.1 = load i32, i32* @H
  store i32 %X.1, i32* %X   ; Update X
  br label %cond_next

cond_next:
  %X.2 = load i32, i32* %X  ; Read X
  ret i32 %X.2
}
</code></pre>
<p>现在，我们可以按下面的方式处理任意变量而无需插入任何 phi 节点了：</p>
<ol>
<li>对每一个变量都分配一份栈空间</li>
<li>对变量的每一次读取都使用一次 load 指令</li>
<li>对变量的每一次赋值都使用一次 store 指令</li>
<li>要取变量的地址，只需要直接使用栈对象的地址就可以了 (也就是直接使用存放栈空间指针的那个寄存器变量)</li>
</ol>
<p>刚解决了不可变性的问题，现在我们又有了新的问题：即使是对于非常简单且常见的操作，我们也引入了过多的对栈空间的访问，这将导致极大的性能问题。幸运的是，LLVM 优化器有一个非常好用的优化过程，&ldquo;mem2reg&rdquo;, 来帮助我们解决这个问题。这个优化过程可以将对内存空间的访问转化为对寄存器变量的使用，并且在合适的地方插入 phi 节点。如果你对上面的例子使用这个优化过程，你将得到：</p>
<pre><code class="language-llvm">$ llvm-as &lt; example.ll | opt -mem2reg | llvm-dis
@G = weak global i32 0
@H = weak global i32 0

define i32 @test(i1 %Condition) {
entry:
  br i1 %Condition, label %cond_true, label %cond_false

cond_true:
  %X.0 = load i32, i32* @G
  br label %cond_next

cond_false:
  %X.1 = load i32, i32* @H
  br label %cond_next

cond_next:
  %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ]
  ret i32 %X.01
}
</code></pre>
<p>mem2reg 过程实现了用于构造 SSA 的标准 &ldquo;迭代式支配边界&rdquo;(iterated dominance frontier) 算法，同时针对一系列常见的 &ldquo;前端偷懒&rdquo; 情况 (比如仅仅是因为懒得放 phi 节点而使用内存) 做了针对性的优化。mem2reg 可谓是在语言中实现变量的标准方式，前端应该总是使用 mem2reg. 值得注意的是，mem2reg 只优化特定情况下的内存使用：</p>
<ol>
<li>它只优化由 alloca 分配的内存，所以它并不会优化到全局变量或者是在堆上的内存对象。</li>
<li>它只优化在函数的 <code>entry</code> 块分配的内存。在起始块的 alloca 指令只会执行一次，这简化了分析。</li>
<li>它只优化那些仅被 load/store 指令使用的内存。如果你将内存的地址传递给别的函数或是将指针偏移，那么 mem2reg 就不会优化这个 alloca.</li>
<li>它只优化包含<a href="https://llvm.org/docs/LangRef.html#first-class-types" target="_blank">第一类值</a>(像是指针，标量或者向量) 或是长度为 1 的数组的内存。mem2reg 并不能将对内存中结构体或者是数组的访问优化为对 (多个) 寄存器的访问，但另一个优化过程 &ldquo;sroa&rdquo; 可以做到这一点 &ndash; 它甚至还能优化对联合体 (union) 的访问等更多情况。</li>
</ol>
<p>对大部分的命令式语言而言，在将简单的变量使用转化为内存访问时，上面的情况都很少发生 &ndash; 我们将通过 Kaleidoscope 证明这一点。最后，你可能会觉得这样做太麻烦了，为什么不干脆直接在前端写写算法，构造好 SSA Form 呢？原因有三：</p>
<ol>
<li>mem2reg 有良好的测试，并且已经在 clang 中证明了自己: clang 同样使用 mem2reg 来实现变量，假如 mem2reg 出现了 bug，那么它很快就会被 clang 的大量用户发现，进而被开发者修复。</li>
<li>mem2reg 跑得飞快：它能快速地处理一般情况，同时也对大量的特殊情况做了特别优化：它能检测到只在一个基本块内被使用的变量或是只被赋值了一次的变量，同时还使用了启发式方法来避免插入无用的 phi 节点; 而这只是 mem2reg 优化的一小部分。</li>
<li>mem2reg 能生成调试信息：在 LLVM 中，我们需要先暴露变量的地址，随后才能为该地址附加<a href="https://llvm.org/docs/SourceLevelDebugging.html" target="_blank">调试信息</a>. 而使用 mem2reg 可以非常自然地与 LLVM 生成调试信息的技术相嵌合。</li>
</ol>
<p>不出意外的话，mem2reg 能极大地简化前端设计与实现。现在，让我们开始为 Kaleidoscope 加入变量吧！</p>
<h2 id="74-kaleidoscope-中的变量">7.4 Kaleidoscope 中的变量</h2>
<p>解决了理论问题之后，我们现在来决定 Kaleidoscope 里的变量写法。我们主要加入两个特性：</p>
<ol>
<li>以 <code>=</code> 运算符修改变量</li>
<li>定义新变量</li>
</ol>
<p>尽管只有第一项特性能体现出变量之&quot;变&quot;, 但鉴于 Kaleidoscope 现在只能通过函数形参引入变量，所以我们还得添上第二项特性。事实上定义新变量是非常有用的，就算是不可变的变量也能极大提升程序的可读性。语法上，我们的程序将类似下面这样：</p>
<pre><code class="language-py"># Define ':' for sequencing: as a low-precedence operator that ignores operands
# and just returns the RHS.
def binary : 1 (x y) y;

# Recursive fib, we could do this before.
def fib(x)
  if (x &lt; 3) then
    1
  else
    fib(x-1)+fib(x-2);

# Iterative fib.
def fibi(x)
  var a = 1, b = 1, c in
  (for i = 3, i &lt; x in
     c = a + b :
     a = b :
     b = c) :
  b;

# Call it.
fibi(10);
</code></pre>
<p>为了修改变量，我们首先需要为变量生成使用 alloca 的中间代码，随后加入新的运算符，最后再来为 Kaleidoscope 加入变量定义语法。</p>
<h2 id="75-修改之前的变量实现">7.5 修改之前的变量实现</h2>
<p>Kaleidoscope 的符号表之前是在中间代码生成阶段使用 &lsquo;NamedValues&rsquo; map 维护的。该 map 以 LLVM 的 <code>Value*</code> 的形式保存每一个名字对应的 double 值。为了使之可变，我们现在改其为存放名字对应的内存地址。实际上这是一种重构，(就本身而言) 其不改变编译器的行为，只是修改了编译器的实现。</p>
<p>目前 Kaleidoscope 只支持两种形式的变量定义：函数形参与 for 循环循环变量。为了看起来整齐，我们会让它们也变得可变。这意味着它们的使用也需要改为对内存的读写。</p>
<p>首先，我们将 <code>NamedValues</code> 中的 <code>Value*</code> 修改为 <code>AllocaInst*</code>. 改完后，C++ 编译器就会开始向我们抱怨哪里需要更新了：</p>
<pre><code class="language-cpp">static std::map&lt;std::string, AllocaInst*&gt; NamedValues;
</code></pre>
<p>同时，我们创建一个函数来帮助我们在函数的起始块 (entry block) 插入 alloca 指令。</p>
<pre><code class="language-cpp">/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of
/// the function.  This is used for mutable variables etc.
static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction,
                                          const std::string &amp;VarName) {
  IRBuilder&lt;&gt; TmpB(&amp;TheFunction-&gt;getEntryBlock(),
                 TheFunction-&gt;getEntryBlock().begin());
  return TmpB.CreateAlloca(Type::getDoubleTy(TheContext), 0,
                           VarName.c_str());
}
</code></pre>
<p>上面的代码首先创建了一个插入位置为起始块第一条指令 (<code>.begin()</code>) 的 IRBuilder，随后以 <code>VarName</code> 为名字插入 alloca 指令并返回其结果。由于 Kaleidoscope 里所有变量的类型都是 double，所以我们并不需要传入变量的类型。</p>
<p>基于上面的函数，我们首先来更改变量求值的代码。现在变量在栈空间中，所以求值变量就需要一次 load:</p>
<pre><code class="language-cpp">Value *VariableExprAST::codegen() {
  // Look this variable up in the function.
  // 根据名字找到函数中的变量 (其为一指针)
  Value *V = NamedValues[Name];
  if (!V)
    return LogErrorV(&quot;Unknown variable name&quot;);

  // Load the value.
  // 使用 load 指令获取其值
  return Builder.CreateLoad(V, Name.c_str());
}
</code></pre>
<p>上面的代码相当直观。随后我们需要修改变量定义的实现，在定义时插入 alloca 指令。首先修改 <code>ForExprAST::codegen()</code> (完整代码参见<a href="">后文</a>):</p>
<pre><code class="language-cpp">Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();

// Create an alloca for the variable in the entry block.
// 为变量在起始块插入一条 alloca 指令
AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);

// Emit the start code first, without 'variable' in scope.
// 首先在循环变量不在作用域内的情况下生成初始值
Value *StartVal = Start-&gt;codegen();
if (!StartVal)
  return nullptr;

// Store the value into the alloca.
// 将该初始值存入分配出的内存空间中
Builder.CreateStore(StartVal, Alloca);
...

// Compute the end condition.
// 求值循环终止条件
Value *EndCond = End-&gt;codegen();
if (!EndCond)
  return nullptr;

// Reload, increment, and restore the alloca.  This handles the case where
// the body of the loop mutates the variable.
// 重新读取循环变量的值，加一，然后写入回去。
// 不使用之前循环变量的值是为了防止循环体内修改了循环变量的情况。
Value *CurVar = Builder.CreateLoad(Alloca);
Value *NextVar = Builder.CreateFAdd(CurVar, StepVal, &quot;nextvar&quot;);
Builder.CreateStore(NextVar, Alloca);
...
</code></pre>
<p>代码做的事跟<a href="ch-5.md#535-%e4%b8%ad%e9%97%b4%e4%bb%a3%e7%a0%81%e7%94%9f%e6%88%90">之前</a>是一样的，除了我们现在使用 load/store 而不是手动构造 phi 节点来更新它的值。</p>
<p>为了让函数形参可变，我们也需要为它们生成 alloca 指令：</p>
<blockquote>
<p>译者注：此处原文多用 argument，但综合上下文意思，其实际应指函数形参 (parameter), 故译文全部使用&quot;形参&quot;.</p>
</blockquote>
<pre><code class="language-cpp">Function *FunctionAST::codegen() {
  ...
  Builder.SetInsertPoint(BB);

  // Record the function arguments in the NamedValues map.
  NamedValues.clear();
  for (auto &amp;Arg : TheFunction-&gt;args()) {
    // Create an alloca for this variable.
    // 为每个变量生成一条 alloca 指令
    AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());

    // Store the initial value into the alloca.
    // 将其初始值存入内存中
    Builder.CreateStore(&amp;Arg, Alloca);

    // Add arguments to variable symbol table.
    // 将参数加入符号表中
    NamedValues[Arg.getName()] = Alloca;
  }

  if (Value *RetVal = Body-&gt;codegen()) {
    ...
</code></pre>
<p>对于每一个形参，我们插入一条 alloca 指令，然后将实参值存入刚刚分配出的内存对象中，然后将形参变量 (的地址) 加入符号表; 这个过程将在函数的起始块被插入之后发生。</p>
<p>最后我们还需要在优化过程中加入 mem2reg 以生成优秀的中间代码：</p>
<pre><code class="language-cpp">// Promote allocas to registers.
TheFPM-&gt;add(createPromoteMemoryToRegisterPass());
// Do simple &quot;peephole&quot; optimizations and bit-twiddling optzns.
TheFPM-&gt;add(createInstructionCombiningPass());
// Reassociate expressions.
TheFPM-&gt;add(createReassociatePass());
...
</code></pre>
<p>让我们来比较一下被 mem2reg 优化前后的代码吧。对于先前的递归斐波那契函数而言，优化前的代码是这样的：</p>
<pre><code class="language-llvm">define double @fib(double %x) {
entry:
  %x1 = alloca double
  store double %x, double* %x1
  %x2 = load double, double* %x1
  %cmptmp = fcmp ult double %x2, 3.000000e+00
  %booltmp = uitofp i1 %cmptmp to double
  %ifcond = fcmp one double %booltmp, 0.000000e+00
  br i1 %ifcond, label %then, label %else

then:       ; preds = %entry
  br label %ifcont

else:       ; preds = %entry
  %x3 = load double, double* %x1
  %subtmp = fsub double %x3, 1.000000e+00
  %calltmp = call double @fib(double %subtmp)
  %x4 = load double, double* %x1
  %subtmp5 = fsub double %x4, 2.000000e+00
  %calltmp6 = call double @fib(double %subtmp5)
  %addtmp = fadd double %calltmp, %calltmp6
  br label %ifcont

ifcont:     ; preds = %else, %then
  %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]
  ret double %iftmp
}
</code></pre>
<p>尽管代码非常简单，只有一个变量 (参数<code>x</code>),  但它还是很好地说明我们实现变量的方法。在起始块，我们为 <code>x</code> 生成了一条 alloca 指令并放入初始值; 函数内每一个对它的引用都被转换成了对栈空间的访问。作为对比，我们没有改写 if/then/else 表达式的代码生成方式 &ndash; 事实上，手动插入 phi 节点来实现它反而更加简单。</p>
<p>mem2reg 执行完毕后，代码变成了这样：</p>
<pre><code class="language-llvm">define double @fib(double %x) {
entry:
  %cmptmp = fcmp ult double %x, 3.000000e+00
  %booltmp = uitofp i1 %cmptmp to double
  %ifcond = fcmp one double %booltmp, 0.000000e+00
  br i1 %ifcond, label %then, label %else

then:
  br label %ifcont

else:
  %subtmp = fsub double %x, 1.000000e+00
  %calltmp = call double @fib(double %subtmp)
  %subtmp5 = fsub double %x, 2.000000e+00
  %calltmp6 = call double @fib(double %subtmp5)
  %addtmp = fadd double %calltmp, %calltmp6
  br label %ifcont

ifcont:     ; preds = %else, %then
  %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ]
  ret double %iftmp
}
</code></pre>
<p>对 mem2reg 来说，这不过是一种平凡情况 &ndash; <code>x</code> 根本没有被重新定义。这个例子只是为了缓解你在生成了 &ldquo;低效&rdquo; 代码之后的紧张感而已，放轻松:)！</p>
<p>执行完剩余的优化后，我们得到：</p>
<pre><code class="language-llvm">define double @fib(double %x) {
entry:
  %cmptmp = fcmp ult double %x, 3.000000e+00
  %booltmp = uitofp i1 %cmptmp to double
  %ifcond = fcmp ueq double %booltmp, 0.000000e+00
  br i1 %ifcond, label %else, label %ifcont

else:
  %subtmp = fsub double %x, 1.000000e+00
  %calltmp = call double @fib(double %subtmp)
  %subtmp5 = fsub double %x, 2.000000e+00
  %calltmp6 = call double @fib(double %subtmp5)
  %addtmp = fadd double %calltmp, %calltmp6
  ret double %addtmp

ifcont:
  ret double 1.000000e+00
}
</code></pre>
<p>simplifycfg 优化过程选择将返回指令复制一份插入到 <code>else</code> 块中，这将消除一些跳转与 phi 指令。</p>
<p>本小节我们修改了符号表实现，令其储存栈变量 (地址) 而非值。现在是时候来实现赋值运算符了。</p>
<h2 id="76-崭新的赋值运算符">7.6 崭新的赋值运算符</h2>
<p>凭我们现在的代码，加入新的赋值运算符非常简单，可以像解析普通二元运算符一样解析它。尽管如此，我们还是选择将其实现为内置运算符以方便后续的代码生成。第一步是为其设置优先级：</p>
<pre><code class="language-cpp">int main() {
  // Install standard binary operators.
  // 1 is lowest precedence.
  BinopPrecedence['='] = 2;
  BinopPrecedence['&lt;'] = 10;
  BinopPrecedence['+'] = 20;
  BinopPrecedence['-'] = 20;
</code></pre>
<p>随后我们便可以直接来为赋值运算符生成中间代码了：</p>
<pre><code class="language-cpp">Value *BinaryExprAST::codegen() {
  // Special case '=' because we don't want to emit the LHS as an expression.
  // 作为特殊情况处理：我们不想求值左边的 &quot;表达式&quot;
  if (Op == '=') {
    // Assignment requires the LHS to be an identifier.
    // 左表达式必须是一个标识符以充当变量名
    VariableExprAST *LHSE = dynamic_cast&lt;VariableExprAST*&gt;(LHS.get());
    if (!LHSE)
      return LogErrorV(&quot;destination of '=' must be a variable&quot;);
</code></pre>
<p>赋值运算符的求值并不像普通的二元运算符，后者先求值左边，再求值右边，然后计算。所以我们将其列为特殊情况优先处理。其另一个不同之处在于左 &ldquo;表达式&rdquo; 并不能是任意的表达式 &ndash; <code>(x+1) = expr</code> 是不合法的，我们只允许形如 <code>x = expr</code> 的表达式。</p>
<pre><code class="language-cpp">  // Codegen the RHS.
  // 求值右表达式
  Value *Val = RHS-&gt;codegen();
  if (!Val)
    return nullptr;

  // Look up the name.
  // 查找名字是否存在
  Value *Variable = NamedValues[LHSE-&gt;getName()];
  if (!Variable)
    return LogErrorV(&quot;Unknown variable name&quot;);

  Builder.CreateStore(Val, Variable);
  return Val;
}
...
</code></pre>
<p>一旦找到名字对应的变量，中间代码的生成就很简单了：先求值右表达式，然后将其存入内存，最后返回其值。最后返回赋予的值是为了支持形如 <code>X = (Y = Z)</code> 的链式赋值。</p>
<p>有了赋值运算符，我们就可以修改循环变量和参数了。比如说，我们可以写出下面的代码：</p>
<pre><code class="language-py"># Function to print a double.
extern printd(x);

# Define ':' for sequencing: as a low-precedence operator that ignores operands
# and just returns the RHS.
def binary : 1 (x y) y;

def test(x)
  printd(x) :
  x = 4 :
  printd(x);

test(123);
</code></pre>
<p>上面的代码先输出 &ldquo;123&rdquo;, 然后输出 &ldquo;4&rdquo; &ndash; 我们现在可以修改变量的值了！本章的主要目标业已完成，接下来我们将支持局部变量的定义，这将令 &ldquo;变量&rdquo; 这个特性变得更加实用。</p>
<h2 id="77-自定义局部变量">7.7 自定义局部变量</h2>
<p>支持 <code>var/in</code> 表达式就像我们之前支持其他表达式一样：先修改 lexer，然后是 parser，接着 AST，最后为其生成代码。我们首先来修改 lexer，代码很平凡，没什么好解释的了：</p>
<pre><code class="language-cpp">enum Token {
  ...
  // var definition
  tok_var = -13
...
}
...
static int gettok() {
...
    if (IdentifierStr == &quot;in&quot;)
      return tok_in;
    if (IdentifierStr == &quot;binary&quot;)
      return tok_binary;
    if (IdentifierStr == &quot;unary&quot;)
      return tok_unary;
    if (IdentifierStr == &quot;var&quot;)
      return tok_var;
    return tok_identifier;
...
</code></pre>
<p>接下来为其定义新的 AST 节点：</p>
<pre><code class="language-cpp">/// VarExprAST - Expression class for var/in
class VarExprAST : public ExprAST {
  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames;
  std::unique_ptr&lt;ExprAST&gt; Body;

public:
  VarExprAST(std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames,
             std::unique_ptr&lt;ExprAST&gt; Body)
    : VarNames(std::move(VarNames)), Body(std::move(Body)) {}

  Value *codegen() override;
};
</code></pre>
<p>我们希望能一口气定义一串变量，并且它们分别有可选的初始值，随后在 var/in 表达式的 body 部分便可使用被定义的变量。在代码中，我们使用一个 vector <code>VarNames</code> 来储存它们。</p>
<p>AST 写好后，我们就可以来改 parser 了。修改主表达式的解析函数如下：</p>
<pre><code class="language-cpp">/// primary
///   ::= identifierexpr
///   ::= numberexpr
///   ::= parenexpr
///   ::= ifexpr
///   ::= forexpr
///   ::= varexpr
static std::unique_ptr&lt;ExprAST&gt; ParsePrimary() {
  switch (CurTok) {
  default:
    return LogError(&quot;unknown token when expecting an expression&quot;);
  case tok_identifier:
    return ParseIdentifierExpr();
  case tok_number:
    return ParseNumberExpr();
  case '(':
    return ParseParenExpr();
  case tok_if:
    return ParseIfExpr();
  case tok_for:
    return ParseForExpr();
  case tok_var:
    return ParseVarExpr();
  }
}
</code></pre>
<p>随后是解析 VarExpr 的函数 <code>ParseVarExpr</code>:</p>
<pre><code class="language-cpp">/// varexpr ::= 'var' identifier ('=' expression)?
//                    (',' identifier ('=' expression)?)* 'in' expression
static std::unique_ptr&lt;ExprAST&gt; ParseVarExpr() {
  getNextToken();  // eat the var.

  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames;

  // At least one variable name is required.
  // 至少需要一个变量名
  if (CurTok != tok_identifier)
    return LogError(&quot;expected identifier after var&quot;);
</code></pre>
<p>首先，我们先解析标识符/表达式对并将其信息存入 <code>VarNames</code> 中。</p>
<pre><code class="language-cpp">while (1) {
  std::string Name = IdentifierStr;
  getNextToken();  // eat identifier.

  // Read the optional initializer.
  // 读取可选的初始值
  std::unique_ptr&lt;ExprAST&gt; Init;
  if (CurTok == '=') {
    getNextToken(); // eat the '='.

    Init = ParseExpression();
    if (!Init) return nullptr;
  }

  VarNames.push_back(std::make_pair(Name, std::move(Init)));

  // End of var list, exit loop.
  // 变量定义列表结束了，退出循环
  if (CurTok != ',') break;
  getNextToken(); // eat the ','.

  if (CurTok != tok_identifier)
    return LogError(&quot;expected identifier list after var&quot;);
}
</code></pre>
<p>解析完变量定义之后，我们来解析函数体并构建 AST 节点：</p>
<pre><code class="language-cpp">  // At this point, we have to have 'in'.
  // 现在这里应该是一个 in
  if (CurTok != tok_in)
    return LogError(&quot;expected 'in' keyword after 'var'&quot;);
  getNextToken();  // eat 'in'.

  auto Body = ParseExpression();
  if (!Body)
    return nullptr;

  return std::make_unique&lt;VarExprAST&gt;(std::move(VarNames),
                                       std::move(Body));
}
</code></pre>
<p>解析并用 AST 表示出代码之后，我们来为其生成 LLVM IR. 首先是：</p>
<pre><code class="language-cpp">Value *VarExprAST::codegen() {
  std::vector&lt;AllocaInst *&gt; OldBindings;

  Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent();

  // Register all variables and emit their initializer.
  // 为所有变量注册并求值其初始值
  for (unsigned i = 0, e = VarNames.size(); i != e; ++i) {
    const std::string &amp;VarName = VarNames[i].first;
    ExprAST *Init = VarNames[i].second.get();
</code></pre>
<p>上面的循环遍历所有定义的变量，将其一个个加入变量表中，同时将先前同名变量的值保存于表 <code>OldBindings</code> 中。</p>
<pre><code class="language-cpp">  // Emit the initializer before adding the variable to scope, this prevents
  // the initializer from referencing the variable itself, and permits stuff
  // like this:
  // 我们在变量加入作用域之前便求值初始值表达式。这样会阻止初始值表达式中对该变量的引用，
  // 但仍允许对已存在的同名外层变量的引用，比如：
  //  var a = 1 in
  //    var a = a in ...   # refers to outer 'a'.
  Value *InitVal;
  if (Init) {
    InitVal = Init-&gt;codegen();
    if (!InitVal)
      return nullptr;
  } else { // If not specified, use 0.0.
    InitVal = ConstantFP::get(TheContext, APFloat(0.0));
  }

  AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);
  Builder.CreateStore(InitVal, Alloca);

  // Remember the old variable binding so that we can restore the binding when
  // we unrecurse.
  OldBindings.push_back(NamedValues[VarName]);

  // Remember this binding.
  NamedValues[VarName] = Alloca;
}
</code></pre>
<p>除了注释里提到的问题之外，我们做的主要就是求值初始值表达式，生成 alloca 指令，然后更新符号表使名字被绑定到对应的栈变量上。完成后，我们就可以求值 body 部分了：</p>
<pre><code class="language-cpp">// Codegen the body, now that all vars are in scope.
// 现在所有的新变量都在作用域内，可以开始为 body 生成中间代码了
Value *BodyVal = Body-&gt;codegen();
if (!BodyVal)
  return nullptr;
</code></pre>
<p>最后，在返回之前，我们将之前被遮盖的同名外层变量的绑定恢复：</p>
<pre><code class="language-cpp">  // Pop all our variables from scope.
  // 将新定义的变量全都从作用域中删去
  for (unsigned i = 0, e = VarNames.size(); i != e; ++i)
    NamedValues[VarNames[i].first] = OldBindings[i];

  // Return the body computation.
  // 返回函数体求出的值
  return BodyVal;
}
</code></pre>
<p>到这里，我们实现了带作用域的局部变量定义，并且变量 (显然地) 都是可变的 :). 终于，我们完成了本章开头设下的目标。我们举例用的迭代式斐波那契计算函数也在新实现下良好地运行; mem2reg 优化过程将我们所有的栈变量都优化为 SSA 寄存器变量; phi 节点被按需插入，而我们的前端实现依旧简洁 &ndash; 没有什么 &ldquo;迭代式支配边界计算&rdquo; 给彻底整乱。</p>
<h2 id="78-完整代码">7.8 完整代码</h2>
<p>这里是本章例子的完整代码，具备完全的变量与 var/in 支持。使用下面的命令构建这个例子：</p>
<pre><code class="language-bash"># Compile
clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy
# Run
./toy
</code></pre>
<p>完整代码如下：</p>
<pre><code class="language-cpp">#include &quot;../include/KaleidoscopeJIT.h&quot;
#include &quot;llvm/ADT/APFloat.h&quot;
#include &quot;llvm/ADT/STLExtras.h&quot;
#include &quot;llvm/IR/BasicBlock.h&quot;
#include &quot;llvm/IR/Constants.h&quot;
#include &quot;llvm/IR/DerivedTypes.h&quot;
#include &quot;llvm/IR/Function.h&quot;
#include &quot;llvm/IR/IRBuilder.h&quot;
#include &quot;llvm/IR/Instructions.h&quot;
#include &quot;llvm/IR/LLVMContext.h&quot;
#include &quot;llvm/IR/LegacyPassManager.h&quot;
#include &quot;llvm/IR/Module.h&quot;
#include &quot;llvm/IR/Type.h&quot;
#include &quot;llvm/IR/Verifier.h&quot;
#include &quot;llvm/Support/TargetSelect.h&quot;
#include &quot;llvm/Target/TargetMachine.h&quot;
#include &quot;llvm/Transforms/InstCombine/InstCombine.h&quot;
#include &quot;llvm/Transforms/Scalar.h&quot;
#include &quot;llvm/Transforms/Scalar/GVN.h&quot;
#include &quot;llvm/Transforms/Utils.h&quot;
#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

using namespace llvm;
using namespace llvm::orc;

//===----------------------------------------------------------------------===//
// Lexer
//===----------------------------------------------------------------------===//

// The lexer returns tokens [0-255] if it is an unknown character, otherwise one
// of these for known things.
enum Token {
  tok_eof = -1,

  // commands
  tok_def = -2,
  tok_extern = -3,

  // primary
  tok_identifier = -4,
  tok_number = -5,

  // control
  tok_if = -6,
  tok_then = -7,
  tok_else = -8,
  tok_for = -9,
  tok_in = -10,

  // operators
  tok_binary = -11,
  tok_unary = -12,

  // var definition
  tok_var = -13
};

static std::string IdentifierStr; // Filled in if tok_identifier
static double NumVal;             // Filled in if tok_number

/// gettok - Return the next token from standard input.
static int gettok() {
  static int LastChar = ' ';

  // Skip any whitespace.
  while (isspace(LastChar))
    LastChar = getchar();

  if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]*
    IdentifierStr = LastChar;
    while (isalnum((LastChar = getchar())))
      IdentifierStr += LastChar;

    if (IdentifierStr == &quot;def&quot;)
      return tok_def;
    if (IdentifierStr == &quot;extern&quot;)
      return tok_extern;
    if (IdentifierStr == &quot;if&quot;)
      return tok_if;
    if (IdentifierStr == &quot;then&quot;)
      return tok_then;
    if (IdentifierStr == &quot;else&quot;)
      return tok_else;
    if (IdentifierStr == &quot;for&quot;)
      return tok_for;
    if (IdentifierStr == &quot;in&quot;)
      return tok_in;
    if (IdentifierStr == &quot;binary&quot;)
      return tok_binary;
    if (IdentifierStr == &quot;unary&quot;)
      return tok_unary;
    if (IdentifierStr == &quot;var&quot;)
      return tok_var;
    return tok_identifier;
  }

  if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+
    std::string NumStr;
    do {
      NumStr += LastChar;
      LastChar = getchar();
    } while (isdigit(LastChar) || LastChar == '.');

    NumVal = strtod(NumStr.c_str(), nullptr);
    return tok_number;
  }

  if (LastChar == '#') {
    // Comment until end of line.
    do
      LastChar = getchar();
    while (LastChar != EOF &amp;&amp; LastChar != '\n' &amp;&amp; LastChar != '\r');

    if (LastChar != EOF)
      return gettok();
  }

  // Check for end of file.  Don't eat the EOF.
  if (LastChar == EOF)
    return tok_eof;

  // Otherwise, just return the character as its ascii value.
  int ThisChar = LastChar;
  LastChar = getchar();
  return ThisChar;
}

//===----------------------------------------------------------------------===//
// Abstract Syntax Tree (aka Parse Tree)
//===----------------------------------------------------------------------===//

namespace {

/// ExprAST - Base class for all expression nodes.
class ExprAST {
public:
  virtual ~ExprAST() = default;

  virtual Value *codegen() = 0;
};

/// NumberExprAST - Expression class for numeric literals like &quot;1.0&quot;.
class NumberExprAST : public ExprAST {
  double Val;

public:
  NumberExprAST(double Val) : Val(Val) {}

  Value *codegen() override;
};

/// VariableExprAST - Expression class for referencing a variable, like &quot;a&quot;.
class VariableExprAST : public ExprAST {
  std::string Name;

public:
  VariableExprAST(const std::string &amp;Name) : Name(Name) {}

  Value *codegen() override;
  const std::string &amp;getName() const { return Name; }
};

/// UnaryExprAST - Expression class for a unary operator.
class UnaryExprAST : public ExprAST {
  char Opcode;
  std::unique_ptr&lt;ExprAST&gt; Operand;

public:
  UnaryExprAST(char Opcode, std::unique_ptr&lt;ExprAST&gt; Operand)
      : Opcode(Opcode), Operand(std::move(Operand)) {}

  Value *codegen() override;
};

/// BinaryExprAST - Expression class for a binary operator.
class BinaryExprAST : public ExprAST {
  char Op;
  std::unique_ptr&lt;ExprAST&gt; LHS, RHS;

public:
  BinaryExprAST(char Op, std::unique_ptr&lt;ExprAST&gt; LHS,
                std::unique_ptr&lt;ExprAST&gt; RHS)
      : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {}

  Value *codegen() override;
};

/// CallExprAST - Expression class for function calls.
class CallExprAST : public ExprAST {
  std::string Callee;
  std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;

public:
  CallExprAST(const std::string &amp;Callee,
              std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args)
      : Callee(Callee), Args(std::move(Args)) {}

  Value *codegen() override;
};

/// IfExprAST - Expression class for if/then/else.
class IfExprAST : public ExprAST {
  std::unique_ptr&lt;ExprAST&gt; Cond, Then, Else;

public:
  IfExprAST(std::unique_ptr&lt;ExprAST&gt; Cond, std::unique_ptr&lt;ExprAST&gt; Then,
            std::unique_ptr&lt;ExprAST&gt; Else)
      : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {}

  Value *codegen() override;
};

/// ForExprAST - Expression class for for/in.
class ForExprAST : public ExprAST {
  std::string VarName;
  std::unique_ptr&lt;ExprAST&gt; Start, End, Step, Body;

public:
  ForExprAST(const std::string &amp;VarName, std::unique_ptr&lt;ExprAST&gt; Start,
             std::unique_ptr&lt;ExprAST&gt; End, std::unique_ptr&lt;ExprAST&gt; Step,
             std::unique_ptr&lt;ExprAST&gt; Body)
      : VarName(VarName), Start(std::move(Start)), End(std::move(End)),
        Step(std::move(Step)), Body(std::move(Body)) {}

  Value *codegen() override;
};

/// VarExprAST - Expression class for var/in
class VarExprAST : public ExprAST {
  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames;
  std::unique_ptr&lt;ExprAST&gt; Body;

public:
  VarExprAST(
      std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames,
      std::unique_ptr&lt;ExprAST&gt; Body)
      : VarNames(std::move(VarNames)), Body(std::move(Body)) {}

  Value *codegen() override;
};

/// PrototypeAST - This class represents the &quot;prototype&quot; for a function,
/// which captures its name, and its argument names (thus implicitly the number
/// of arguments the function takes), as well as if it is an operator.
class PrototypeAST {
  std::string Name;
  std::vector&lt;std::string&gt; Args;
  bool IsOperator;
  unsigned Precedence; // Precedence if a binary op.

public:
  PrototypeAST(const std::string &amp;Name, std::vector&lt;std::string&gt; Args,
               bool IsOperator = false, unsigned Prec = 0)
      : Name(Name), Args(std::move(Args)), IsOperator(IsOperator),
        Precedence(Prec) {}

  Function *codegen();
  const std::string &amp;getName() const { return Name; }

  bool isUnaryOp() const { return IsOperator &amp;&amp; Args.size() == 1; }
  bool isBinaryOp() const { return IsOperator &amp;&amp; Args.size() == 2; }

  char getOperatorName() const {
    assert(isUnaryOp() || isBinaryOp());
    return Name[Name.size() - 1];
  }

  unsigned getBinaryPrecedence() const { return Precedence; }
};

/// FunctionAST - This class represents a function definition itself.
class FunctionAST {
  std::unique_ptr&lt;PrototypeAST&gt; Proto;
  std::unique_ptr&lt;ExprAST&gt; Body;

public:
  FunctionAST(std::unique_ptr&lt;PrototypeAST&gt; Proto,
              std::unique_ptr&lt;ExprAST&gt; Body)
      : Proto(std::move(Proto)), Body(std::move(Body)) {}

  Function *codegen();
};

} // end anonymous namespace

//===----------------------------------------------------------------------===//
// Parser
//===----------------------------------------------------------------------===//

/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current
/// token the parser is looking at.  getNextToken reads another token from the
/// lexer and updates CurTok with its results.
static int CurTok;
static int getNextToken() { return CurTok = gettok(); }

/// BinopPrecedence - This holds the precedence for each binary operator that is
/// defined.
static std::map&lt;char, int&gt; BinopPrecedence;

/// GetTokPrecedence - Get the precedence of the pending binary operator token.
static int GetTokPrecedence() {
  if (!isascii(CurTok))
    return -1;

  // Make sure it's a declared binop.
  int TokPrec = BinopPrecedence[CurTok];
  if (TokPrec &lt;= 0)
    return -1;
  return TokPrec;
}

/// LogError* - These are little helper functions for error handling.
std::unique_ptr&lt;ExprAST&gt; LogError(const char *Str) {
  fprintf(stderr, &quot;Error: %s\n&quot;, Str);
  return nullptr;
}

std::unique_ptr&lt;PrototypeAST&gt; LogErrorP(const char *Str) {
  LogError(Str);
  return nullptr;
}

static std::unique_ptr&lt;ExprAST&gt; ParseExpression();

/// numberexpr ::= number
static std::unique_ptr&lt;ExprAST&gt; ParseNumberExpr() {
  auto Result = std::make_unique&lt;NumberExprAST&gt;(NumVal);
  getNextToken(); // consume the number
  return std::move(Result);
}

/// parenexpr ::= '(' expression ')'
static std::unique_ptr&lt;ExprAST&gt; ParseParenExpr() {
  getNextToken(); // eat (.
  auto V = ParseExpression();
  if (!V)
    return nullptr;

  if (CurTok != ')')
    return LogError(&quot;expected ')'&quot;);
  getNextToken(); // eat ).
  return V;
}

/// identifierexpr
///   ::= identifier
///   ::= identifier '(' expression* ')'
static std::unique_ptr&lt;ExprAST&gt; ParseIdentifierExpr() {
  std::string IdName = IdentifierStr;

  getNextToken(); // eat identifier.

  if (CurTok != '(') // Simple variable ref.
    return std::make_unique&lt;VariableExprAST&gt;(IdName);

  // Call.
  getNextToken(); // eat (
  std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args;
  if (CurTok != ')') {
    while (true) {
      if (auto Arg = ParseExpression())
        Args.push_back(std::move(Arg));
      else
        return nullptr;

      if (CurTok == ')')
        break;

      if (CurTok != ',')
        return LogError(&quot;Expected ')' or ',' in argument list&quot;);
      getNextToken();
    }
  }

  // Eat the ')'.
  getNextToken();

  return std::make_unique&lt;CallExprAST&gt;(IdName, std::move(Args));
}

/// ifexpr ::= 'if' expression 'then' expression 'else' expression
static std::unique_ptr&lt;ExprAST&gt; ParseIfExpr() {
  getNextToken(); // eat the if.

  // condition.
  auto Cond = ParseExpression();
  if (!Cond)
    return nullptr;

  if (CurTok != tok_then)
    return LogError(&quot;expected then&quot;);
  getNextToken(); // eat the then

  auto Then = ParseExpression();
  if (!Then)
    return nullptr;

  if (CurTok != tok_else)
    return LogError(&quot;expected else&quot;);

  getNextToken();

  auto Else = ParseExpression();
  if (!Else)
    return nullptr;

  return std::make_unique&lt;IfExprAST&gt;(std::move(Cond), std::move(Then),
                                      std::move(Else));
}

/// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression
static std::unique_ptr&lt;ExprAST&gt; ParseForExpr() {
  getNextToken(); // eat the for.

  if (CurTok != tok_identifier)
    return LogError(&quot;expected identifier after for&quot;);

  std::string IdName = IdentifierStr;
  getNextToken(); // eat identifier.

  if (CurTok != '=')
    return LogError(&quot;expected '=' after for&quot;);
  getNextToken(); // eat '='.

  auto Start = ParseExpression();
  if (!Start)
    return nullptr;
  if (CurTok != ',')
    return LogError(&quot;expected ',' after for start value&quot;);
  getNextToken();

  auto End = ParseExpression();
  if (!End)
    return nullptr;

  // The step value is optional.
  std::unique_ptr&lt;ExprAST&gt; Step;
  if (CurTok == ',') {
    getNextToken();
    Step = ParseExpression();
    if (!Step)
      return nullptr;
  }

  if (CurTok != tok_in)
    return LogError(&quot;expected 'in' after for&quot;);
  getNextToken(); // eat 'in'.

  auto Body = ParseExpression();
  if (!Body)
    return nullptr;

  return std::make_unique&lt;ForExprAST&gt;(IdName, std::move(Start), std::move(End),
                                       std::move(Step), std::move(Body));
}

/// varexpr ::= 'var' identifier ('=' expression)?
//                    (',' identifier ('=' expression)?)* 'in' expression
static std::unique_ptr&lt;ExprAST&gt; ParseVarExpr() {
  getNextToken(); // eat the var.

  std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames;

  // At least one variable name is required.
  if (CurTok != tok_identifier)
    return LogError(&quot;expected identifier after var&quot;);

  while (true) {
    std::string Name = IdentifierStr;
    getNextToken(); // eat identifier.

    // Read the optional initializer.
    std::unique_ptr&lt;ExprAST&gt; Init = nullptr;
    if (CurTok == '=') {
      getNextToken(); // eat the '='.

      Init = ParseExpression();
      if (!Init)
        return nullptr;
    }

    VarNames.push_back(std::make_pair(Name, std::move(Init)));

    // End of var list, exit loop.
    if (CurTok != ',')
      break;
    getNextToken(); // eat the ','.

    if (CurTok != tok_identifier)
      return LogError(&quot;expected identifier list after var&quot;);
  }

  // At this point, we have to have 'in'.
  if (CurTok != tok_in)
    return LogError(&quot;expected 'in' keyword after 'var'&quot;);
  getNextToken(); // eat 'in'.

  auto Body = ParseExpression();
  if (!Body)
    return nullptr;

  return std::make_unique&lt;VarExprAST&gt;(std::move(VarNames), std::move(Body));
}

/// primary
///   ::= identifierexpr
///   ::= numberexpr
///   ::= parenexpr
///   ::= ifexpr
///   ::= forexpr
///   ::= varexpr
static std::unique_ptr&lt;ExprAST&gt; ParsePrimary() {
  switch (CurTok) {
  default:
    return LogError(&quot;unknown token when expecting an expression&quot;);
  case tok_identifier:
    return ParseIdentifierExpr();
  case tok_number:
    return ParseNumberExpr();
  case '(':
    return ParseParenExpr();
  case tok_if:
    return ParseIfExpr();
  case tok_for:
    return ParseForExpr();
  case tok_var:
    return ParseVarExpr();
  }
}

/// unary
///   ::= primary
///   ::= '!' unary
static std::unique_ptr&lt;ExprAST&gt; ParseUnary() {
  // If the current token is not an operator, it must be a primary expr.
  if (!isascii(CurTok) || CurTok == '(' || CurTok == ',')
    return ParsePrimary();

  // If this is a unary operator, read it.
  int Opc = CurTok;
  getNextToken();
  if (auto Operand = ParseUnary())
    return std::make_unique&lt;UnaryExprAST&gt;(Opc, std::move(Operand));
  return nullptr;
}

/// binoprhs
///   ::= ('+' unary)*
static std::unique_ptr&lt;ExprAST&gt; ParseBinOpRHS(int ExprPrec,
                                              std::unique_ptr&lt;ExprAST&gt; LHS) {
  // If this is a binop, find its precedence.
  while (true) {
    int TokPrec = GetTokPrecedence();

    // If this is a binop that binds at least as tightly as the current binop,
    // consume it, otherwise we are done.
    if (TokPrec &lt; ExprPrec)
      return LHS;

    // Okay, we know this is a binop.
    int BinOp = CurTok;
    getNextToken(); // eat binop

    // Parse the unary expression after the binary operator.
    auto RHS = ParseUnary();
    if (!RHS)
      return nullptr;

    // If BinOp binds less tightly with RHS than the operator after RHS, let
    // the pending operator take RHS as its LHS.
    int NextPrec = GetTokPrecedence();
    if (TokPrec &lt; NextPrec) {
      RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS));
      if (!RHS)
        return nullptr;
    }

    // Merge LHS/RHS.
    LHS =
        std::make_unique&lt;BinaryExprAST&gt;(BinOp, std::move(LHS), std::move(RHS));
  }
}

/// expression
///   ::= unary binoprhs
///
static std::unique_ptr&lt;ExprAST&gt; ParseExpression() {
  auto LHS = ParseUnary();
  if (!LHS)
    return nullptr;

  return ParseBinOpRHS(0, std::move(LHS));
}

/// prototype
///   ::= id '(' id* ')'
///   ::= binary LETTER number? (id, id)
///   ::= unary LETTER (id)
static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() {
  std::string FnName;

  unsigned Kind = 0; // 0 = identifier, 1 = unary, 2 = binary.
  unsigned BinaryPrecedence = 30;

  switch (CurTok) {
  default:
    return LogErrorP(&quot;Expected function name in prototype&quot;);
  case tok_identifier:
    FnName = IdentifierStr;
    Kind = 0;
    getNextToken();
    break;
  case tok_unary:
    getNextToken();
    if (!isascii(CurTok))
      return LogErrorP(&quot;Expected unary operator&quot;);
    FnName = &quot;unary&quot;;
    FnName += (char)CurTok;
    Kind = 1;
    getNextToken();
    break;
  case tok_binary:
    getNextToken();
    if (!isascii(CurTok))
      return LogErrorP(&quot;Expected binary operator&quot;);
    FnName = &quot;binary&quot;;
    FnName += (char)CurTok;
    Kind = 2;
    getNextToken();

    // Read the precedence if present.
    if (CurTok == tok_number) {
      if (NumVal &lt; 1 || NumVal &gt; 100)
        return LogErrorP(&quot;Invalid precedence: must be 1..100&quot;);
      BinaryPrecedence = (unsigned)NumVal;
      getNextToken();
    }
    break;
  }

  if (CurTok != '(')
    return LogErrorP(&quot;Expected '(' in prototype&quot;);

  std::vector&lt;std::string&gt; ArgNames;
  while (getNextToken() == tok_identifier)
    ArgNames.push_back(IdentifierStr);
  if (CurTok != ')')
    return LogErrorP(&quot;Expected ')' in prototype&quot;);

  // success.
  getNextToken(); // eat ')'.

  // Verify right number of names for operator.
  if (Kind &amp;&amp; ArgNames.size() != Kind)
    return LogErrorP(&quot;Invalid number of operands for operator&quot;);

  return std::make_unique&lt;PrototypeAST&gt;(FnName, ArgNames, Kind != 0,
                                         BinaryPrecedence);
}

/// definition ::= 'def' prototype expression
static std::unique_ptr&lt;FunctionAST&gt; ParseDefinition() {
  getNextToken(); // eat def.
  auto Proto = ParsePrototype();
  if (!Proto)
    return nullptr;

  if (auto E = ParseExpression())
    return std::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E));
  return nullptr;
}

/// toplevelexpr ::= expression
static std::unique_ptr&lt;FunctionAST&gt; ParseTopLevelExpr() {
  if (auto E = ParseExpression()) {
    // Make an anonymous proto.
    auto Proto = std::make_unique&lt;PrototypeAST&gt;(&quot;__anon_expr&quot;,
                                                 std::vector&lt;std::string&gt;());
    return std::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E));
  }
  return nullptr;
}

/// external ::= 'extern' prototype
static std::unique_ptr&lt;PrototypeAST&gt; ParseExtern() {
  getNextToken(); // eat extern.
  return ParsePrototype();
}

//===----------------------------------------------------------------------===//
// Code Generation
//===----------------------------------------------------------------------===//

static std::unique_ptr&lt;LLVMContext&gt; TheContext;
static std::unique_ptr&lt;Module&gt; TheModule;
static std::unique_ptr&lt;IRBuilder&lt;&gt;&gt; Builder;
static std::map&lt;std::string, AllocaInst *&gt; NamedValues;
static std::unique_ptr&lt;legacy::FunctionPassManager&gt; TheFPM;
static std::unique_ptr&lt;KaleidoscopeJIT&gt; TheJIT;
static std::map&lt;std::string, std::unique_ptr&lt;PrototypeAST&gt;&gt; FunctionProtos;
static ExitOnError ExitOnErr;

Value *LogErrorV(const char *Str) {
  LogError(Str);
  return nullptr;
}

Function *getFunction(std::string Name) {
  // First, see if the function has already been added to the current module.
  if (auto *F = TheModule-&gt;getFunction(Name))
    return F;

  // If not, check whether we can codegen the declaration from some existing
  // prototype.
  auto FI = FunctionProtos.find(Name);
  if (FI != FunctionProtos.end())
    return FI-&gt;second-&gt;codegen();

  // If no existing prototype exists, return null.
  return nullptr;
}

/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of
/// the function.  This is used for mutable variables etc.
static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction,
                                          StringRef VarName) {
  IRBuilder&lt;&gt; TmpB(&amp;TheFunction-&gt;getEntryBlock(),
                   TheFunction-&gt;getEntryBlock().begin());
  return TmpB.CreateAlloca(Type::getDoubleTy(*TheContext), nullptr, VarName);
}

Value *NumberExprAST::codegen() {
  return ConstantFP::get(*TheContext, APFloat(Val));
}

Value *VariableExprAST::codegen() {
  // Look this variable up in the function.
  AllocaInst *A = NamedValues[Name];
  if (!A)
    return LogErrorV(&quot;Unknown variable name&quot;);

  // Load the value.
  return Builder-&gt;CreateLoad(A-&gt;getAllocatedType(), A, Name.c_str());
}

Value *UnaryExprAST::codegen() {
  Value *OperandV = Operand-&gt;codegen();
  if (!OperandV)
    return nullptr;

  Function *F = getFunction(std::string(&quot;unary&quot;) + Opcode);
  if (!F)
    return LogErrorV(&quot;Unknown unary operator&quot;);

  return Builder-&gt;CreateCall(F, OperandV, &quot;unop&quot;);
}

Value *BinaryExprAST::codegen() {
  // Special case '=' because we don't want to emit the LHS as an expression.
  if (Op == '=') {
    // Assignment requires the LHS to be an identifier.
    // This assume we're building without RTTI because LLVM builds that way by
    // default.  If you build LLVM with RTTI this can be changed to a
    // dynamic_cast for automatic error checking.
    VariableExprAST *LHSE = static_cast&lt;VariableExprAST *&gt;(LHS.get());
    if (!LHSE)
      return LogErrorV(&quot;destination of '=' must be a variable&quot;);
    // Codegen the RHS.
    Value *Val = RHS-&gt;codegen();
    if (!Val)
      return nullptr;

    // Look up the name.
    Value *Variable = NamedValues[LHSE-&gt;getName()];
    if (!Variable)
      return LogErrorV(&quot;Unknown variable name&quot;);

    Builder-&gt;CreateStore(Val, Variable);
    return Val;
  }

  Value *L = LHS-&gt;codegen();
  Value *R = RHS-&gt;codegen();
  if (!L || !R)
    return nullptr;

  switch (Op) {
  case '+':
    return Builder-&gt;CreateFAdd(L, R, &quot;addtmp&quot;);
  case '-':
    return Builder-&gt;CreateFSub(L, R, &quot;subtmp&quot;);
  case '*':
    return Builder-&gt;CreateFMul(L, R, &quot;multmp&quot;);
  case '&lt;':
    L = Builder-&gt;CreateFCmpULT(L, R, &quot;cmptmp&quot;);
    // Convert bool 0/1 to double 0.0 or 1.0
    return Builder-&gt;CreateUIToFP(L, Type::getDoubleTy(*TheContext), &quot;booltmp&quot;);
  default:
    break;
  }

  // If it wasn't a builtin binary operator, it must be a user defined one. Emit
  // a call to it.
  Function *F = getFunction(std::string(&quot;binary&quot;) + Op);
  assert(F &amp;&amp; &quot;binary operator not found!&quot;);

  Value *Ops[] = {L, R};
  return Builder-&gt;CreateCall(F, Ops, &quot;binop&quot;);
}

Value *CallExprAST::codegen() {
  // Look up the name in the global module table.
  Function *CalleeF = getFunction(Callee);
  if (!CalleeF)
    return LogErrorV(&quot;Unknown function referenced&quot;);

  // If argument mismatch error.
  if (CalleeF-&gt;arg_size() != Args.size())
    return LogErrorV(&quot;Incorrect # arguments passed&quot;);

  std::vector&lt;Value *&gt; ArgsV;
  for (unsigned i = 0, e = Args.size(); i != e; ++i) {
    ArgsV.push_back(Args[i]-&gt;codegen());
    if (!ArgsV.back())
      return nullptr;
  }

  return Builder-&gt;CreateCall(CalleeF, ArgsV, &quot;calltmp&quot;);
}

Value *IfExprAST::codegen() {
  Value *CondV = Cond-&gt;codegen();
  if (!CondV)
    return nullptr;

  // Convert condition to a bool by comparing non-equal to 0.0.
  CondV = Builder-&gt;CreateFCmpONE(
      CondV, ConstantFP::get(*TheContext, APFloat(0.0)), &quot;ifcond&quot;);

  Function *TheFunction = Builder-&gt;GetInsertBlock()-&gt;getParent();

  // Create blocks for the then and else cases.  Insert the 'then' block at the
  // end of the function.
  BasicBlock *ThenBB = BasicBlock::Create(*TheContext, &quot;then&quot;, TheFunction);
  BasicBlock *ElseBB = BasicBlock::Create(*TheContext, &quot;else&quot;);
  BasicBlock *MergeBB = BasicBlock::Create(*TheContext, &quot;ifcont&quot;);

  Builder-&gt;CreateCondBr(CondV, ThenBB, ElseBB);

  // Emit then value.
  Builder-&gt;SetInsertPoint(ThenBB);

  Value *ThenV = Then-&gt;codegen();
  if (!ThenV)
    return nullptr;

  Builder-&gt;CreateBr(MergeBB);
  // Codegen of 'Then' can change the current block, update ThenBB for the PHI.
  ThenBB = Builder-&gt;GetInsertBlock();

  // Emit else block.
  TheFunction-&gt;getBasicBlockList().push_back(ElseBB);
  Builder-&gt;SetInsertPoint(ElseBB);

  Value *ElseV = Else-&gt;codegen();
  if (!ElseV)
    return nullptr;

  Builder-&gt;CreateBr(MergeBB);
  // Codegen of 'Else' can change the current block, update ElseBB for the PHI.
  ElseBB = Builder-&gt;GetInsertBlock();

  // Emit merge block.
  TheFunction-&gt;getBasicBlockList().push_back(MergeBB);
  Builder-&gt;SetInsertPoint(MergeBB);
  PHINode *PN = Builder-&gt;CreatePHI(Type::getDoubleTy(*TheContext), 2, &quot;iftmp&quot;);

  PN-&gt;addIncoming(ThenV, ThenBB);
  PN-&gt;addIncoming(ElseV, ElseBB);
  return PN;
}

// Output for-loop as:
//   var = alloca double
//   ...
//   start = startexpr
//   store start -&gt; var
//   goto loop
// loop:
//   ...
//   bodyexpr
//   ...
// loopend:
//   step = stepexpr
//   endcond = endexpr
//
//   curvar = load var
//   nextvar = curvar + step
//   store nextvar -&gt; var
//   br endcond, loop, endloop
// outloop:
Value *ForExprAST::codegen() {
  Function *TheFunction = Builder-&gt;GetInsertBlock()-&gt;getParent();

  // Create an alloca for the variable in the entry block.
  AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);

  // Emit the start code first, without 'variable' in scope.
  Value *StartVal = Start-&gt;codegen();
  if (!StartVal)
    return nullptr;

  // Store the value into the alloca.
  Builder-&gt;CreateStore(StartVal, Alloca);

  // Make the new basic block for the loop header, inserting after current
  // block.
  BasicBlock *LoopBB = BasicBlock::Create(*TheContext, &quot;loop&quot;, TheFunction);

  // Insert an explicit fall through from the current block to the LoopBB.
  Builder-&gt;CreateBr(LoopBB);

  // Start insertion in LoopBB.
  Builder-&gt;SetInsertPoint(LoopBB);

  // Within the loop, the variable is defined equal to the PHI node.  If it
  // shadows an existing variable, we have to restore it, so save it now.
  AllocaInst *OldVal = NamedValues[VarName];
  NamedValues[VarName] = Alloca;

  // Emit the body of the loop.  This, like any other expr, can change the
  // current BB.  Note that we ignore the value computed by the body, but don't
  // allow an error.
  if (!Body-&gt;codegen())
    return nullptr;

  // Emit the step value.
  Value *StepVal = nullptr;
  if (Step) {
    StepVal = Step-&gt;codegen();
    if (!StepVal)
      return nullptr;
  } else {
    // If not specified, use 1.0.
    StepVal = ConstantFP::get(*TheContext, APFloat(1.0));
  }

  // Compute the end condition.
  Value *EndCond = End-&gt;codegen();
  if (!EndCond)
    return nullptr;

  // Reload, increment, and restore the alloca.  This handles the case where
  // the body of the loop mutates the variable.
  Value *CurVar =
      Builder-&gt;CreateLoad(Alloca-&gt;getAllocatedType(), Alloca, VarName.c_str());
  Value *NextVar = Builder-&gt;CreateFAdd(CurVar, StepVal, &quot;nextvar&quot;);
  Builder-&gt;CreateStore(NextVar, Alloca);

  // Convert condition to a bool by comparing non-equal to 0.0.
  EndCond = Builder-&gt;CreateFCmpONE(
      EndCond, ConstantFP::get(*TheContext, APFloat(0.0)), &quot;loopcond&quot;);

  // Create the &quot;after loop&quot; block and insert it.
  BasicBlock *AfterBB =
      BasicBlock::Create(*TheContext, &quot;afterloop&quot;, TheFunction);

  // Insert the conditional branch into the end of LoopEndBB.
  Builder-&gt;CreateCondBr(EndCond, LoopBB, AfterBB);

  // Any new code will be inserted in AfterBB.
  Builder-&gt;SetInsertPoint(AfterBB);

  // Restore the unshadowed variable.
  if (OldVal)
    NamedValues[VarName] = OldVal;
  else
    NamedValues.erase(VarName);

  // for expr always returns 0.0.
  return Constant::getNullValue(Type::getDoubleTy(*TheContext));
}

Value *VarExprAST::codegen() {
  std::vector&lt;AllocaInst *&gt; OldBindings;

  Function *TheFunction = Builder-&gt;GetInsertBlock()-&gt;getParent();

  // Register all variables and emit their initializer.
  for (unsigned i = 0, e = VarNames.size(); i != e; ++i) {
    const std::string &amp;VarName = VarNames[i].first;
    ExprAST *Init = VarNames[i].second.get();

    // Emit the initializer before adding the variable to scope, this prevents
    // the initializer from referencing the variable itself, and permits stuff
    // like this:
    //  var a = 1 in
    //    var a = a in ...   # refers to outer 'a'.
    Value *InitVal;
    if (Init) {
      InitVal = Init-&gt;codegen();
      if (!InitVal)
        return nullptr;
    } else { // If not specified, use 0.0.
      InitVal = ConstantFP::get(*TheContext, APFloat(0.0));
    }

    AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);
    Builder-&gt;CreateStore(InitVal, Alloca);

    // Remember the old variable binding so that we can restore the binding when
    // we unrecurse.
    OldBindings.push_back(NamedValues[VarName]);

    // Remember this binding.
    NamedValues[VarName] = Alloca;
  }

  // Codegen the body, now that all vars are in scope.
  Value *BodyVal = Body-&gt;codegen();
  if (!BodyVal)
    return nullptr;

  // Pop all our variables from scope.
  for (unsigned i = 0, e = VarNames.size(); i != e; ++i)
    NamedValues[VarNames[i].first] = OldBindings[i];

  // Return the body computation.
  return BodyVal;
}

Function *PrototypeAST::codegen() {
  // Make the function type:  double(double,double) etc.
  std::vector&lt;Type *&gt; Doubles(Args.size(), Type::getDoubleTy(*TheContext));
  FunctionType *FT =
      FunctionType::get(Type::getDoubleTy(*TheContext), Doubles, false);

  Function *F =
      Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get());

  // Set names for all arguments.
  unsigned Idx = 0;
  for (auto &amp;Arg : F-&gt;args())
    Arg.setName(Args[Idx++]);

  return F;
}

Function *FunctionAST::codegen() {
  // Transfer ownership of the prototype to the FunctionProtos map, but keep a
  // reference to it for use below.
  auto &amp;P = *Proto;
  FunctionProtos[Proto-&gt;getName()] = std::move(Proto);
  Function *TheFunction = getFunction(P.getName());
  if (!TheFunction)
    return nullptr;

  // If this is an operator, install it.
  if (P.isBinaryOp())
    BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence();

  // Create a new basic block to start insertion into.
  BasicBlock *BB = BasicBlock::Create(*TheContext, &quot;entry&quot;, TheFunction);
  Builder-&gt;SetInsertPoint(BB);

  // Record the function arguments in the NamedValues map.
  NamedValues.clear();
  for (auto &amp;Arg : TheFunction-&gt;args()) {
    // Create an alloca for this variable.
    AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());

    // Store the initial value into the alloca.
    Builder-&gt;CreateStore(&amp;Arg, Alloca);

    // Add arguments to variable symbol table.
    NamedValues[std::string(Arg.getName())] = Alloca;
  }

  if (Value *RetVal = Body-&gt;codegen()) {
    // Finish off the function.
    Builder-&gt;CreateRet(RetVal);

    // Validate the generated code, checking for consistency.
    verifyFunction(*TheFunction);

    // Run the optimizer on the function.
    TheFPM-&gt;run(*TheFunction);

    return TheFunction;
  }

  // Error reading body, remove function.
  TheFunction-&gt;eraseFromParent();

  if (P.isBinaryOp())
    BinopPrecedence.erase(P.getOperatorName());
  return nullptr;
}

//===----------------------------------------------------------------------===//
// Top-Level parsing and JIT Driver
//===----------------------------------------------------------------------===//

static void InitializeModuleAndPassManager() {
  // Open a new module.
  TheContext = std::make_unique&lt;LLVMContext&gt;();
  TheModule = std::make_unique&lt;Module&gt;(&quot;my cool jit&quot;, *TheContext);
  TheModule-&gt;setDataLayout(TheJIT-&gt;getDataLayout());

  // Create a new builder for the module.
  Builder = std::make_unique&lt;IRBuilder&lt;&gt;&gt;(*TheContext);

  // Create a new pass manager attached to it.
  TheFPM = std::make_unique&lt;legacy::FunctionPassManager&gt;(TheModule.get());

  // Promote allocas to registers.
  TheFPM-&gt;add(createPromoteMemoryToRegisterPass());
  // Do simple &quot;peephole&quot; optimizations and bit-twiddling optzns.
  TheFPM-&gt;add(createInstructionCombiningPass());
  // Reassociate expressions.
  TheFPM-&gt;add(createReassociatePass());
  // Eliminate Common SubExpressions.
  TheFPM-&gt;add(createGVNPass());
  // Simplify the control flow graph (deleting unreachable blocks, etc).
  TheFPM-&gt;add(createCFGSimplificationPass());

  TheFPM-&gt;doInitialization();
}

static void HandleDefinition() {
  if (auto FnAST = ParseDefinition()) {
    if (auto *FnIR = FnAST-&gt;codegen()) {
      fprintf(stderr, &quot;Read function definition:&quot;);
      FnIR-&gt;print(errs());
      fprintf(stderr, &quot;\n&quot;);
      ExitOnErr(TheJIT-&gt;addModule(
          ThreadSafeModule(std::move(TheModule), std::move(TheContext))));
      InitializeModuleAndPassManager();
    }
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}

static void HandleExtern() {
  if (auto ProtoAST = ParseExtern()) {
    if (auto *FnIR = ProtoAST-&gt;codegen()) {
      fprintf(stderr, &quot;Read extern: &quot;);
      FnIR-&gt;print(errs());
      fprintf(stderr, &quot;\n&quot;);
      FunctionProtos[ProtoAST-&gt;getName()] = std::move(ProtoAST);
    }
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}

static void HandleTopLevelExpression() {
  // Evaluate a top-level expression into an anonymous function.
  if (auto FnAST = ParseTopLevelExpr()) {
    if (FnAST-&gt;codegen()) {
      // Create a ResourceTracker to track JIT'd memory allocated to our
      // anonymous expression -- that way we can free it after executing.
      auto RT = TheJIT-&gt;getMainJITDylib().createResourceTracker();

      auto TSM = ThreadSafeModule(std::move(TheModule), std::move(TheContext));
      ExitOnErr(TheJIT-&gt;addModule(std::move(TSM), RT));
      InitializeModuleAndPassManager();

      // Search the JIT for the __anon_expr symbol.
      auto ExprSymbol = ExitOnErr(TheJIT-&gt;lookup(&quot;__anon_expr&quot;));

      // Get the symbol's address and cast it to the right type (takes no
      // arguments, returns a double) so we can call it as a native function.
      double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress();
      fprintf(stderr, &quot;Evaluated to %f\n&quot;, FP());

      // Delete the anonymous expression module from the JIT.
      ExitOnErr(RT-&gt;remove());
    }
  } else {
    // Skip token for error recovery.
    getNextToken();
  }
}

/// top ::= definition | external | expression | ';'
static void MainLoop() {
  while (true) {
    fprintf(stderr, &quot;ready&gt; &quot;);
    switch (CurTok) {
    case tok_eof:
      return;
    case ';': // ignore top-level semicolons.
      getNextToken();
      break;
    case tok_def:
      HandleDefinition();
      break;
    case tok_extern:
      HandleExtern();
      break;
    default:
      HandleTopLevelExpression();
      break;
    }
  }
}

//===----------------------------------------------------------------------===//
// &quot;Library&quot; functions that can be &quot;extern'd&quot; from user code.
//===----------------------------------------------------------------------===//

#ifdef _WIN32
#define DLLEXPORT __declspec(dllexport)
#else
#define DLLEXPORT
#endif

/// putchard - putchar that takes a double and returns 0.
extern &quot;C&quot; DLLEXPORT double putchard(double X) {
  fputc((char)X, stderr);
  return 0;
}

/// printd - printf that takes a double prints it as &quot;%f\n&quot;, returning 0.
extern &quot;C&quot; DLLEXPORT double printd(double X) {
  fprintf(stderr, &quot;%f\n&quot;, X);
  return 0;
}

//===----------------------------------------------------------------------===//
// Main driver code.
//===----------------------------------------------------------------------===//

int main() {
  InitializeNativeTarget();
  InitializeNativeTargetAsmPrinter();
  InitializeNativeTargetAsmParser();

  // Install standard binary operators.
  // 1 is lowest precedence.
  BinopPrecedence['='] = 2;
  BinopPrecedence['&lt;'] = 10;
  BinopPrecedence['+'] = 20;
  BinopPrecedence['-'] = 20;
  BinopPrecedence['*'] = 40; // highest.

  // Prime the first token.
  fprintf(stderr, &quot;ready&gt; &quot;);
  getNextToken();

  TheJIT = ExitOnErr(KaleidoscopeJIT::Create());

  InitializeModuleAndPassManager();

  // Run the main &quot;interpreter loop&quot; now.
  MainLoop();

  return 0;
}
</code></pre>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>除特殊注明部分，本站内容采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a> 进行许可。</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/Origami404" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://wiki.hitsz.org" target="_blank"><span>HITsz LUG wiki</span></a>
            </li>
            
            <li>
                <a href="https://space.bilibili.com/1124374292" target="_blank"><span>bilibili</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/arch/">Arch</a>
            </span>
            
            <span>
                <a href="/tags/arm/">ARM</a>
            </span>
            
            <span>
                <a href="/tags/c/">C</a>
            </span>
            
            <span>
                <a href="/tags/docker/">Docker</a>
            </span>
            
            <span>
                <a href="/tags/git/">Git</a>
            </span>
            
            <span>
                <a href="/tags/haskell/">Haskell</a>
            </span>
            
            <span>
                <a href="/tags/https/">HTTPS</a>
            </span>
            
            <span>
                <a href="/tags/linux-%E5%B7%A5%E5%85%B7/">linux 工具</a>
            </span>
            
            <span>
                <a href="/tags/llvm/">LLVM</a>
            </span>
            
            <span>
                <a href="/tags/mgit/">mgit</a>
            </span>
            
            <span>
                <a href="/tags/python/">Python</a>
            </span>
            
            <span>
                <a href="/tags/windows/">Windows</a>
            </span>
            
            <span>
                <a href="/tags/%E5%8F%98%E5%88%86%E6%B3%95/">变分法</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9F%9F%E5%90%8D/">域名</a>
            </span>
            
            <span>
                <a href="/tags/%E5%AF%BC%E8%AE%BA/">导论</a>
            </span>
            
            <span>
                <a href="/tags/%E6%88%91%E4%BC%9A%E7%86%9F%E7%BB%83%E5%9C%B0%E5%AE%89%E8%A3%85xxx%E7%B3%BB%E5%88%97/">我会熟练地安装xxx系列</a>
            </span>
            
            <span>
                <a href="/tags/%E6%8A%98%E8%85%BE/">折腾</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E5%AD%A6/">数学</a>
            </span>
            
            <span>
                <a href="/tags/%E6%96%B0%E8%A7%82%E7%82%B9/">新观点</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/">服务器管理</a>
            </span>
            
            <span>
                <a href="/tags/%E6%AF%95%E6%98%87%E6%9D%AF/">毕昇杯</a>
            </span>
            
            <span>
                <a href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
            </span>
            
            <span>
                <a href="/tags/%E7%90%86%E8%AE%BA%E7%89%A9%E7%90%86/">理论物理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%B3%9F%E7%B3%95%E4%BD%86%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E4%B8%9C%E8%A5%BF/">糟糕但值得纪念的东西</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BA%BF%E4%BB%A3/">线代</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E7%A8%8B/">编程</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF/">编译前端</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E7%95%99%E5%9C%B0/">自留地</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/">自言自语</a>
            </span>
            
            <span>
                <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
            </span>
            
            <span>
                <a href="/tags/%E8%BD%AE%E5%AD%90/">轮子</a>
            </span>
            
            <span>
                <a href="/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/">非技术</a>
            </span>
            
        </div>
    </div>
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#71-前言">7.1 前言</a></li>
    <li><a href="#72-那么问题是什么">7.2 那么问题是什么？</a></li>
    <li><a href="#73-llvm-中的内存">7.3 LLVM 中的内存</a></li>
    <li><a href="#74-kaleidoscope-中的变量">7.4 Kaleidoscope 中的变量</a></li>
    <li><a href="#75-修改之前的变量实现">7.5 修改之前的变量实现</a></li>
    <li><a href="#76-崭新的赋值运算符">7.6 崭新的赋值运算符</a></li>
    <li><a href="#77-自定义局部变量">7.7 自定义局部变量</a></li>
    <li><a href="#78-完整代码">7.8 完整代码</a></li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/Origami404" target="_blank"><span>GitHub</span></a>
            </li>
            
            <li>
                <a href="https://wiki.hitsz.org" target="_blank"><span>HITsz LUG wiki</span></a>
            </li>
            
            <li>
                <a href="https://space.bilibili.com/1124374292" target="_blank"><span>bilibili</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/arch/">Arch</a>
            </span>
            
            <span>
                <a href="/tags/arm/">ARM</a>
            </span>
            
            <span>
                <a href="/tags/c/">C</a>
            </span>
            
            <span>
                <a href="/tags/docker/">Docker</a>
            </span>
            
            <span>
                <a href="/tags/git/">Git</a>
            </span>
            
            <span>
                <a href="/tags/haskell/">Haskell</a>
            </span>
            
            <span>
                <a href="/tags/https/">HTTPS</a>
            </span>
            
            <span>
                <a href="/tags/linux-%E5%B7%A5%E5%85%B7/">linux 工具</a>
            </span>
            
            <span>
                <a href="/tags/llvm/">LLVM</a>
            </span>
            
            <span>
                <a href="/tags/mgit/">mgit</a>
            </span>
            
            <span>
                <a href="/tags/python/">Python</a>
            </span>
            
            <span>
                <a href="/tags/windows/">Windows</a>
            </span>
            
            <span>
                <a href="/tags/%E5%8F%98%E5%88%86%E6%B3%95/">变分法</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9F%9F%E5%90%8D/">域名</a>
            </span>
            
            <span>
                <a href="/tags/%E5%AF%BC%E8%AE%BA/">导论</a>
            </span>
            
            <span>
                <a href="/tags/%E6%88%91%E4%BC%9A%E7%86%9F%E7%BB%83%E5%9C%B0%E5%AE%89%E8%A3%85xxx%E7%B3%BB%E5%88%97/">我会熟练地安装xxx系列</a>
            </span>
            
            <span>
                <a href="/tags/%E6%8A%98%E8%85%BE/">折腾</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E5%AD%A6/">数学</a>
            </span>
            
            <span>
                <a href="/tags/%E6%96%B0%E8%A7%82%E7%82%B9/">新观点</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86/">服务器管理</a>
            </span>
            
            <span>
                <a href="/tags/%E6%AF%95%E6%98%87%E6%9D%AF/">毕昇杯</a>
            </span>
            
            <span>
                <a href="/tags/%E6%B1%87%E7%BC%96/">汇编</a>
            </span>
            
            <span>
                <a href="/tags/%E7%90%86%E8%AE%BA%E7%89%A9%E7%90%86/">理论物理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%B3%9F%E7%B3%95%E4%BD%86%E5%80%BC%E5%BE%97%E7%BA%AA%E5%BF%B5%E7%9A%84%E4%B8%9C%E8%A5%BF/">糟糕但值得纪念的东西</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BA%BF%E4%BB%A3/">线代</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E7%A8%8B/">编程</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%89%8D%E7%AB%AF/">编译前端</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a>
            </span>
            
            <span>
                <a href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E7%95%99%E5%9C%B0/">自留地</a>
            </span>
            
            <span>
                <a href="/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/">自言自语</a>
            </span>
            
            <span>
                <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
            </span>
            
            <span>
                <a href="/tags/%E8%BD%AE%E5%AD%90/">轮子</a>
            </span>
            
            <span>
                <a href="/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/">非技术</a>
            </span>
            
        </div>
    </div>
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#71-前言">7.1 前言</a></li>
    <li><a href="#72-那么问题是什么">7.2 那么问题是什么？</a></li>
    <li><a href="#73-llvm-中的内存">7.3 LLVM 中的内存</a></li>
    <li><a href="#74-kaleidoscope-中的变量">7.4 Kaleidoscope 中的变量</a></li>
    <li><a href="#75-修改之前的变量实现">7.5 修改之前的变量实现</a></li>
    <li><a href="#76-崭新的赋值运算符">7.6 崭新的赋值运算符</a></li>
    <li><a href="#77-自定义局部变量">7.7 自定义局部变量</a></li>
    <li><a href="#78-完整代码">7.8 完整代码</a></li>
  </ul>
</nav>
    </div>
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2019-2022
                <a href="https://blog.origami404.top/">Origami404</a>
                
                | 基于 <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 构建
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>



<script defer src="/assets/js/fuji.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" />
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"></script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body);"
></script>




</body>

</html>
