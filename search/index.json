[{"content":"最近身体不适, 于是荒废了很多时间来看网文, 现在看完了来无聊来测测我的阅读速率. 以此掩盖我看小说摸鱼 21 小时的事实\n基本情况/数据 小说本身:\n 大小单位均为 byte\n  阅读的小说: 彩虹之门 重生之超级战舰 GBK 编码大小: 6,812,306 (lzma 压缩后: 2,235,155) UTF-8 编码大小: 10,173,587 (lzma 压缩后: 2,348,648) 字数: 中文字符 2967369, 非空白字符 3284508, 总字符 3451021  我的阅读速度:\n 该书在我的阅读器上共有 4301 页 我的平均阅读速度是 200 页每小时  根据此知乎文章中提到的数据, 中文字平均信息熵为 9.53, 那么计算得到:\n 平均中文字数阅读速度: 138 千字每小时, 或者 38.33 字每秒, 或者 365.29 bit/s 平均字数阅读速度: 153 千字每小时, 或者 42.5 字每秒, 或者 (假设空白标点与中文同信息熵) 406.3 bit/s 平均 GBK 阅读速度: 309 KiB/h, 或者 88.0 byte/s, 或者 704.0 bit/s 平均 UTF-8 阅读速度: 462 KiB/h, 或者 131.4 byte/s, 或者 1051.3 bit/s 平均 lzma 压缩阅读速度(总量取两种编码平均值): 104 KiB/h, 或者 29.6 byte/s, 或者 236.8 bit/s  感想  这小说真好看 我目前阅读速度应该取 365.3 bit/s 比较合适 也许可以每隔五年测量一下网文阅读速度以获得信息接受速度与年龄的关系? ","date":"2022-03-19","permalink":"https://blog.origami404.top/post/2020-03-entropy-rate-of-novel/","tags":null,"title":"我阅读网文的信息熵速率"},{"content":"波兹曼认为, 电报, 摄影术和电视消解了信息的上下文, 使之成为割裂的片段, 妨碍了深入的思考. 而在当下, 这种消解似乎愈演愈烈 \u0026ndash; 如果说电视节目至少还要半小时一集的话, 短视频就只要几十秒钟了. 但是, 基于超文本的 \u0026ldquo;互联\u0026rdquo; 形式, 似乎得以构建一种新形式的, 非线性的上下文.\n所谓 \u0026ldquo;消息的上下文\u0026rdquo;, 也许不过就是其他一系列消息. 这种说法想来波兹曼先生不会同意 \u0026ndash; 他应该会说, 一个合适的上下文除了消息本身, 更重要的是它们之间的联系与关系, 以及一些超脱于信息之上的思考, 或者说抽象的信息. 在文字中, 这些关系透过连接词被表示出来. 经由电视产生的无意义连接词本身反映了电视对这种上下文的消解. 而网页链接, 似乎也是一种 \u0026ldquo;无意义通用连接词\u0026rdquo; \u0026ndash; 毕竟两个 \u0026lt;a\u0026gt; 标签能有多少不同呢? 还真可以很不同, 因为我们可以在里面放不同的字; 链接的说明文字对一个链接的上下文至关重要.\n那么, 我们是否可以通过链接, 来抵挡碎片化所带来的上下文缺失呢? 我认为是可以的, 但不是旧的基于线性文字的上下文, 而是一种新的形式, 新到也许你不认为这像那种传统意义上的上下文.\n首先, 碎片化, 无上下文的信息是有其好处的: 这意味着它们 \u0026ldquo;可复用\u0026rdquo;. (虽然, \u0026ldquo;可复用\u0026rdquo; 这个词本身暗指了 \u0026ldquo;没有信息\u0026rdquo; \u0026ndash; 如果一句话能适用于所有情况, 那么它根本无助于指示任何一种情况). 可复用的信息听起来也许很别扭, 但是也许它早已有了自己的名字: 知识. 知识的一个可以接受的定义便是 \u0026ldquo;可复用的信息\u0026rdquo;, 而知识之间的连接更是一般人所推崇的. 可为什么基于连接的知识(维基)在深入的层面上还是很难取代线性的知识(课本)呢? 对这个问题, 我也没有答案. 也许比起图, 人脑更适合处理线性的知识. 毕竟根据我的经验, 人对大规模的图的把握能力是很弱的. 但是, 人脑中也许一直存在这一张大图 \u0026ndash; 只是我们不擅长于获取节点的所有邻居罢了.\n图化的碎片信息会导致非阻塞(异步)的访问. 在图状的信息里, 人们很容易卡在一条信息之后就把它放进队列里, 然后马上滑向下一条, 就好事件循环的队列里一样 \u0026ndash; 不过很可能再也没有 await 了. 于是从信息的获取开始, 人们开始追求各种各样的非阻塞的操作, 比如追求即时交互, 害怕耗时长的活动. 事实上, 我目前可能就是一个这样的人. 在写这篇文章的过程中, 我无数次想打开手机/qq/tg, 想跳到新的信息去. 好在我刚刚看完书, 还能强迫自己在这写. 我发现我越来越不能做单件耗时长的任务了.\n当然, 这可能是很正常, 甚至正确的想法. 马拉松运动员会自觉把长跑分成短跑, 好的程序员擅长将大需求分解成小需求. 更大的任务意味着更多的不确定性, 也意味着更大的绝对误差. 我之前便对自己的这个缺点有所意识, 但我认为, 也许不必过多担心: 本来我就不需要做大任务, 我只需要把大任务切小, 然后做一组小任务就可以了. 但是波兹曼先生让我反思这种行为也许会导致不一样的结果: 一组小任务跟一个大任务, 正如电视和铅字, 是任务的两种载体. 也许将战线拉长使得更多的其他信息的碰撞与组合成为可能, 但一口气做完也有其独特的沉浸感. 我意识到能一口气完成一个大任务对自己的心态的影响是巨大的, 能极大地增加我对自己的信心. 或许这就是所谓的慢生活吧.\n其实这篇文章便是信息碎片化在我身上的绝佳体现: 这什么意识流奇妙文章. 我一直想用破折号 -- 连接子句, 这何尝不是一种 \u0026ldquo;ok, \u0026hellip; now\u0026rdquo;? 不过值得庆幸的是, 对于技术类文章我似乎仍(部分)保持住了铅字的优良传统 \u0026ndash; 至少它们还是逻辑统一, 并且能首尾呼应的. 似乎我应该尝试去训练如何像表达技术一样去表达自己的思想了, 这篇文章实在是太糟糕了.\n曾经, 我只是想将博客作为技术沉淀输出的平台, 抱持着\u0026quot;能顺带帮到别人的话就最好了的\u0026quot;想法, 所以我很少往博客里写非技术类文章. 但是在看到了许多优秀的博主的博客之后, 我逐渐意识到, 有时候自己的心路, 自己的选择, 也能给予别人很大的感触与温暖. 所以至少现在的我, 觉得也许需要写点自己了. 即使这篇文章超烂的, 我也斗胆把它留着, 毕竟第一步总是值得纪念的, 不是吗? 如果打扰到 RSS 用户的话也请不要取关 qwq\n不过, 开始输出情绪跟倾向, 而不是基于理性的论证与思考, 又何尝不是一种娱乐至死呢.\n","date":"2022-03-15","permalink":"https://blog.origami404.top/post/2022-03-thinking-on-ao2d/","tags":["自言自语","非技术","自留地","糟糕但值得纪念的东西"],"title":"娱乐至死, 但信息时代"},{"content":"发现了重要的一点: 对人来说, 1k 节点的图跟 10k 节点的图完全没有差别: 都是一团黑糊糊的看不清的玩意. 所以大规模图可视化没有活路, 取样才是真理.\n 主要参考: https://github.com/Ashish7129/Graph_Sampling\n 基于探索(遍历)的取样 简单随机游走 SRW, Simple Random Walk 随机挑一个开始点, 然后随机游走(指每次随机取一个邻居), 当走到新点时就把点加入取样结果中. 如果在一段时间内都没有走到新点, 就随机换一个起始点重新开始.\n会影响取样图的平均度数等属性.\n带飞回的随机游走 RWF, Random Walk with Fly back probability 设定一个飞回概率 p. 每次随机游走选下一个点的时候, 以 p 的概率飞回起始点重新开始, 以 1-p 的概率进行随机选下一个点.\n其能确保起始点的所有邻居被充分地探索. 随着 p 增大, 取样近似于 BFS 的结果.\n带导出子图的随机游走 ISRW, Induced Subgraph Random Walk SRW 跟 RWF 都不能 “完整” 地体现原图的结构: 因为它们每次取样都只选择了一个邻居, 这导致几乎不可能把一个点的所有邻居都保留在取样中 \u0026ndash; 于是取样图的平均度数会比原图小. 并且, SRW/RWF 还会影响图的最短路/平均路径长度, 因为有很多的边被忽略了.\n于是我们修改 SRW 的单个取样策略 \u0026ndash; 每次走到新点的时候, 把这个新点及其全部邻居都加入取样图(也就是将新点的导出子图加入取样图), 这样也许能更好地反映原图的结构.\n雪球取样 SB, Snowball Sampling BFS, 但是限制每次只取 k 个不在取样图里的邻居. (每一片外层雪花负责滚来 k 片不在雪球里的雪花组成新的外层)\n林火取样 FF, ForestFire Sampling BFS, 但是每个邻居都只有一个概率被选中. (类似树林里树把火传到另一颗邻居树的概率)\nMetropolis-Hastings 随机游走 MHRW  梅特罗波利斯-黑斯廷斯算法, MH 算法, 是一种马尔可夫蒙特卡洛(MCMC)方法, 参考:\nhttps://zh.wikipedia.org/wiki/梅特罗波利斯－黑斯廷斯算法\n 随机选一个起始点 v 作为当前点, 记 D(v) 为 v 的度, 随机选一个邻居 w, 如果 p \u0026lt;= D(v)/D(w), 其中 p 是一个[0, 1]的随机数, 那么就把 “当前点” 设成 w (并把 w 加入取样). 一直做到取完样为止.\n带子图的 MHRW 如题, 就是取样的时候取导出子图的 MHRW.\n基于边的取样 带完全导出子图的边取样 TIES, Total Induction Edge Sampling 先在图中随机选边, 然后将边两端的节点加入选样. 当选样完后, 将选样图中所有节点导出的子图的其他边都补全进选样图中.\n","date":"2022-03-12","permalink":"https://blog.origami404.top/post/2022-03-graph-sampling-intro/","tags":["图论","导论"],"title":"图取样算法简介"},{"content":"总览  主要参考文章: https://thinkingeek.com/arm-assembler-raspberry-pi/\n绝大部分示例代码都是从此文章抄来的\n这篇参考文章偏向于使用 ARM 汇编进行开发的入门, 期望读者水平为学过 C, 还教了一些算法啥的. 作者还有一本书, 200来页, 书比网站上的更加系统, 建议看书.\n当然如果我写错了什么, 那当然是我的问题, 不关作者事.\n 这是一份对 ARMv7 汇编的急救指南, 目的是以最快速度提供 \u0026ldquo;实现一个 target 到 ARMv7 的 C 编译器\u0026rdquo; 所需要的 ARM 汇编知识. 本文章假设读者熟悉汇编语言与 C, 至少看过 CSAPP 的第 4 章, 并且了解一些编译技术.\n本文章 没有 :\n 任何对 不同模式 的介绍与说明 (也就是只考虑 User 模式) 任何对 浮点运算 的介绍与说明 对一些指令的完全介绍, 比如 ldm/stm 对规范的完整解释  本文章的介绍顺序大体按照那本书里的顺序, 为了方便查阅, 根据主题分类索引如下:\n 总览 \u0026amp; 框架: 基本架构 寄存器: 寄存器 分支: 分支, 控制结构的翻译, 条件执行 内存与取址模式: 内存, 基本取址模式, load/store 特有的取址 函数: 函数, 但不含栈, 函数, 但不含局部变量, 函数, 齐活了 动手实践: 用 GDB 调试汇编程序, 用 GCC 交叉编译 C 代码到 ARMv7 可执行文件并反编译  基本架构 第一个程序 \u0026amp; 如何运行 下面是一个返回值为 2 的简单的汇编程序：\n/* -- first.s */ /* 这是注释 */ .global main /* 一个程序的入口(entry) 必须是全局的(global) */ .func main /* 标记 label ’main’ 为一个函数 */ main: /* 这是 label main */ mov r0, #2 /* 将字面量 2 放入寄存器 r0 中 */ bx lr /* 从 main 中 \u0026quot;返回\u0026quot; */  简单地将其编译, 然后链接为可执行程序:\n$ as -g -mfpu=vfpv2 -o first.o first.s $ gcc -o first first.o  执行它并查看其返回值:\n$ ./first ; echo $? 2  如果懒得每次都打命令, 可以写一个简单的脚本:\n#!/bin/bash as -g -mfpu=vfpv2 -o $1.o $1.s gcc -o $1 $1.o rm $1.o ./$1 ; echo $?  解释 注释不可以嵌套.\n.开头的是给 GNU Assembler (简称 gas 或 as) 的指令(directive), 不是 ARM 汇编. (类比 C 的宏)\nglobal 跟 linkage 有关, 是给链接器看的; 由 gcc 负责调用链接器, 就不用我们手动指定库了.\n每一行 ARM 汇编都长这样:\n 标号: 指令 参数 注释   它们的英文是 label: instruction parameters comments\n 它们全都是可选的, 不一定都会出现. 特别地, 只有单独标号的一行将标号绑定到下一行, 这样子就可以将多个标号绑定到同一行上:\nA: mov r0, #1 /* 标号 A 绑定到这条指令 */ B: mov r0, #2 /* 标号 B 绑定到这条指令 */ C: D: E: mov r0, #2 /* 标号 C, D, E 绑定到这条指令 */  汇编里的空白是无所谓的, 参数依逗号分隔, 立即数(immediate, 类比 C 的字面量(literal)) 以 # 开头, 参数中用作目的地的参数常常在最左边(如这里的 r0).\n单行注释一般也可以用 @ 打头, 类似 bash/python 里的 # 跟 C++ 里的 //.\n直接使用 LD TODO\n寄存器 对树莓派 2B 来说, 除开特殊的寄存器, 共有 16 个通用整数寄存器以及 32 个通用浮点寄存器. 每一个通用整数寄存器(分别叫 r0 到 r15) 都是 32 位长的. 本章只讨论整数寄存器.\n汇编里的数据采用补码表示, 立即数同理.\n有些通用寄存器并不是真的 \u0026ldquo;通用\u0026rdquo; \u0026ndash; 它们在特定上下文有特定用途:\n r13 也被称为 sp (Stack Pointer) r14 也被称为 lr (Link Register) r15 也被称为 pc (Program Counter)  关于 fp, 一般是 r11, 但是官方貌似没有指定, 我看到的也有用 r7 的, 所以你随便挑一个就好了.\n下面的例子展示了寄存器的基本用法:\n/* -- sum01.s */ .global main main: mov r1, #3 /* r1 ← 3 */ mov r2, #4 /* r2 ← 4 */ add r0, r1, r2 /* r0 ← r1 + r2 */ bx lr  内存 对 ARM, 所有指令的参数必须是立即数或者是寄存器, 而不是像 x86 一样还可以直接塞内存地址. 用来将内存特定位置的值读入寄存器的指令是 ldr (load register), 用来写回去的是 str (store register).\n地址 地址是内存里特定位置的名字. 在 ARMv7, 地址是一个 32 位长的整数, 标识内存中每一个字节. 对汇编程序而言, 内存是扁平的.\n当从内存读/存数据时, 地址的计算方式(即取址模式, addressing mode)有很多种, 本章只介绍一种: 通过寄存器取址.\n汇编里的标号实质上被实现为这行汇编代码对应的二进制码在可执行文件里的地址. 所以我们可以把标号当作 \u0026ldquo;地址的立即数\u0026rdquo; 来看.\n我们可以使用汇编器指令来申请大块内存:\n.balign 4 @ 对齐到 4 字节, Byte ALIGN myvar1: @ 标号, 接下来就可以通过该标号获得数据的地址 .word 3 @ 留出 1 个 \u0026quot;word\u0026quot; 的空白 (32bit) 并将其设为补码 3  程序的数据一般会跟代码分开放在内存的不同区域(节, section). 使用 .data 让汇编器把下面的东西放在数据节(data section)里, 使用 .text 让汇编器把下面的东西放在代码节(text section)里.\nLoad 下面的程序定义两个内存中的变量 myvar1 和 myvar2, 分别赋予其初始值 3 和 4, 然后取其值, 相加, 返回作为错误码.\n/* -- load01.s */ /* -- Data section */ .data /* 确保数据被对齐到 4 字节 */ .balign 4 /* 定义 myvar1 的存储空间(storage) */ myvar1: /* 一个值为 3 的 4 byte 整数 */ .word 3 /* 确保数据被对齐到 4 字节 */ .balign 4 /* 定义 myvar2 的存储空间(storage) */ myvar2: /* 一个值为 4 的 4 byte 整数 */ .word 4 /* -- Code section */ .text /* 确保代码被对齐到 4 字节 */ .balign 4 .global main main: ldr r1, addr_of_myvar1 /* r1 ← \u0026amp;myvar1 */ ldr r1, [r1] /* r1 ← *r1 */ ldr r2, addr_of_myvar2 /* r2 ← \u0026amp;myvar2 */ ldr r2, [r2] /* r2 ← *r2 */ add r0, r1, r2 /* r0 ← r1 + r2 */ bx lr /* 用来访问数据的标号 */ addr_of_myvar1 : .word myvar1 addr_of_myvar2 : .word myvar2  注意最下面的 addr_of_*. 即使标号 myvar1 已经包含了 myvar1 的地址, 但是因为这个标号在 .data 节里, 所以我们不能跨节, 在 .text 节里使用它. 我们必须在 .text 节里再做两个标号, 分别放它们的地址, 然后用标号来访问这些地址 \u0026ndash; 现在 addr_of_myvar1 是一个 \u0026ldquo;地址\u0026rdquo;, 这个 \u0026ldquo;地址\u0026rdquo; 指着一个 word, 这个 word 的值是 myvar1 的地址, 类似于一个二级指针.\n 总结: 标号不能跨节使用.\n 上面的 \u0026ldquo;地址\u0026rdquo; 打了引号: 因为重定位(relocation)的缘故, 它并不是一个真的地址, 而是一个待填的 \u0026ldquo;坑\u0026rdquo;; 这个坑将会在链接时被链接器补上.\n要把寄存器里的值当做地址传给 ldr, 我们只要用中括号把它括起来就可以了.\n但是这样子很烦人, 所以汇编器可以帮我们自动处理不同节的重定位: 我们不需要像上面一样补上最后两行然后跳两次 \u0026ndash; 我们可以直接使用 =\u0026lt;标号\u0026gt; 的形式来得到不同节里的标号值. 具体使用可见下节\nStore 下面的程序定义两个内存中的变量 myvar1 和 myvar2, 赋予其初始值 0, 然后使用 str 指令赋予其值 3, 4, 然后取其值, 相加, 返回作为错误码.\n/* -- store01.s */ /* -- Data section */ .data .balign 4 myvar1: .word 0 .balign 4 myvar2: .word 0 /* -- Code section */ .text .balign 4 .global main main: + ldr r1, =myvar1 /* r1 ← \u0026amp;myvar1 */ mov r3, #3 /* r3 ← 3 */ + str r3, [r1] /* *r1 ← r3 */ + ldr r2, =myvar2 /* r2 ← \u0026amp;myvar2 */ mov r3, #4 /* r3 ← 4 */ + str r3, [r2] /* *r2 ← r3 */ /* 跟之前一样 */ ldr r1, =myvar2 /* r1 ← \u0026amp;myvar1 */ ldr r1, [r1] /* r1 ← *r1 */ ldr r2, =myvar2 /* r2 ← \u0026amp;myvar2 */ ldr r2, [r2] /* r2 ← *r2 */ add r0, r1, r2 bx lr  注意上面代码的两个 str 指令的参数顺序, 我们写 str A, [B], 是将 A -\u0026gt; *B, 而不是像普通指令一样目的地在左边.\nGDB  If you develop C/C++ in Linux and never used gdb, shame on you.\n 本章介绍如何使用 GDB 方便地调试汇编程序.\n启动 GDB:\n$ gdb --args ./store01 GNU gdb (GDB) 7.4.1-debian Copyright (C) 2012 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \u0026quot;show copying\u0026quot; and \u0026quot;show warranty\u0026quot; for details. This GDB was configured as \u0026quot;arm-linux-gnueabihf\u0026quot;. For bug reporting instructions, please see: ... Reading symbols from /home/roger/asm/chapter03/store01...(no debugging symbols found)...done. (gdb)  现在我们进入了 GDB 的交互模式.\n退出 GDB:\n(gdb) quit  开始运行程序 \u0026ndash; 这会跳过所有 C 运行时库的初始化, 直接在标号 main 前停住.\n(gdb) start Temporary breakpoint 1 at 0x8390 Starting program: /home/roger/asm/chapter03/store01 Temporary breakpoint 1, 0x00008390 in main ()  反汇编:\n 使用 disas 作为简写也可\n (gdb) disassemble Dump of assembler code for function main: =\u0026gt; 0x00008390 :\tldr\tr1, [pc, #40]\t; 0x83c0 箭头指向**将要**被执行的指令 0x00008394 :\tmov\tr3, #3 0x00008398 :\tstr\tr3, [r1] 0x0000839c :\tldr\tr2, [pc, #32]\t; 0x83c4 0x000083a0 :\tmov\tr3, #4 0x000083a4 :\tstr\tr3, [r2] 0x000083a8 :\tldr\tr1, [pc, #16]\t; 0x83c0 0x000083ac :\tldr\tr1, [r1] 0x000083b0 :\tldr\tr2, [pc, #12]\t; 0x83c4 0x000083b4 :\tldr\tr2, [r2] 0x000083b8 :\tadd\tr0, r1, r2 0x000083bc :\tbx\tlr End of assembler dump.  查看寄存器:\n(gdb) info registers r0 r1 r2 r3 r0 0x1\t1 r1 0xbefff744\t3204446020 r2 0xbefff74c\t3204446028 r3 0x8390\t33680  修改寄存器的值:\n p 表示 print\n (gdb) p $r0 = 2 $1 = 2 $1表示执行 p 时求值求出的第一个结果 (gdb) info registers r0 r1 r2 r3 r0 0x2\t2 r1 0xbefff744\t3204446020 r2 0xbefff74c\t3204446028 r3 0x8390\t33680  引用之前输入的值:\n(gdb) p $1 $2 = 2  执行下一条指令:\n stepi 表示 step instruction\n (gdb) stepi 0x00008394 in main ()  打印变量/变量地址:\n(gdb) p \u0026amp;myvar1 $3 = ( *) 0x10564  (gdb) p myvar1 $4 = 0  执行到下一个标号:\n(gdb) continue Continuing. [Inferior 1 (process 3080) exited with code 07]  分支 (Branching) r15 在绝大部分情况下充当 pc 的作用, 寄存器名称 pc 就是 r15 的别名.\nARMv7 指令集定长, 32bit.\n改变 pc 的值的过程称为分支(Branching). 中文一般也叫跳转, 虽然跳转对应的英文应该是 jump.\n无条件跳转 单独使用 b \u0026lt;label\u0026gt; 指令来进行无条件跳转.\n/* -- branch01.s */ .text .global main main: mov r0, #2 /* r0 ← 2 */ b end /* 跳转到标号为 'end' 的位置 */ mov r0, #3 /* r0 ← 3 */ end: bx lr  有条件跳转 cpsr(Current Program Status Register) 寄存器是一个特殊寄存器, 保存了程序执行过程中一些条件信息. 其保存的四个 flag 分别是:\n N: Negative flag: 上一条指令的结果是否为负数 Z: Zero flag: 上一条指令的结果是否为 0 C: Carry flag: 上一条指令的结果是否需要第 33 个位才能表示 \u0026ndash; 加法溢出或者非借位减法都会使其为真 V: Overflow flag: 上一条指令的结果是否出现了溢出  我们可以使用 cmp A B 指令来 \u0026ldquo;做比较\u0026rdquo; \u0026ndash; 它相当于执行 sub ? A B(A - B), 运算中更新 cpsr, 但运算结果并不会保存在任何地方. 所以我们有:\n N: A \u0026lt; B Z: A == B C: A \u0026gt; B (发生了非借位减法) V: 溢出  我们可以透过 cpsr 的状态来判断常见的关系:\n   缩写 关系 cpsr 状态     EQ equal Z == 1   NE not equal Z == 0   GE greater or equal than N == V   LT lower than  N != V   GT greather than N == V \u0026amp;\u0026amp; Z == 0   LE lower or equal than N != V || Z == 1   MI minus/negative N == 1   PL plus/positive or zero N == 0   VS overflow set V == 1   VC overflow clear V == 0   HI higher C == 1 \u0026amp;\u0026amp; Z == 0   LS lower or same C == 0 || Z == 1   CS/HS carry set/higher or same C == 1   CC/LO carry clear/lower C == 0    上面的这些缩写可以拿来跟 b 指令组合变成 bXX 指令, 例如下面这个程序:\n/* -- compare01.s */ .text .global main main: mov r1, #2 /* r1 ← 2 */ mov r2, #2 /* r2 ← 2 */ cmp r1, r2 /* 用 \u0026quot;r1 - r2\u0026quot; 的伪操作来更新 cpsr 寄存器 */ beq case_equal /* cpsr 状态为 EQ, 即 Z == 1 时, 就跳转 */ case_different : mov r0, #2 /* r0 ← 2 */ b end /* branch to end */ case_equal: mov r0, #1 /* r0 ← 1 */ end: bx lr  实现控制流  这里描述的实现不是最优的, 只是能行的.\n更优的实现(具有更少跳转语句)参见龙书\n if/then/else if_eval: /* 求值条件, 并根据条件生成 cmp */ bXX else /* 合适的 bXX 用于跳转 */ then_part: /* 生成 then 块 */ b end_of_if else: /* 生成 else 块 */ end_of_if:  具体实现与短路的实现可以看龙书.\nwhile while_condition: /* 生成条件 E */ bXX end_of_loop /* 如果 E 是假的, 跳转 */ /* 生成循环体 */ b while_condition /* 无条件跳回开始 */ end_of_loop:  for 不带 continue 的 相当于:\nfor (A; B; C) S A; while (B) { S; C; }  带 continue 的 A; while (B) { S; // continue 相当于 goto step step: C; }  更紧凑的指令 / 取址模式 Indexing modes / 指令参数类型 通过之前的例子, 我们可以发现一条 ARM 汇编指令的参数可以是不同的类型(立即数/寄存器/[寄存器]/标号\u0026hellip;). 这些类型被称为 indexing mode (这个名字没啥意义, 反正你认为是参数类型就是了).\n指令的语法可以总结如下:\ninstruction Rdest, Rsource1, source2  其中 Rdest 与 Rsource1 都必须是一个寄存器, 而 source2 则可以塞入更多种类的操作数. 本章主要讨论 source2 的其他种类.\n 有些指令是不一样的, 但是总的来说就是这么个理, 比如 mov Rdest, source2\n 至于 ldr 跟 str 的特殊取址模式, 下章再讲.\n位移运算数  LSL #n/Rsource3: 逻辑左移, 左 n 位会丢, 右 n 位是 0. n 由立即数或者寄存器 Rsource3 里的值决定 LSR #n/Rsource3: 逻辑右移, 左 n 位是 0, 右 n 位会丢 ASR #n/Rsource3: 算术右移, 左 n 位填充为符号位, 右 n 位会丢 ROR #n/Rsource3: 向右旋转, 类似 LSR, 但右 n 位被推到左 n 位去  举几个例子:\nmov r1, r2, LSL #1 @ r1 \u0026lt;- (r2*2) mov r1, r2, LSL #2 @ r1 \u0026lt;- (r2*4) mov r1, r3, ASR #3 @ r1 \u0026lt;- (r3/8) mov r3, #4 mov r1, r2, LSL r3 @ r1 \u0026lt;- (r2*16)  更复杂的乘法:\nadd r1, r2, r2, LSL #1 @ r1 \u0026lt;- r2 + (r2*2) equivalent to r1 \u0026lt;- r1*3 add r1, r2, r2, LSL #2 @ r1 \u0026lt;- r2 + (r2*4) equivalent to r1 \u0026lt;- r1*5 sub r1, r2, r2, LSL #3 /* r1 \u0026lt;- r2 - (r2*8) equivalent to r1 \u0026lt;- r2*(-7) */ rsb r1, r2, r2, LSL #3 /* r1 \u0026lt;- (r2*8) - r2 equivalent to r1 \u0026lt;- r2*7 */  注意 rsb (Reverse SuBstract)指令, 它就是被减数跟减数顺序反过来的 sub 指令. 因为位移操作数只能在最后一个参数(source2)用, 所以 ARM 提供了这个指令来让我们不用用正常的 sub 减完再取负. (适合于我们想要对被减数使用位移的时候)\n这个主要用来做强度约减的.\n数组与结构体 定义/分配空间 C 语言里的数组/结构体定义可以翻译如下:\nint a[100]; struct my_struct { char f0; int f1; } b; char s[] = \u0026quot;This is a string\u0026quot;;  /* -- array01.s */ .data a: .skip 400 @ 预留 400 byte 的内存空间, 即 sizeof(a) b: .skip 8 @ 预留 8 byte 的内存空间, 即 sizeof(b), 要考虑对齐 S: .asciz \u0026quot;This is a string\u0026quot; @ ASCIi with Zero terminator, 会自动在最后附加空字符  Indexing mode / 索引模式 / 取址模式 不更新寄存器 (Non-updating indexing modes)  [R1, #±n]: 取地址 R1±n [R1, #±R2]: 取地址 R1±R2 [R1, ±R2, shift_op #±n]: shift_op 可以是上面提到过的任意位移操作, 取地址 R1 ± shift_op(R2, ±n)  其中 (1) 适合类似 a[N], N 为常数的索引, 也适合于结构体里取成员. (3) 适合于 a[i], i 是变量的索引. 假如 a 是 i32 类型的数组, 那么只要 [a, i, LSL #4] 就可以了.\n例子:\nstr r2, [r1, #+12] @ *(r1 + 12) \u0026lt;- r2 str r2, [r1, +r3] @ *(r1 + r3) \u0026lt;- r2 str r2, [r1, +r2, LSL #2] @ *(r1 + r2*4) \u0026lt;- r2  取址后更新寄存器 (Post-indexing modes) 考虑下面的 C 代码:\nfor (int i = 0; i \u0026lt; n; i++) { a[i] = i; }  如果正常地按照字面意思来翻译的话, 我们会翻译成这样:\n/* 假设 r0 存了 a 的首地址, r1 存了 n 的值 */ /* 用 r2 来当 i */ mov r2, #0 loop: cmp r2, r1 bge loop_end str r2 [r0, +r2, LSL #2] @ r2 -\u0026gt; *(r0 + r2*4) add r2, r2, #1 @ r2 \u0026lt;- r2 + 1 b loop loop_end:  但是仔细想想, 我们并不需要每一次访问元素都算一次地址, 我们可能可以这样实现:\n/* 假设 r0 一开始存了 a 的首地址, r1 存了 n 的值 */ mov r2, #0 loop: cmp r2, r1 bge loop_end str r2 [r0] @ (*) r2 -\u0026gt; *r0 add r0, r0, #4 @ (*) r0 \u0026lt;- r0 + 4 add r2, r2, #1 @ r2 \u0026lt;- r2 + 1 b loop loop_end:  而 ARM 为这种情况提供了一个快速的取址模式: \u0026ldquo;取址, 然后更新\u0026rdquo;. (*) 两行可被合并为 str r2 [r0], #+4\n [R1], #±n: 取地址 R1, 然后 R1 ±= n [R1], #±R2: 取地址 R1, 然后 R1 ±= R2 [R1], ±R2, shift_op #±n: 取地址 R1, 然后 R1 ±= shift_op(R2, ±n)  取址前更新寄存器 (Pre-indexing modes) 同样, 也有先更新寄存器, 再取址的取值模式:\n [R1, #±n]!: R1 ±= n, 然后取地址 R1 [R1, #±R2]!: R1 ±= R2, 然后取地址 R1 [R1, ±R2, shift_op #±n]!: R1 ±= shift_op(R2, ±n), 然后取地址 R1   好怪啊, 为什么不把 pre 和 post 的语法反过来\n 访问 要想访问数组的第 i 个元素, 我们就直接像上面那样使用 [a, #i LSL #2](*(a+4*i)) 就可以了.\n要想访问结构体的域, 我们也像上面那样, 不过这次是计算出偏移量然后加上: [p, #offset] (*(p + offset))\n函数 基本知识 一段代码要想成为一个 \u0026ldquo;函数\u0026rdquo;, 必须遵守一些约定. 这些约定用来约束函数执行前后的 CPU 状态. 在 Linux 上, 一个 ARM 汇编函数必须遵守 ARM 结构过程调用规范(ARM Architecture Procedure Call Standard, AAPCS).\n寄存器 r14 又叫 lr (link register), 保存了调用本函数的指令的下一条指令的地址(可以看作是执行完要返回哪里)\n寄存器 r13 又叫 sp (stack pointer), 保存了栈顶的地址.\n参数传递 首四个参数必须被按顺序存于 r0, r1, r2, r3.\n更多的参数置于栈中 TODO\n\u0026ldquo;好\u0026quot;函数  函数不应该依赖开始执行时 cpsr 的状态 函数可以自由修改 r0, r1, r2, r3 除非被用于传递参数, 否则函数不应该依赖于开始执行时 r0, r1, r2, r3 内的值 函数内部可以随意修改 lr, 但离开函数之后 sp 的值总应该是进入函数时 lr 的值 函数内部可以随意修改其他寄存器, 但离开函数时它们的值应该与进入时相同  调用函数 直接(立即)调用: bl \u0026lt;标号\u0026gt;, 此标号必须在 .text 节定义.\n间接调用: blx Rsource1, 其中 Rsource1 存着该函数的第一条指令的地址\n离开函数 直接跳转即可. bx Rsource1, 其中 Rsource1 应该保存着进入函数时 lr 的值.\n blx 指令在跳转的同时还会将 lr 设为 pc + #4, 而函数返回时我们只需要做一个简单跳转就好了, 所以直接用 bx\n 返回值 对于 32bit 的基础类型, 比如 C 的 char, short, int, long, 返回值存于 r0; 对于 64 位的基础类型, 返回值存于 r0 与 r1; 对于其他任何长度大于 32 bit 的类型, 返回值存于栈上.\n实例: Hello World (调用 C 标准库函数) /* -- hello01.s */ .data greeting: .asciz \u0026quot;Hello world\u0026quot; /* .asciz: 以 0 结尾的字符数组 */ .balign 4 return: .word 0 /* 用于保存 lr 的值, 因为函数调用可能改变 lr */ /* 被调函数只负责能跳回来, **不负责**还原 lr 的值!!! */ .text .global main main: ldr r1, address_of_return /* r1 ← \u0026amp;address_of_return */ str lr, [r1] /* *r1 ← lr */ ldr r0, address_of_greeting /* r0 ← \u0026amp;address_of_greeting */ /* 传给 puts 的第一个参数 */ bl puts /* 调用 puts */ /* lr ← address of next instruction */ ldr r1, address_of_return /* r1 ← \u0026amp;address_of_return */ ldr lr, [r1] /* lr ← *r1 */ bx lr /* return from main */ address_of_greeting: .word greeting address_of_return: .word return /* 外部函数 External */ .global puts  栈 基本理论  sp 表示当前栈顶. 根据 AAPCS, 其应以 8 字节对齐. 离开函数时, sp 必须被恢复为进入函数时的值  在 Linux ARM 上, 栈向低地址方向增长.\n入栈/出栈理论上的操作如下:\nsub sp, sp, #8 /* sp ← sp - 8. 扩大当前栈帧 8 byte */ str lr, [sp] /* *sp ← lr */ ... // 函数的其他代码 ... ldr lr, [sp] /* lr ← *sp */ add sp, sp, #8 /* sp ← sp + 8. /* 减小当前栈帧 8 byte 将 sp 还原 */ bx lr  使用索引模式, 代码简化如下:\nstr lr, [sp, #-8]! /* preindex: sp ← sp - 8; *sp ← lr */ ... // Code of the function ldr lr, [sp], #+8 /* postindex; lr ← *sp; sp ← sp + 8 */ bx lr  阶乘程序 下面的程序实现了阶乘:\n/* -- factorial01.s */ .data message1: .asciz \u0026quot;Type a number: \u0026quot; format: .asciz \u0026quot;%d\u0026quot; message2: .asciz \u0026quot;The factorial of %d is %d\\n\u0026quot; .text factorial: str lr, [sp,#-4]! /* Push lr onto the top of the stack */ str r0, [sp,#-4]! /* Push r0 onto the top of the stack */ /* Note that after that, sp is 8 byte aligned */ cmp r0, #0 /* compare r0 and 0 */ bne is_nonzero /* if r0 != 0 then branch */ mov r0, #1 /* r0 ← 1. This is the return */ b end is_nonzero: /* Prepare the call to factorial(n-1) */ sub r0, r0, #1 /* r0 ← r0 - 1 */ bl factorial /* After the call r0 contains factorial(n-1) */ /* Load r0 (that we kept in th stack) into r1 */ ldr r1, [sp] /* r1 ← *sp */ mul r0, r0, r1 /* r0 ← r0 * r1 */ end: add sp, sp, #+4 /* Discard the r0 we kept in the stack */ ldr lr, [sp], #+4 /* Pop the top of the stack and put it in lr */ bx lr /* Leave factorial */ .global main main: str lr, [sp,#-4]! /* Push lr onto the top of the stack */ sub sp, sp, #4 /* Make room for one 4 byte integer in the stack */ /* In these 4 bytes we will keep the number */ /* entered by the user */ /* Note that after that the stack is 8-byte aligned */ ldr r0, address_of_message1 /* Set \u0026amp;message1 as the first parameter of printf */ bl printf /* Call printf */ ldr r0, address_of_format /* Set \u0026amp;format as the first parameter of scanf */ mov r1, sp /* Set the top of the stack as the second parameter */ /* of scanf */ bl scanf /* Call scanf */ ldr r0, [sp] /* Load the integer read by scanf into r0 */ /* So we set it as the first parameter of factorial */ bl factorial /* Call factorial */ mov r2, r0 /* Get the result of factorial and move it to r2 */ /* So we set it as the third parameter of printf */ ldr r1, [sp] /* Load the integer read by scanf into r1 */ /* So we set it as the second parameter of printf */ ldr r0, address_of_message2 /* Set \u0026amp;message2 as the first parameter of printf */ bl printf /* Call printf */ add sp, sp, #+4 /* Discard the integer read by scanf */ ldr lr, [sp], #+4 /* Pop the top of the stack and put it in lr */ bx lr /* Leave main */ address_of_message1: .word message1 address_of_message2: .word message2 address_of_format: .word format  快速保存各种寄存器: ldm \u0026amp; stm TODO 详细介绍\n使用 stmdb sp!, {r4, lr} 将 r4, lr 推入栈中; 使用 ldmia sp!, {r4, lr} 将 r4, lr 弹出栈(并且把对应寄存器的值设回去).\nGNU as 给我们提供了两个助记符: push {r4, lr} 与 pop {r4, lr}\n条件执行 对大部分指令, 在它后面加条件后缀(eq, ne, \u0026hellip;)即可:\nmp r2, #0 @ Compare r2 and 0 moveq r1, r1, ASR #1 @ if r2 == 0, r1 \u0026lt;- r1 \u0026gt;\u0026gt; 1. [r1 \u0026lt;- r1/2] addne r1, r1, r1, LSL #1 @ if r2 != 0, r1\u0026lt;-r1+(r1\u0026lt;\u0026lt;1). [r1 \u0026lt;- 3*r1] addne r1, r1, #1 @ if r2 != 0, r1 \u0026lt;- r1 + 1  需要注意的是, 一般的指令并不会改变 cpsr 的状态, 只有 cmp 跟加了后缀 s 的指令会改变 cpsr.\n/* for (int i = 100 ; i \u0026gt;= 0; i--) */ mov r1, #100 loop: /* do something */ subs r1, r1, #1 @ r1 \u0026lt;- r1 - 1, update cpsr with the final r1 bpl loop @ branch if the previous sub computed a positive @ number (N flag in cpsr is 0)  局部变量 快速总结  关于栈帧, 那本书里教的貌似不是 gcc 的做法, 注意对比\n 标准没有规定 fp 是哪个寄存器, 但通行做法是用 r11, GNU as 也支持使用 fp 作为 r11 的简写.\n标准对栈帧结构没啥要求, 只要你能符合 AAPCS 就可以了. 反汇编 arm-linux-gnueabihf-gcc 的编译结果可以看到 GCC 对栈帧的处理方式, 总结一下就是下面这样子(对应下面动手实践的星号行的时候的机器状态):\n | | Low address | | | | | | | |\u0026lt;----------+ + |......................................| | + | | | + | | | + | Local variable | | + | | | + |......................................| | + | | | + | | | + | Local variable | | + | | | + |......................................| | + | | | + | | | + | Local variable | | + | | | + +--------------------------------------+ | | | | | | | | (Last) Other registers(R4) | | | | | +--------------------------------------+ | | | | | | | | (Last) FP | | +----------------+ +--------+ |\u0026lt;---+ | | | | +--------------------------------------+ | +-+ Stack Pointer | | | | | | | | | | | +----------------+ | | (last) LR | | | | | | +----------------+ | +--------------------------------------+ | | | | | | +--------+ Frame Pointer | | | | | | | | | +----------------+ | | | | | | | | | | | High address +------\u0026gt;  一直通过 fp = *fp 就可以遍历当前整个栈, 看起来就好像用 fp 把栈帧都串起来了一样.\n动手过程 int fib(int x) { if (x == 1 || x == 2) { return 1; } else { return fib(x - 1) + fib(x - 2); } }  使用下面的命令反汇编: (我知道 gcc 可以直接出汇编, 但貌似 objdump 出来的格式好看点)(输出经过了美化, 可能你的原始输出会不太一样)\narm-linux-gnueabihf-gcc -march=armv7-a -O0 -static -g -c arm_stackframe.c -o arm_stackframe.O0.armv7.o arm-linux-gnueabihf-objdump -drwCS arm_stackframe.armv7.O0.o \u0026gt; arm_stackframe.armv7.O0.s   参数解释参见: https://stackoverflow.com/a/1289907\n arm_stackframe.armv7.O0.o: file format elf32-littlearm Disassembly of section .text: 00000000 \u0026lt;fib\u0026gt;: @int fib(int x) { /* ==================== 进入函数的处理 ====================== */ 0:\te92d4810 push\t{r4, fp, lr} @ 存 r4, 因为后面会用 4:\te28db008 add\tfp, sp, #8 @ 让 fp 指向栈里存着的 fp 8:\te24dd00c sub\tsp, sp, #12 @ 栈空间保留 3 * i32 /* *************************************** 上面的示意图就是现在的状态 *************************************** */ c:\te50b0010 str\tr0, [fp, #-16] @ 根据 AAPCS, r0 里是第一个参数, 这里把输入参数放到栈上 (可能是因为开了 O0, 默认假设参数都在栈上方便 codegen) @ if (x == 1 || x == 2) { 10:\te51b3010 ldr\tr3, [fp, #-16] @ 读取输入参数 14:\te3530001 cmp\tr3, #1 @ 短路比较 18:\t0a000002 beq\t28 \u0026lt;fib+0x28\u0026gt; 1c:\te51b3010 ldr\tr3, [fp, #-16] 20:\te3530002 cmp\tr3, #2 24:\t1a000001 bne\t30 \u0026lt;fib+0x30\u0026gt; @ return 1; 28:\te3a03001 mov\tr3, #1 @ 返回值存 r3 里, 跳转到返回 2c:\tea00000a b\t5c \u0026lt;fib+0x5c\u0026gt; @ } else { @ return fib(x - 1) + fib(x - 2); 30:\te51b3010 ldr\tr3, [fp, #-16] @ r3 读取第一个, 输入参数 34:\te2433001 sub\tr3, r3, #1 @ 减一 38:\te1a00003 mov\tr0, r3 @ 设好参数 3c:\tebfffffe bl\t0 \u0026lt;fib\u0026gt;\t3c: R_ARM_CALL\tfib @ 调函数 40:\te1a04000 mov\tr4, r0 @ r4 存返回值 44:\te51b3010 ldr\tr3, [fp, #-16] 48:\te2433002 sub\tr3, r3, #2 4c:\te1a00003 mov\tr0, r3 50:\tebfffffe bl\t0 \u0026lt;fib\u0026gt;\t50: R_ARM_CALL\tfib 54:\te1a03000 mov\tr3, r0 @ r3 存返回值 58:\te0843003 add\tr3, r4, r3 @ r3 = r3 + r4 @ } /* ==================== 返回的处理 ====================== */ 5c:\te1a00003 mov\tr0, r3 60:\te24bd008 sub\tsp, fp, #8 @ 局部变量退栈 64:\te8bd8810 pop\t{r4, fp, pc} @ 直接把存着 lr 的内存格子给 pc (相当于 bx lr)  顺带一提 O1 优化的版本如下:\narm_stackframe.armv7.O1.o: file format elf32-littlearm Disassembly of section .text: 00000000 \u0026lt;fib\u0026gt;: int fib(int x) { if (x == 1 || x == 2) { @ 对基本情况直接原地返回, 不操作栈 0:\te2403001 sub\tr3, r0, #1 4:\te3530001 cmp\tr3, #1 8:\t8a000001 bhi\t14 \u0026lt;fib+0x14\u0026gt; return 1; c:\te3a00001 mov\tr0, #1 } else { return fib(x - 1) + fib(x - 2); } 10:\te12fff1e bx\tlr int fib(int x) { 14:\te92d4070 push\t{r4, r5, r6, lr} 18:\te1a04000 mov\tr4, r0 @ 这下没干存栈里再读回来的蠢事了 return fib(x - 1) + fib(x - 2); 1c:\te1a00003 mov\tr0, r3 20:\tebfffffe bl\t0 \u0026lt;fib\u0026gt;\t20: R_ARM_CALL\tfib 24:\te1a05000 mov\tr5, r0 28:\te2440002 sub\tr0, r4, #2 2c:\tebfffffe bl\t0 \u0026lt;fib\u0026gt;\t2c: R_ARM_CALL\tfib 30:\te0850000 add\tr0, r5, r0 34:\te8bd8070 pop\t{r4, r5, r6, pc} ","date":"2022-02-13","permalink":"https://blog.origami404.top/compiler-and-type-theory/2022-02-armv7-basic/","tags":["汇编","ARM","毕昇杯"],"title":"毕昇杯专用 ARMv7 汇编急救"},{"content":"记录一下当我买了一个域名之后前前后后的折腾结果, 包含很多概论性的讲解, 应该对还没有配过 HTTPS 的小伙伴有一定的帮助.\n本文的定位大概就是 \u0026ldquo;没吃过猪肉, 还没见过猪跑吗\u0026rdquo; 中的 \u0026ldquo;猪跑\u0026rdquo; 吧.\n域名是什么? 域名 , Domain Name, 是一个可以写在 url 里的名字.\n我们知道, 当下互联网上(同一个网络内)的实体是靠 IP 地址来唯一标识的. 完成域名到 IP 地址转换的系统称为 DNS. DNS 的主要构成部分是大大小小的 DNS 服务器. DNS 服务器接受客户的访问, 返回域名对应的 IP 地址; 它是多级缓存的分布式数据库, 通过将请求 “转发” 给其他服务器实现了具有层次结构的名称空间.\n如何 “拥有” 一个域名: 理论 那么, 在这个庞大的系统里, 我们要如何插入一条属于我们的记录呢?\n答: 给钱.\n尽管 DNS 是可以是分布式的系统, 但显然域名的管理不能是分布式的(真的吗?). ICANN, 互联网名称与数字地址分配机构(Internet Corporation for Assigned Names and Numbers), 一个位于美国加州的非营利社团, 负责域名与 IP 地址的分配. ICANN 直接管理顶级域名(TLD, top-level domain), 并且适当地把一些顶级域名分配给其他组织, 譬如:\n 基础建设 TLD (.arpa) 国家及地区 TLD (ccTLD): 如 .cn, .uk 等 国际 TLD (IDN) 通用 TLD (gTLD): 如 .com, .org, .net 等  这里有一个 TLD 列表.\nICANN 是非营利组织, 它把一些顶级域名的注册服务承包出去, 那些承包商可就不是非营利的了. 他们负责维护域名的 whois 信息(就是一大堆你的个人信息, 为了在法律上证明你对该域名的所有权), 保证域名的唯一性, 也许还为倒卖域名的其他公司提供支持 :(. 所以, 为了获得一个域名, 我们需要前往某个域名注册提供商那里支付一笔费用, 随后他们便会负责帮你去 ICANN 或者哪里为你注册一个域名.\n如何 “拥有” 一个域名: 实践 常见的外国域名注册提供商有:\n GoDaddy, 狗爹, 最大的一家, 小贵, 而且有点黑料 Gandi Namecheap, 顾名思义, 主打便宜, 还送邮箱服务, 但是貌似不能支付宝 ResellerClub, 印度公司, Web 页面很拉, 但是便宜, 而且是亚洲龙头  国内的提供商有:\n 万网 DNSPod 新网 趣域网, 免实名, 但是页面看起来很拉 阿里云腾讯云这些貌似也可以买, 而且说不定有备案服务  国内的提供商大多需要实名/备案, 但国内的基本上都比国外便宜(国外赚美刀花美刀怎么能一样呢). 况且很多国外的提供商都提供 whois 信息保护, 信息泄露可以少一点.\n上面的信息都是聊天聊来的. 出于贫穷+不想实名, 我选择在 ResellerClub 购入了一个 .top 域名(就是现在这个啦). 根据群友说法, .top 域名注册商是国内某家公司, 所以人力成本很低, 所以便宜 :(. 我的 id 字母混数字, 就更加便宜, 10 年只需要 277 CNY.\n在 RC 的网站上选好域名, 注册账号. 注册账号要填很多信息, 这些信息可能在打官司的时候有用, 但鉴于我又不会拿这个域名来干什么, 我就直接填了我们学校的信息(笑)\n地址倒是卡了我一下 \u0026ndash; 虽然帮李华写了很多信, 但是没写过英文地址啊. 咨询群友意见之后, 我选择了全拼音(包括 “Lu, 路” 之类的), 首字母大写, 逆序 (地址由小到大, 逗号分隔) 的形式.\n最后记得把 域名隐私保护 那个按钮打开就可以了.\n注册了域名, 接着就是要往 DNS 里插信息了. DNS 中维护了几类记录:\n 主机记录 (A 记录): 记录域名对应到哪个 IPv4 地址. 别名记录 (CNAME 记录): 记录域名对应到哪个域名. (“不要来烦我, 去找这个域名!”) IPv6主机记录 (AAAA 记录): 记录域名对应到哪个 IPv6 地址. 域名服务器记录 (NS 记录): 用来指定该域名由哪个DNS服务器来进行解析. 每个注册的域名都可以由多个 DNS 域名服务器来进行解析, 并且在注册的时候就会默认被塞几条域名注册商提供的 NS 记录. 一般这个记录长这样子: ns1.domain.com、ns2.domain.com…. 这个记录只有域名注册商那里可以改, 所以如果你能改这个记录, 那你必然是域名的所有者. 纯文本记录 (TXT 记录): 就是简单地把 DNS 当 “字典” 用; 这种记录一般用来验证你是域名的管理者: 只有能访问 NS 记录中的 DNS 服务提供商的人才能添加 DNS 记录.  因为 RC 默认的 DNS 记录管理很拉, 所以我们选择使用 Cloudflare 来管理我们的 DNS 记录. 首先注册一个 Cloudflare 账号, 然后把刚刚买的域名填进去, 接着按照指示去 RC 里修改 NS 记录把管理权交给 Cloudflare 就可以了. 接着我们就可以在 Cloudflare 里加记录了. (或者, 让程序通过 API 来往里面加记录)\n有了域名还不够, 现在都 2022 年了, 怎么还能不上 HTTPS 呢. 等等, HTTPS 是啥?\n为什么要申请 SSL 证书 / 上 HTTPS? \u0026ndash; 一张 SSL 证书能干什么呢?\n\u0026ndash; 能证明你访问这个域名访问到的, 就是申请证书的主机.\n 当然一张高级证书里可以塞进别的信息, 证明该域名的一些其他信息.\n像上面那样的, 只是证明访问域名访问到的是特定主机的证书, 叫 DV 证书, Domain Validated certificates\n往证书里塞入其他信息, 比如域名持有者的公司信息之类的, 就可以得到高级证书, 比如 OV 证书或者是 EV 证书. (organization validated (OV) and extended validation (EV) certificates)\n偶尔你可以在浏览器的小锁上看到某某公司的名字, 这就是高级证书了 (笑)\n SSL 证书是如何起作用的? SSL 证书的验证流程大概是这样的:\n 浏览器解析域名, 做 DNS, 拿到 ip, 访问 ip 首先从那个 ip 里收一张证书回来 然后拿证书开始加密通信  验证过程中可能出现的问题与解决方法:\n 我要是在 DNS 部分动手脚, 访问到假 ip, 给假证书, 怎么办?  DNS 很难动手脚 证书的颁发是需要权威机构(CA)的认证的, 并且需要检验你是不是域名的管理者; 域名信息是写在证书里的, 所以不能通过简单的让浏览器访问假 ip 来骗   证书在传输过程中被截了怎么办?  证书也是被签名的, 浏览器收到证书会先检验你这证书是不是真的. 检验证书的证书, 检验检验证书的证书, 一直套娃, 到最后的根证书, 形成了一条相继确保安全的证书链. 这条链的根节点, 根证书, 其私钥被全世界最权威的机构以最安全的形式保管, 公钥被直接放在常见的操作系统里, 安装就有. 要想修改证书就得打破这条链, 但是这要是被打破了, 那天就塌了, 也轮不到我们来担心了 :)    所以, 有了 SSL 证书, 至少中间人攻击就难搞了; 数据的传输也被证书加密, 从而很难被嗅探到了.\n那如何申请一张证书呢? 要申请证书, 自然要先 买服务器 (钱无预定). 为了省心我直接买了 Vultr 新的韩国机房的 5$/mo 的机子, 1g1c 跑点小服务足以. IPv4 ping 100-150ms, IPv6 ping 250ms左右, 套层代理就很快了, 所以没大问题.\n然后就 是找 便宜 靠谱的 CA 来给你签一份证书. 作为穷人自然是选择给免费发证书的 CA: Let’s Encrypt. Let’s Encrypt 注册的证书一张管 90 天, 只能在倒数 30 天之前续签; 同时可以选择签通配符证书, 也就是一张证书证掉所有域名(比如*.origami404.top), 这样子就可以放肆使用子域名了.\n申请证书的方式有很多种, 比如你可以派一个人去 CA 的总部把证书抄回来然后打进去, 也可以通过 ACME 协议 (这协议就是 Let’s Encrypt 那班人弄出来的来着)来自动申请. ACME 现在的版本是 ACME v2, 不跟 v1 向后兼容, 主要比 v1 好的地方就是支持签通配符证书.\nACME 的原理 在 ACME 协议里, 我们有两个程序, ACME 客户端跟服务端. 服务端运行在 CA 的服务器上, 客户端运行在需要申请证书的服务器上. 当安装客户端时, 客户端会要求你输入你想申请证书的域名与 CA. 随后其:\n 生成一个密钥对(也就是一个公钥跟对应的一个私钥), 然后与 CA py, 通过 HTTPS 链接(这个链接此时由 CA 的 SSL 证书保障)来跟 CA share 这个对. 这个密钥对又叫 authorization key pair (下文简称 AK) CA 生成一个 HTTP/DNS 挑战(issue challenges (DNS or HTTP)) 来验证客户端对其宣称的域名的控制权. 为保安全, CA 还会发送一个随机数, 叫 nonce, 给客户端. 客户端必须用 AK 的私钥给它签名, 然后发回去, 以证明自己手上确实有私钥.  HTTP 挑战认定了这样一个事实: 如果在 DNS 里, 你这个域名对应到的 ip 就是发出请求的服务器的话, 那你就是 “控制” 着这个域名. 因此, HTTP 挑战的主要流程如下:\n CA 给客户端发一个 token 客户端收到 token, 创建一个文件, 里面包含了这个 token 跟 AK 的指纹 客户端监听 80 端口, 准备把文件送出去, 同时通知 CA 说我好了 CA 访问域名, 解析到 ip 地址, 访问那个 ip 地址的服务器的 80 端口, 尝试收文件. 一旦收到正确的文件了, 就认为挑战成功.  DNS 挑战则认为, 如果你能往 DNS 里插这个域名关联着的记录, 那你就 “控制” 着这个域名. 于是, DNS 挑战的主要流程如下:\n CA 给客户端发一个 token 客户端收到 token, 然后生成一个包含了 token 和 AK 指纹的一个字符串 (内容同 HTTP 挑战里的文件内容) 客户端往 DNS 里加入一条 TXT 记录, 记录的值就是这个字符串, 然后通知 CA 来收 CA 通过 DNS 查询得到 TXT 记录的值, 检查是不是自己发的. 如果值正确了, 就认为挑战成功.  HTTP 挑战的主要坏处就是它要占用 80 端口一段时间 \u0026ndash; 在这段时间里我们的服务就得停一会, 挺烦的. 而 DNS 挑战的主要坏处就是它需要让客户端这个程序能操纵你的 DNS 管理商. 对于正常的应用而言, 一般都是选择 DNS 挑战, 毕竟一般来讲我们都不想让网站每两个月就当掉 10-15 分钟, 并且主流 DNS 管理商(比如 Cloudflare)都提供了对应的 API 供 ACME 客户端使用. 但我选择了 HTTP 挑战 \u0026ndash; 因为 Caddy 可以自动帮我处理这件事.\n这就不得不讲讲如何用一台服务器跑多个应用了 \u0026ndash; 毕竟 80/443 端口只有一个, 不是吗?\n用一台服务器跑多个应用 理论: 子域名, 反向代理, 以及边缘网关 在网络里, IP 地址用于确定某一台主机, 而端口号则可以用来确定主机上哪一个程序提供服务. 系统把端口号分给不同的应用, 在收到数据包之后根据端口号把数据包转给不同的应用处理, 于是我们就可以在一台服务器上同时运行多个需要访问网络的应用了. 需要访问不同应用, 就在地址上加上端口号就可以了, 比如这样: 127.0.0.1:3000.\n当我们在浏览器里输入域名的时候, 浏览器就拿域名去找 DNS, 讨回来一个 IP 地址, 然后访问. 但问题是, 浏览器拿到了 IP 地址, 会访问它哪个端口呢?\n一个直觉的想法是, DNS 返回的 ip 地址应该是带着端口的, 这样浏览器不就知道了嘛. 然而 DNS 并没有这种功能 \u0026ndash; DNS 在设计时就只是负责 把域名映射到 IP 地址, 而 不 负责把域名映射到 IP地址+端口号.\n DNS 在设计的时候为啥不把端口号加上呢? 我猜测有二:\n 端口号相比 IP 地址, 变动得更加频繁, 加进去会加重 DNS 的负担 设计 DNS 的人忘记了 :(   所以浏览器拿到 IP 地址之后, 它也不知道该访问啥; 首先它会看看你打进去的 URL 是不是包含端口(有冒号), 有它就往那个 IP 发带着那个端口号的包; 没有的话, 浏览器就 直接假设你想访问 80 端口 (如果你的 URL 是 http 开头的, 走 HTTP 协议的话), 然后往那个 IP 发带着 80 端口号的包.\n现在假如我们想要这样子:\n 访问 A.origami404.top 就访问到 A 服务 访问 B.origami404.top 就访问到 B 服务 访问 C.origami404.top 就访问到 C 服务  要怎么办呢? 一个简单的解决办法是, 买三台服务器, 把这三个域名绑定到三个 IP 上. 然而我并没有钱.\n俗话说, “计算机科学里的任何问题都可以通过加一个抽象层解决”. 既然操作系统可以看端口把收到的包分给不同的应用, 我们也可以写一个应用, 专门守住 80 端口, 收到包之后解包, 看看包里写着的 “待访问域名”, 然后根据这个的值把包处理一下, 然后跟对应的程序建立连接, 把处理好的包发过去就好了.\n像这种 “守门口分包” 的功能, 叫 反向代理. 正向代理把服务端跟用户隔离, 只让服务端看到自己; 反向代理也把用户端跟服务器隔离, 但是只让用户看到自己. 常见的可以用来当反代的软件有:\n Nginx: 很出名, 很强大, 很快. 能均衡, 反代, 静态文件. 但是配置文件看起来很复杂 (快进到图灵完备) Apache: 很老, 不大快 Haproxy: 只做均衡和反代, 不能当静态文件服务器. 配置上比 nginx 更像 “网络配置” Caddy: 比较新, Go 写的; 自带一个 ACME 客户端, 可以自动通过 HTTP 挑战续 SSL 证书; 配置文件写起来很友好 Traefik: 很新, 可以直接管理各种容器(通过容器的 label 来动态地决定这包该发哪)  事实上大部分这些软件都能不止能做反代, 还能搞负载均衡/静态文件服务器等, 但无论如何做的都是 “守门口分包” 的工作: 负载均衡就是把收到的包均分丢几个不同服务器去, 静态文件服务器就是收包然后找文件发回去.\n基于好奇跟懒, 我选择了 Caddy 作为 “守门员”. 理由就像上面提到的那样:\n 相对来讲很快的速度(毕竟是 Go 写的), 对我这小户人家完全够用 可以 自动申请/续签证书, 不需要先把自己关掉, 让出 80 端口, 再用别的程序做 HTTP 挑战 配置文件(Caddyfile)很好写, Nginx 的配置文件直接劝退, 抄都抄不懂 :(  偶尔, 你也会看到上面的软件把自己叫做 “边缘网关”. 这个边缘指的是提供服务的服务器集群, 跟外部世界之间的边缘. 这些软件接受所有来自外界的访问, 将其转发, 就好像一个坐在边界的网关一样, 所以叫边缘网关.\n实践: 基于 Docker 的服务架构 如果一台服务器上跑多个服务的话, 各个服务的安装/管理/配置将会是一场噩梦. 幸好现在是 2022 年了, 我们有了非常好用的容器化技术, 以及还算可以的容器管理技术. 这次我打算把所有服务都丢容器里边, 同时充分利用 Docker 的 network 功能, 尽可能少地暴露端口.\n图中的每一个黑框框都代表一个容器, 虚线框框代表一个 network, 被框住的容器就代表其与该 network 相连. 最外边代表整个 Docker 环境, 只有 80/443 端口被暴露出来, 连接到守门员 Caddy 的容器里.\n我的管理方法是这样的, 对每一项服务, 比如 Outline, 创建一个子文件夹, 里面放一个 docker-compose.yml, 描述了这个服务. 如果有需要挂载出来的数据目录, 或者挂载进去的配置文件, 也都放在这个子文件夹里, 方便备份和管理. 大概目录就长这个样子:\n. └── services ├── caddy-main # Caddy 的目录 │ ├── caddy-config # 数据 │ ├── caddy-data # 数据 │ ├── Caddyfile # 配置, 每次加新服务都要修改这个文件, 增加反代规则, 然后重启 Caddy │ └── docker-compose.yml # Docker-compose ├── miniflux # Miniflux 的目录(一个 RSS 服务) │ ├── data # Miniflux 的数据存放的目录 │ └── docker-compose.yml # Docker-compose ├── outline # Outline 的目录 │ ├── docker-compose.yml # Docker-compose │ ├── docker.env # Outline 的环境变量太多, 单独拿一个文件出来设 │ ├── init_minio.yml # 用来初始化 MinIO 的命令, 因为有关系, 所以放在 Outline 这里 │ ├── minio_main_data # 数据 │ ├── outline_db_data # 数据 │ └── redis.conf # 配置 ............  然后 Caddy 如下配置:\n# Caddy docker-compose.yml version: \u0026quot;3\u0026quot; services: caddy-main: image: caddy:2-alpine container_name: caddy-main restart: always ports: - \u0026quot;80:80\u0026quot; - \u0026quot;443:443\u0026quot; volumes: # 把各种配置文件挂进去, 数据都挂出来 - \u0026quot;./Caddyfile:/etc/caddy/Caddyfile:ro\u0026quot; - \u0026quot;./caddy-config:/config\u0026quot; - \u0026quot;./caddy-data:/data\u0026quot; networks: # 将 caddy-main 容器加入 service-net 之中 - service-net networks: # service-net 这个顶层网络我们在外部单独创建 # 使其跟所有服务独立, 便于管理(不会说一不小心把哪个服务关了, 所有服务都死了) service-net: external: true  # Caddyfile # 对于任何访问到 80 端口的包, Caddy 都会把它们转发到对应域名的 443 端口去 # 也就是说相当于有一条 *:80 -\u0026gt; *:443 的转发规则 # 所以我们在下面只需要配置各个子域名的 443 端口的转发规则就可以了 # 对于访问 443 端口, 目标域名为 outline.origami404.top 的包 outline.origami404.top:443 { # 这些包的日志将会被记录 log { # 等级为 info level INFO # 记录在容器里的 /data/outline.log output file /data/outline.log { # 单个大小最大 10MB, 保留最近的 10 个这样的文件, 超过了就开始循环写入 roll_size 10MB roll_keep 10 } } # 设置给这个子域名进行 ACME HTTP 挑战的时候要交给 CA 的邮箱 tls Origami404g@gmail.com # 启用基于 gzip 的压缩传输 # 有可能会有问题, 但我还没遇到 2333 encode gzip # 设置反向代理(reverse_proxy) # 把收到的包丢到地址 http://outline:3000 去 # 因为我们提供服务的容器都在同一个 network, service-net 里 # 所以我们可以通过容器的名字当 url 互相访问容器 reverse_proxy outline:3000 } # 如果需要增加其他的服务, 照猫画虎复制粘贴就可以了, 只不过改改反代的目标地址而已 # 比如下面这堆, 可以将对 rss.origami404.top 的访问, 反代到对应的容器 miniflux 的 80 端口上. rss.origami404.top:443 { log { level INFO output file /data/miniflux.log { roll_size 10MB roll_keep 10 } } tls Origami404g@gmail.com encode gzip reverse_proxy miniflux:80 }  我看到貌似有可以直接通过给容器加 label 的形式定义 Caddy 的转发规则(而不用写在 Caddyfile 里), 从而真正实现动态增加服务 \u0026ndash; 然而我现在还不会\n然后我们稍微地配置一下 Miniflux 跟 Outline:\n此处不会详细介绍如何配置它们, 目的主要是介绍服务的架构\n# Miniflux docker-compose.yml version: \u0026quot;3\u0026quot; # 基本配置照抄官网 services: miniflux: image: miniflux/miniflux:latest container_name: miniflux # 注意这里我们不需要写任何的 ports # 这个 ports 是用来把端口绑定到主机上的 # 而我们根本不需要让外界能通过这个端口访问到该容器 # 我们只需要让 Caddy 能访问到这个容器就可以了 # 然而要做到上面这点, 我们只需要把容器们放到同一个网络就可以了 # 同一个网路的容器之间默认是都可以互相访问的 #ports: # - \u0026quot;80:80\u0026quot; depends_on: - db environment: - DATABASE_URL=postgres://miniflux:secret@db/miniflux?sslmode=disable - RUN_MIGRATIONS=1 - CREATE_ADMIN=1 - ADMIN_USERNAME=管理员用户名 - ADMIN_PASSWORD=管理员用户密码 healthcheck: test: [\u0026quot;CMD\u0026quot;, \u0026quot;/usr/bin/miniflux\u0026quot;, \u0026quot;-healthcheck\u0026quot;, \u0026quot;auto\u0026quot;] # 在这里对于网络的配置要注意加入这个 docker-compose 创建的默认网络 # 同一个 docker-compose.yml 里创建的容器可以互相访问的原因, 就是它们在同一个网络里 # 执行 docker-compose up 的时候, 首先创建一个网络 xxx_default, 然后再创建容器, 把容器加入到网络里 # 这个网络在 docker-compose.yml 里可以通过 default 来访问 networks: - service-net - default # 就是这个 db: image: postgres:latest container_name: miniflus_postgres environment: - POSTGRES_USER=miniflux - POSTGRES_PASSWORD=secret volumes: - ./data:/var/lib/postgresql/data healthcheck: test: [\u0026quot;CMD\u0026quot;, \u0026quot;pg_isready\u0026quot;, \u0026quot;-U\u0026quot;, \u0026quot;miniflux\u0026quot;] interval: 10s start_period: 30s networks: # 同样地, 指明这个网络是外部的, 这样执行这个的 docker-compose up 的时候 # 就不会尝试去创建一个网络 service-net, 而是去找一个已经存在的网络 service-net 了 service-net: external: true  # Outline docker-compose.yml version: \u0026quot;3\u0026quot; services: # 基本上就照抄官方的 outline: image: outlinewiki/outline container_name: outline env_file: ./docker.env restart: always # 同样不需要暴露端口 # ports: # - \u0026quot;3000:3000\u0026quot; # 同样网络记得加入 default, 要不然就不能访问数据库了 networks: - service-net - default depends_on: - postgres - redis - storage redis: image: redis container_name: outline_redis env_file: ./docker.env restart: always # 把数据啊配置啊全部挂出来, 不要用 docker volume volumes: - ./redis.conf:/redis.conf command: [\u0026quot;redis-server\u0026quot;, \u0026quot;/redis.conf\u0026quot;] # 不需要对外提供服务的容器根本不需要加入到 service-net 网络中 # 只需要加入到这个 docker-compose 定义的 default 网络就可以了 postgres: image: postgres container_name: outline_postgres env_file: ./docker.env restart: always volumes: - ./outline_db_data:/var/lib/postgresql/data networks: service-net: external: true  要运行的话, 就只需要简单地创建网络, 并且启动所有 docker-compose 就可以了.\n$ docker network create service-net # 创建网络 $ cd caddy-main \u0026amp;\u0026amp; docker-compose up -d # 把容器都创建起来 $ cd ../outline \u0026amp;\u0026amp; docker-compose up -d $ cd ../miniflux \u0026amp;\u0026amp; docker-compose up -d  子域名注册 现在我们的服务器已经准备好接收访问各个子域名的包了, 是时候来修改 DNS, 使所有子域名都被解析到我们的服务器上了. 在之前的文章里, 我们已经把域名的 NS 记录改成了 Cloudflare. 登录 Cloudflare 检查一下, 发现 CF 很贴心地直接帮我们加入了通配符形式的 DNS 记录, 不需要我们再进一步配置了.\n那么基本的配置到这里就结束了.\n","date":"2022-02-03","permalink":"https://blog.origami404.top/post/2022-02-domain-and-server-management/","tags":["域名","HTTPS","服务器管理","Docker"],"title":"购入域名之后..."},{"content":"7.1 前言 欢迎来到 我的第一个基于 LLVM 的语言前端 教程第七章。在前六章我们构建了一门小而强的函数式编程语言, 从中我们学到了如何去解析程序文本，构建与表示 AST，生成 LLVM IR 以及优化冗余代码和实现即时编译。\n尽管 Kaleidoscope 作为一门函数式语言已经足够优秀，但事实上其函数式特性使得为其生成 LLVM IR 显得 \u0026ldquo;过于简单\u0026rdquo; 了。特别是，函数式的风格令我们特别容易直接构建出 SSA 形式的 LLVM IR \u0026ndash; 而 SSA 经常将那些想用 LLVM 实现一门包含变量的命令式语言的初学者挡在门外。\n幸运的是，你并不需要直接在前端生成 SSA form: 尽管偶尔结果出人意料，但 LLVM 提供了非常健壮的 SSA 构建支持。\n7.2 那么问题是什么？ 为了理解为什么变量会阻碍我们生成 SSA form，考虑下面一段 C 语言代码：\nint G, H; int test(_Bool Condition) { int X; if (Condition) X = G; else X = H; return X; }  在这里，我们有一个变量 X, 它的值依赖于程序的执行路径。对于返回指令而言，X 的值有两种可能，所以我们需要插入一个 phi 节点来合并这两个值。大体上，我们希望编译器生成这样的 LLVM IR:\n@G = weak global i32 0 ; type of @G is i32* @H = weak global i32 0 ; type of @H is i32* define i32 @test(i1 %Condition) { entry: br i1 %Condition, label %cond_true, label %cond_false cond_true: %X.0 = load i32, i32* @G br label %cond_next cond_false: %X.1 = load i32, i32* @H br label %cond_next cond_next: %X.2 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ] ret i32 %X.2 }   译者注：关于上面的 LLVM 的一些解释\nLLVM IR 作为一种中间表示，其本身很少见地是强类型的。LLVM IR 内的所有 \u0026ldquo;变量\u0026rdquo; 依 SSA 定义只能被赋值 (\u0026ldquo;定义\u0026rdquo;) 一次且仅一次。而如果我们想要实现真实的 \u0026ldquo;变量\u0026rdquo;, 我们需要一块内存和一个指向该内存的指针，随后通过指针修改/读取内存的内容到变量中去。对于 C 的全局变量而言，其本身就不可能符合 LLVM IR 关于变量的 SSA 约束，于是 C 的全局变量在翻译成 LLVM IR 的 \u0026ldquo;变量\u0026rdquo; 的时候只能是作为一个指向它的指针。\n关于 LLVM IR 指针的快速介绍：\n 一个指针的类型是 \u0026lt;type\u0026gt;* 使用 alloca \u0026lt;类型\u0026gt; 来分配空间 使用 load \u0026lt;想读取的值的类型\u0026gt;, \u0026lt;指针类型\u0026gt; \u0026lt;指针变量\u0026gt; 指令来读取 使用 store \u0026lt;想写入的值的类型\u0026gt; \u0026lt;想写入的变量\u0026gt;, \u0026lt;指针类型\u0026gt; \u0026lt;指针变量\u0026gt; 来写入。  在随后对 LLVM IR 的优化过程中，LLVM 负责将对 \u0026ldquo;内存\u0026rdquo; 的读取优化为局部变量，同时构造出合适的 SSA Form. 这样做便避免了要求前端生成 SSA Form，极大地减轻了前端的工作量。\n 在上面的例子里，对全局变量 G 和 H 的求值需要显式加载 (load), 随后它们分别存活于 (live in) if 语句的 then 与 else 分支之中。为了合并两个分支中 X 的不同值，在 cond_next 块内的 X.2 使用了 phi 节点来依控制流选择值。当控制流经过 cond_false 块时，X.2 获得 X.1 的值; 当控制流经过 cond_true 块时，X.2 获得 X.1 的值。本章的主要目的不在于讲解 SSA Form 的细节，如需更多信息，请参阅此 参考.\n 译者注: SSA 术语解释：定义 (definition)，存活 (live) 与杀死 (kill)\n在 SSA 里，我们将对某变量的一次赋值称为该变量的定义。所谓一个变量的某个值在程序的某个位置存活，是指从那个值的某个赋值出发，经过所有可能的控制流到达该点时，其路径上都没有该变量的其他定义。一个变量的某个值被杀死，如果该变量被赋予了另外一个值。\n   译者注: SSA 术语解释: phi \u0026ldquo;节点\u0026rdquo; (phi node)\n一件值得注意的事情是，为什么 phi 指令要叫 \u0026ldquo;phi 节点\u0026rdquo;?\n事实上，LLVM IR 中基本块与其跳转组成了一张图 (称为 CFG，控制流图)，而图中控制流交会的那个节点 (即基本块) 一般都是要插入 phi 的，名词顺用下来就叫 phi 节点了。\n 本章的主要问题是，\u0026ldquo;谁在变量的赋值之前放下 phi 节点？\u0026rdquo; LLVM IR 要求中间代码必须满足 SSA，但构造 SSA Form 需要实现比较难的算法与数据结构，让所有前端都去被折磨一遍显然是得不偿失的。\n7.3 LLVM 中的内存 LLVM 虽然要求所有的寄存器变量 (就是普通的 LLVM IR 中的变量) 满足 SSA，但并不要求所有的内存对象满足 SSA. 在上面的例子中，我们通过对 G 和 H 的 Load 指令直接访问了它们 \u0026ndash; G 和 H 并不需要被 重命名/版本化。与其他编译系统不同，LLVM 不强制要求版本化内存中的对象，而是将对内存的数据流分析综合进 LLVM IR 里 \u0026ndash; 它将在分析类优化过程中被按需计算，随后处理。\n 译者注：粗体小句英文原文：they are not renamed or versioned.\n   译者注: SSA 术语解释：重命名 (rename)/版本化 (version)\n在普通的命令式程序中，我们经常对一个变量多次赋值。在 SSA 中，我们需要区别这多次赋值。比如说上面例子中的 X 变量，我们就将其重命名为 X.0, X.1, X.2 等来区分其包含不同值的时候。这种重命名有时候又叫版本化 (version，作动词), 指的是类似这种直接在变量名后面加数字的重命名方法。\n   译者注: LLVM 中的寄存器变量 (register variable) 与内存对象 (memory object)\n所谓寄存器变量，就是指正常的那些 % 开头的，可以被赋值的变量。在 LLVM IR 中我们拥有无限多的寄存器。寄存器变量要求满足 SSA 约束，可以直接塞进各种指令里当参数，或者是存放指令的结果。\n所谓内存对象，就是通过指针指向的某个对象。内存对象可以在堆上或者在栈上，需要使用 load/store 指令来访问/写入，不能直接作为指令参数/存放指令结果。\n正如上文所提到的，所有的全局变量 (以 @ 开头) 都是指针，指向某个内存对象。\n 知道了这个，我们就有实现变量的基本思路了：我们把所有变量都放在函数的栈里 (从而使其是一个内存对象), 然后我们就可以 \u0026ldquo;绕过\u0026rdquo; SSA 的约束了。为了实现它，我们需要了解 LLVM 是如何处理栈变量 (stack variable) 的。\n在 LLVM，所有的内存访问 (包括读取和写入) 都需要显式使用 load / store 指令。归功于 LLVM 的优秀设计，我们并不需要一个 \u0026ldquo;取地址\u0026rdquo; 运算符。注意全局变量 @G / @H 的实际类型是 i32*, 即便我们在声明它们的时候写的是 i32. @G 声明中的 i32 实际上意味着 @G 为全局数据区保留了一个大小为 i32 的内存空间，而名字 @G 实际上只是对那个空间的地址的一个引用。我们的栈变量以相同方式工作，除了我们这次使用 alloca 指令来声明它们：\ndefine i32 @example() { entry: %X = alloca i32 ; type of %X is i32*. ... %tmp = load i32, i32* %X ; load the stack value %X from the stack. %tmp2 = add i32 %tmp, 1 ; increment it store i32 %tmp2, i32* %X ; store it back ...  上面的例子展示了如何在 LLVM IR 中声明与维护栈变量。被 alloca 指令分配的栈内存可以被任意使用：你可以将该地址传递给其他函数，或者用它储存另一个变量。对于我们之前的实例代码，我们可以用 alloca 指令重写它以避免使用 phi 节点：\n@G = weak global i32 0 ; type of @G is i32* @H = weak global i32 0 ; type of @H is i32* define i32 @test(i1 %Condition) { entry: %X = alloca i32 ; type of %X is i32*. br i1 %Condition, label %cond_true, label %cond_false cond_true: %X.0 = load i32, i32* @G store i32 %X.0, i32* %X ; Update X br label %cond_next cond_false: %X.1 = load i32, i32* @H store i32 %X.1, i32* %X ; Update X br label %cond_next cond_next: %X.2 = load i32, i32* %X ; Read X ret i32 %X.2 }  现在，我们可以按下面的方式处理任意变量而无需插入任何 phi 节点了：\n 对每一个变量都分配一份栈空间 对变量的每一次读取都使用一次 load 指令 对变量的每一次赋值都使用一次 store 指令 要取变量的地址，只需要直接使用栈对象的地址就可以了 (也就是直接使用存放栈空间指针的那个寄存器变量)  刚解决了不可变性的问题，现在我们又有了新的问题：即使是对于非常简单且常见的操作，我们也引入了过多的对栈空间的访问，这将导致极大的性能问题。幸运的是，LLVM 优化器有一个非常好用的优化过程，\u0026ldquo;mem2reg\u0026rdquo;, 来帮助我们解决这个问题。这个优化过程可以将对内存空间的访问转化为对寄存器变量的使用，并且在合适的地方插入 phi 节点。如果你对上面的例子使用这个优化过程，你将得到：\n$ llvm-as \u0026lt; example.ll | opt -mem2reg | llvm-dis @G = weak global i32 0 @H = weak global i32 0 define i32 @test(i1 %Condition) { entry: br i1 %Condition, label %cond_true, label %cond_false cond_true: %X.0 = load i32, i32* @G br label %cond_next cond_false: %X.1 = load i32, i32* @H br label %cond_next cond_next: %X.01 = phi i32 [ %X.1, %cond_false ], [ %X.0, %cond_true ] ret i32 %X.01 }  mem2reg 过程实现了用于构造 SSA 的标准 \u0026ldquo;迭代式支配边界\u0026rdquo;(iterated dominance frontier) 算法，同时针对一系列常见的 \u0026ldquo;前端偷懒\u0026rdquo; 情况 (比如仅仅是因为懒得放 phi 节点而使用内存) 做了针对性的优化。mem2reg 可谓是在语言中实现变量的标准方式，前端应该总是使用 mem2reg. 值得注意的是，mem2reg 只优化特定情况下的内存使用：\n 它只优化由 alloca 分配的内存，所以它并不会优化到全局变量或者是在堆上的内存对象。 它只优化在函数的 entry 块分配的内存。在起始块的 alloca 指令只会执行一次，这简化了分析。 它只优化那些仅被 load/store 指令使用的内存。如果你将内存的地址传递给别的函数或是将指针偏移，那么 mem2reg 就不会优化这个 alloca. 它只优化包含第一类值(像是指针，标量或者向量) 或是长度为 1 的数组的内存。mem2reg 并不能将对内存中结构体或者是数组的访问优化为对 (多个) 寄存器的访问，但另一个优化过程 \u0026ldquo;sroa\u0026rdquo; 可以做到这一点 \u0026ndash; 它甚至还能优化对联合体 (union) 的访问等更多情况。  对大部分的命令式语言而言，在将简单的变量使用转化为内存访问时，上面的情况都很少发生 \u0026ndash; 我们将通过 Kaleidoscope 证明这一点。最后，你可能会觉得这样做太麻烦了，为什么不干脆直接在前端写写算法，构造好 SSA Form 呢？原因有三：\n mem2reg 有良好的测试，并且已经在 clang 中证明了自己: clang 同样使用 mem2reg 来实现变量，假如 mem2reg 出现了 bug，那么它很快就会被 clang 的大量用户发现，进而被开发者修复。 mem2reg 跑得飞快：它能快速地处理一般情况，同时也对大量的特殊情况做了特别优化：它能检测到只在一个基本块内被使用的变量或是只被赋值了一次的变量，同时还使用了启发式方法来避免插入无用的 phi 节点; 而这只是 mem2reg 优化的一小部分。 mem2reg 能生成调试信息：在 LLVM 中，我们需要先暴露变量的地址，随后才能为该地址附加调试信息. 而使用 mem2reg 可以非常自然地与 LLVM 生成调试信息的技术相嵌合。  不出意外的话，mem2reg 能极大地简化前端设计与实现。现在，让我们开始为 Kaleidoscope 加入变量吧！\n7.4 Kaleidoscope 中的变量 解决了理论问题之后，我们现在来决定 Kaleidoscope 里的变量写法。我们主要加入两个特性：\n 以 = 运算符修改变量 定义新变量  尽管只有第一项特性能体现出变量之\u0026quot;变\u0026quot;, 但鉴于 Kaleidoscope 现在只能通过函数形参引入变量，所以我们还得添上第二项特性。事实上定义新变量是非常有用的，就算是不可变的变量也能极大提升程序的可读性。语法上，我们的程序将类似下面这样：\n# Define ':' for sequencing: as a low-precedence operator that ignores operands # and just returns the RHS. def binary : 1 (x y) y; # Recursive fib, we could do this before. def fib(x) if (x \u0026lt; 3) then 1 else fib(x-1)+fib(x-2); # Iterative fib. def fibi(x) var a = 1, b = 1, c in (for i = 3, i \u0026lt; x in c = a + b : a = b : b = c) : b; # Call it. fibi(10);  为了修改变量，我们首先需要为变量生成使用 alloca 的中间代码，随后加入新的运算符，最后再来为 Kaleidoscope 加入变量定义语法。\n7.5 修改之前的变量实现 Kaleidoscope 的符号表之前是在中间代码生成阶段使用 \u0026lsquo;NamedValues\u0026rsquo; map 维护的。该 map 以 LLVM 的 Value* 的形式保存每一个名字对应的 double 值。为了使之可变，我们现在改其为存放名字对应的内存地址。实际上这是一种重构，(就本身而言) 其不改变编译器的行为，只是修改了编译器的实现。\n目前 Kaleidoscope 只支持两种形式的变量定义：函数形参与 for 循环循环变量。为了看起来整齐，我们会让它们也变得可变。这意味着它们的使用也需要改为对内存的读写。\n首先，我们将 NamedValues 中的 Value* 修改为 AllocaInst*. 改完后，C++ 编译器就会开始向我们抱怨哪里需要更新了：\nstatic std::map\u0026lt;std::string, AllocaInst*\u0026gt; NamedValues;  同时，我们创建一个函数来帮助我们在函数的起始块 (entry block) 插入 alloca 指令。\n/// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of /// the function. This is used for mutable variables etc. static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction, const std::string \u0026amp;VarName) { IRBuilder\u0026lt;\u0026gt; TmpB(\u0026amp;TheFunction-\u0026gt;getEntryBlock(), TheFunction-\u0026gt;getEntryBlock().begin()); return TmpB.CreateAlloca(Type::getDoubleTy(TheContext), 0, VarName.c_str()); }  上面的代码首先创建了一个插入位置为起始块第一条指令 (.begin()) 的 IRBuilder，随后以 VarName 为名字插入 alloca 指令并返回其结果。由于 Kaleidoscope 里所有变量的类型都是 double，所以我们并不需要传入变量的类型。\n基于上面的函数，我们首先来更改变量求值的代码。现在变量在栈空间中，所以求值变量就需要一次 load:\nValue *VariableExprAST::codegen() { // Look this variable up in the function. // 根据名字找到函数中的变量 (其为一指针) Value *V = NamedValues[Name]; if (!V) return LogErrorV(\u0026quot;Unknown variable name\u0026quot;); // Load the value. // 使用 load 指令获取其值 return Builder.CreateLoad(V, Name.c_str()); }  上面的代码相当直观。随后我们需要修改变量定义的实现，在定义时插入 alloca 指令。首先修改 ForExprAST::codegen() (完整代码参见后文):\nFunction *TheFunction = Builder.GetInsertBlock()-\u0026gt;getParent(); // Create an alloca for the variable in the entry block. // 为变量在起始块插入一条 alloca 指令 AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); // Emit the start code first, without 'variable' in scope. // 首先在循环变量不在作用域内的情况下生成初始值 Value *StartVal = Start-\u0026gt;codegen(); if (!StartVal) return nullptr; // Store the value into the alloca. // 将该初始值存入分配出的内存空间中 Builder.CreateStore(StartVal, Alloca); ... // Compute the end condition. // 求值循环终止条件 Value *EndCond = End-\u0026gt;codegen(); if (!EndCond) return nullptr; // Reload, increment, and restore the alloca. This handles the case where // the body of the loop mutates the variable. // 重新读取循环变量的值，加一，然后写入回去。 // 不使用之前循环变量的值是为了防止循环体内修改了循环变量的情况。 Value *CurVar = Builder.CreateLoad(Alloca); Value *NextVar = Builder.CreateFAdd(CurVar, StepVal, \u0026quot;nextvar\u0026quot;); Builder.CreateStore(NextVar, Alloca); ...  代码做的事跟之前是一样的，除了我们现在使用 load/store 而不是手动构造 phi 节点来更新它的值。\n为了让函数形参可变，我们也需要为它们生成 alloca 指令：\n 译者注：此处原文多用 argument，但综合上下文意思，其实际应指函数形参 (parameter), 故译文全部使用\u0026quot;形参\u0026quot;.\n Function *FunctionAST::codegen() { ... Builder.SetInsertPoint(BB); // Record the function arguments in the NamedValues map. NamedValues.clear(); for (auto \u0026amp;Arg : TheFunction-\u0026gt;args()) { // Create an alloca for this variable. // 为每个变量生成一条 alloca 指令 AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName()); // Store the initial value into the alloca. // 将其初始值存入内存中 Builder.CreateStore(\u0026amp;Arg, Alloca); // Add arguments to variable symbol table. // 将参数加入符号表中 NamedValues[Arg.getName()] = Alloca; } if (Value *RetVal = Body-\u0026gt;codegen()) { ...  对于每一个形参，我们插入一条 alloca 指令，然后将实参值存入刚刚分配出的内存对象中，然后将形参变量 (的地址) 加入符号表; 这个过程将在函数的起始块被插入之后发生。\n最后我们还需要在优化过程中加入 mem2reg 以生成优秀的中间代码：\n// Promote allocas to registers. TheFPM-\u0026gt;add(createPromoteMemoryToRegisterPass()); // Do simple \u0026quot;peephole\u0026quot; optimizations and bit-twiddling optzns. TheFPM-\u0026gt;add(createInstructionCombiningPass()); // Reassociate expressions. TheFPM-\u0026gt;add(createReassociatePass()); ...  让我们来比较一下被 mem2reg 优化前后的代码吧。对于先前的递归斐波那契函数而言，优化前的代码是这样的：\ndefine double @fib(double %x) { entry: %x1 = alloca double store double %x, double* %x1 %x2 = load double, double* %x1 %cmptmp = fcmp ult double %x2, 3.000000e+00 %booltmp = uitofp i1 %cmptmp to double %ifcond = fcmp one double %booltmp, 0.000000e+00 br i1 %ifcond, label %then, label %else then: ; preds = %entry br label %ifcont else: ; preds = %entry %x3 = load double, double* %x1 %subtmp = fsub double %x3, 1.000000e+00 %calltmp = call double @fib(double %subtmp) %x4 = load double, double* %x1 %subtmp5 = fsub double %x4, 2.000000e+00 %calltmp6 = call double @fib(double %subtmp5) %addtmp = fadd double %calltmp, %calltmp6 br label %ifcont ifcont: ; preds = %else, %then %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ] ret double %iftmp }  尽管代码非常简单，只有一个变量 (参数x), 但它还是很好地说明我们实现变量的方法。在起始块，我们为 x 生成了一条 alloca 指令并放入初始值; 函数内每一个对它的引用都被转换成了对栈空间的访问。作为对比，我们没有改写 if/then/else 表达式的代码生成方式 \u0026ndash; 事实上，手动插入 phi 节点来实现它反而更加简单。\nmem2reg 执行完毕后，代码变成了这样：\ndefine double @fib(double %x) { entry: %cmptmp = fcmp ult double %x, 3.000000e+00 %booltmp = uitofp i1 %cmptmp to double %ifcond = fcmp one double %booltmp, 0.000000e+00 br i1 %ifcond, label %then, label %else then: br label %ifcont else: %subtmp = fsub double %x, 1.000000e+00 %calltmp = call double @fib(double %subtmp) %subtmp5 = fsub double %x, 2.000000e+00 %calltmp6 = call double @fib(double %subtmp5) %addtmp = fadd double %calltmp, %calltmp6 br label %ifcont ifcont: ; preds = %else, %then %iftmp = phi double [ 1.000000e+00, %then ], [ %addtmp, %else ] ret double %iftmp }  对 mem2reg 来说，这不过是一种平凡情况 \u0026ndash; x 根本没有被重新定义。这个例子只是为了缓解你在生成了 \u0026ldquo;低效\u0026rdquo; 代码之后的紧张感而已，放轻松:)！\n执行完剩余的优化后，我们得到：\ndefine double @fib(double %x) { entry: %cmptmp = fcmp ult double %x, 3.000000e+00 %booltmp = uitofp i1 %cmptmp to double %ifcond = fcmp ueq double %booltmp, 0.000000e+00 br i1 %ifcond, label %else, label %ifcont else: %subtmp = fsub double %x, 1.000000e+00 %calltmp = call double @fib(double %subtmp) %subtmp5 = fsub double %x, 2.000000e+00 %calltmp6 = call double @fib(double %subtmp5) %addtmp = fadd double %calltmp, %calltmp6 ret double %addtmp ifcont: ret double 1.000000e+00 }  simplifycfg 优化过程选择将返回指令复制一份插入到 else 块中，这将消除一些跳转与 phi 指令。\n本小节我们修改了符号表实现，令其储存栈变量 (地址) 而非值。现在是时候来实现赋值运算符了。\n7.6 崭新的赋值运算符 凭我们现在的代码，加入新的赋值运算符非常简单，可以像解析普通二元运算符一样解析它。尽管如此，我们还是选择将其实现为内置运算符以方便后续的代码生成。第一步是为其设置优先级：\nint main() { // Install standard binary operators. // 1 is lowest precedence. BinopPrecedence['='] = 2; BinopPrecedence['\u0026lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20;  随后我们便可以直接来为赋值运算符生成中间代码了：\nValue *BinaryExprAST::codegen() { // Special case '=' because we don't want to emit the LHS as an expression. // 作为特殊情况处理：我们不想求值左边的 \u0026quot;表达式\u0026quot; if (Op == '=') { // Assignment requires the LHS to be an identifier. // 左表达式必须是一个标识符以充当变量名 VariableExprAST *LHSE = dynamic_cast\u0026lt;VariableExprAST*\u0026gt;(LHS.get()); if (!LHSE) return LogErrorV(\u0026quot;destination of '=' must be a variable\u0026quot;);  赋值运算符的求值并不像普通的二元运算符，后者先求值左边，再求值右边，然后计算。所以我们将其列为特殊情况优先处理。其另一个不同之处在于左 \u0026ldquo;表达式\u0026rdquo; 并不能是任意的表达式 \u0026ndash; (x+1) = expr 是不合法的，我们只允许形如 x = expr 的表达式。\n// Codegen the RHS. // 求值右表达式 Value *Val = RHS-\u0026gt;codegen(); if (!Val) return nullptr; // Look up the name. // 查找名字是否存在 Value *Variable = NamedValues[LHSE-\u0026gt;getName()]; if (!Variable) return LogErrorV(\u0026quot;Unknown variable name\u0026quot;); Builder.CreateStore(Val, Variable); return Val; } ...  一旦找到名字对应的变量，中间代码的生成就很简单了：先求值右表达式，然后将其存入内存，最后返回其值。最后返回赋予的值是为了支持形如 X = (Y = Z) 的链式赋值。\n有了赋值运算符，我们就可以修改循环变量和参数了。比如说，我们可以写出下面的代码：\n# Function to print a double. extern printd(x); # Define ':' for sequencing: as a low-precedence operator that ignores operands # and just returns the RHS. def binary : 1 (x y) y; def test(x) printd(x) : x = 4 : printd(x); test(123);  上面的代码先输出 \u0026ldquo;123\u0026rdquo;, 然后输出 \u0026ldquo;4\u0026rdquo; \u0026ndash; 我们现在可以修改变量的值了！本章的主要目标业已完成，接下来我们将支持局部变量的定义，这将令 \u0026ldquo;变量\u0026rdquo; 这个特性变得更加实用。\n7.7 自定义局部变量 支持 var/in 表达式就像我们之前支持其他表达式一样：先修改 lexer，然后是 parser，接着 AST，最后为其生成代码。我们首先来修改 lexer，代码很平凡，没什么好解释的了：\nenum Token { ... // var definition tok_var = -13 ... } ... static int gettok() { ... if (IdentifierStr == \u0026quot;in\u0026quot;) return tok_in; if (IdentifierStr == \u0026quot;binary\u0026quot;) return tok_binary; if (IdentifierStr == \u0026quot;unary\u0026quot;) return tok_unary; if (IdentifierStr == \u0026quot;var\u0026quot;) return tok_var; return tok_identifier; ...  接下来为其定义新的 AST 节点：\n/// VarExprAST - Expression class for var/in class VarExprAST : public ExprAST { std::vector\u0026lt;std::pair\u0026lt;std::string, std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt;\u0026gt; VarNames; std::unique_ptr\u0026lt;ExprAST\u0026gt; Body; public: VarExprAST(std::vector\u0026lt;std::pair\u0026lt;std::string, std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt;\u0026gt; VarNames, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : VarNames(std::move(VarNames)), Body(std::move(Body)) {} Value *codegen() override; };  我们希望能一口气定义一串变量，并且它们分别有可选的初始值，随后在 var/in 表达式的 body 部分便可使用被定义的变量。在代码中，我们使用一个 vector VarNames 来储存它们。\nAST 写好后，我们就可以来改 parser 了。修改主表达式的解析函数如下：\n/// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr /// ::= ifexpr /// ::= forexpr /// ::= varexpr static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParsePrimary() { switch (CurTok) { default: return LogError(\u0026quot;unknown token when expecting an expression\u0026quot;); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); case tok_var: return ParseVarExpr(); } }  随后是解析 VarExpr 的函数 ParseVarExpr:\n/// varexpr ::= 'var' identifier ('=' expression)? // (',' identifier ('=' expression)?)* 'in' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseVarExpr() { getNextToken(); // eat the var. std::vector\u0026lt;std::pair\u0026lt;std::string, std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt;\u0026gt; VarNames; // At least one variable name is required. // 至少需要一个变量名 if (CurTok != tok_identifier) return LogError(\u0026quot;expected identifier after var\u0026quot;);  首先，我们先解析标识符/表达式对并将其信息存入 VarNames 中。\nwhile (1) { std::string Name = IdentifierStr; getNextToken(); // eat identifier. // Read the optional initializer. // 读取可选的初始值 std::unique_ptr\u0026lt;ExprAST\u0026gt; Init; if (CurTok == '=') { getNextToken(); // eat the '='. Init = ParseExpression(); if (!Init) return nullptr; } VarNames.push_back(std::make_pair(Name, std::move(Init))); // End of var list, exit loop. // 变量定义列表结束了，退出循环 if (CurTok != ',') break; getNextToken(); // eat the ','. if (CurTok != tok_identifier) return LogError(\u0026quot;expected identifier list after var\u0026quot;); }  解析完变量定义之后，我们来解析函数体并构建 AST 节点：\n// At this point, we have to have 'in'. // 现在这里应该是一个 in if (CurTok != tok_in) return LogError(\u0026quot;expected 'in' keyword after 'var'\u0026quot;); getNextToken(); // eat 'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return std::make_unique\u0026lt;VarExprAST\u0026gt;(std::move(VarNames), std::move(Body)); }  解析并用 AST 表示出代码之后，我们来为其生成 LLVM IR. 首先是：\nValue *VarExprAST::codegen() { std::vector\u0026lt;AllocaInst *\u0026gt; OldBindings; Function *TheFunction = Builder.GetInsertBlock()-\u0026gt;getParent(); // Register all variables and emit their initializer. // 为所有变量注册并求值其初始值 for (unsigned i = 0, e = VarNames.size(); i != e; ++i) { const std::string \u0026amp;VarName = VarNames[i].first; ExprAST *Init = VarNames[i].second.get();  上面的循环遍历所有定义的变量，将其一个个加入变量表中，同时将先前同名变量的值保存于表 OldBindings 中。\n// Emit the initializer before adding the variable to scope, this prevents // the initializer from referencing the variable itself, and permits stuff // like this: // 我们在变量加入作用域之前便求值初始值表达式。这样会阻止初始值表达式中对该变量的引用， // 但仍允许对已存在的同名外层变量的引用，比如： // var a = 1 in // var a = a in ... # refers to outer 'a'. Value *InitVal; if (Init) { InitVal = Init-\u0026gt;codegen(); if (!InitVal) return nullptr; } else { // If not specified, use 0.0. InitVal = ConstantFP::get(TheContext, APFloat(0.0)); } AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); Builder.CreateStore(InitVal, Alloca); // Remember the old variable binding so that we can restore the binding when // we unrecurse. OldBindings.push_back(NamedValues[VarName]); // Remember this binding. NamedValues[VarName] = Alloca; }  除了注释里提到的问题之外，我们做的主要就是求值初始值表达式，生成 alloca 指令，然后更新符号表使名字被绑定到对应的栈变量上。完成后，我们就可以求值 body 部分了：\n// Codegen the body, now that all vars are in scope. // 现在所有的新变量都在作用域内，可以开始为 body 生成中间代码了 Value *BodyVal = Body-\u0026gt;codegen(); if (!BodyVal) return nullptr;  最后，在返回之前，我们将之前被遮盖的同名外层变量的绑定恢复：\n// Pop all our variables from scope. // 将新定义的变量全都从作用域中删去 for (unsigned i = 0, e = VarNames.size(); i != e; ++i) NamedValues[VarNames[i].first] = OldBindings[i]; // Return the body computation. // 返回函数体求出的值 return BodyVal; }  到这里，我们实现了带作用域的局部变量定义，并且变量 (显然地) 都是可变的 :). 终于，我们完成了本章开头设下的目标。我们举例用的迭代式斐波那契计算函数也在新实现下良好地运行; mem2reg 优化过程将我们所有的栈变量都优化为 SSA 寄存器变量; phi 节点被按需插入，而我们的前端实现依旧简洁 \u0026ndash; 没有什么 \u0026ldquo;迭代式支配边界计算\u0026rdquo; 给彻底整乱。\n7.8 完整代码 这里是本章例子的完整代码，具备完全的变量与 var/in 支持。使用下面的命令构建这个例子：\n# Compile clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy # Run ./toy  完整代码如下：\n#include \u0026quot;../include/KaleidoscopeJIT.h\u0026quot; #include \u0026quot;llvm/ADT/APFloat.h\u0026quot; #include \u0026quot;llvm/ADT/STLExtras.h\u0026quot; #include \u0026quot;llvm/IR/BasicBlock.h\u0026quot; #include \u0026quot;llvm/IR/Constants.h\u0026quot; #include \u0026quot;llvm/IR/DerivedTypes.h\u0026quot; #include \u0026quot;llvm/IR/Function.h\u0026quot; #include \u0026quot;llvm/IR/IRBuilder.h\u0026quot; #include \u0026quot;llvm/IR/Instructions.h\u0026quot; #include \u0026quot;llvm/IR/LLVMContext.h\u0026quot; #include \u0026quot;llvm/IR/LegacyPassManager.h\u0026quot; #include \u0026quot;llvm/IR/Module.h\u0026quot; #include \u0026quot;llvm/IR/Type.h\u0026quot; #include \u0026quot;llvm/IR/Verifier.h\u0026quot; #include \u0026quot;llvm/Support/TargetSelect.h\u0026quot; #include \u0026quot;llvm/Target/TargetMachine.h\u0026quot; #include \u0026quot;llvm/Transforms/InstCombine/InstCombine.h\u0026quot; #include \u0026quot;llvm/Transforms/Scalar.h\u0026quot; #include \u0026quot;llvm/Transforms/Scalar/GVN.h\u0026quot; #include \u0026quot;llvm/Transforms/Utils.h\u0026quot; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; using namespace llvm; using namespace llvm::orc; //===----------------------------------------------------------------------===// // Lexer //===----------------------------------------------------------------------===// // The lexer returns tokens [0-255] if it is an unknown character, otherwise one // of these for known things. enum Token { tok_eof = -1, // commands tok_def = -2, tok_extern = -3, // primary tok_identifier = -4, tok_number = -5, // control tok_if = -6, tok_then = -7, tok_else = -8, tok_for = -9, tok_in = -10, // operators tok_binary = -11, tok_unary = -12, // var definition tok_var = -13 }; static std::string IdentifierStr; // Filled in if tok_identifier static double NumVal; // Filled in if tok_number /// gettok - Return the next token from standard input. static int gettok() { static int LastChar = ' '; // Skip any whitespace. while (isspace(LastChar)) LastChar = getchar(); if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == \u0026quot;def\u0026quot;) return tok_def; if (IdentifierStr == \u0026quot;extern\u0026quot;) return tok_extern; if (IdentifierStr == \u0026quot;if\u0026quot;) return tok_if; if (IdentifierStr == \u0026quot;then\u0026quot;) return tok_then; if (IdentifierStr == \u0026quot;else\u0026quot;) return tok_else; if (IdentifierStr == \u0026quot;for\u0026quot;) return tok_for; if (IdentifierStr == \u0026quot;in\u0026quot;) return tok_in; if (IdentifierStr == \u0026quot;binary\u0026quot;) return tok_binary; if (IdentifierStr == \u0026quot;unary\u0026quot;) return tok_unary; if (IdentifierStr == \u0026quot;var\u0026quot;) return tok_var; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), nullptr); return tok_number; } if (LastChar == '#') { // Comment until end of line. do LastChar = getchar(); while (LastChar != EOF \u0026amp;\u0026amp; LastChar != '\\n' \u0026amp;\u0026amp; LastChar != '\\r'); if (LastChar != EOF) return gettok(); } // Check for end of file. Don't eat the EOF. if (LastChar == EOF) return tok_eof; // Otherwise, just return the character as its ascii value. int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// // Abstract Syntax Tree (aka Parse Tree) //===----------------------------------------------------------------------===// namespace { /// ExprAST - Base class for all expression nodes. class ExprAST { public: virtual ~ExprAST() = default; virtual Value *codegen() = 0; }; /// NumberExprAST - Expression class for numeric literals like \u0026quot;1.0\u0026quot;. class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double Val) : Val(Val) {} Value *codegen() override; }; /// VariableExprAST - Expression class for referencing a variable, like \u0026quot;a\u0026quot;. class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string \u0026amp;Name) : Name(Name) {} Value *codegen() override; const std::string \u0026amp;getName() const { return Name; } }; /// UnaryExprAST - Expression class for a unary operator. class UnaryExprAST : public ExprAST { char Opcode; std::unique_ptr\u0026lt;ExprAST\u0026gt; Operand; public: UnaryExprAST(char Opcode, std::unique_ptr\u0026lt;ExprAST\u0026gt; Operand) : Opcode(Opcode), Operand(std::move(Operand)) {} Value *codegen() override; }; /// BinaryExprAST - Expression class for a binary operator. class BinaryExprAST : public ExprAST { char Op; std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS, RHS; public: BinaryExprAST(char Op, std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS, std::unique_ptr\u0026lt;ExprAST\u0026gt; RHS) : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {} Value *codegen() override; }; /// CallExprAST - Expression class for function calls. class CallExprAST : public ExprAST { std::string Callee; std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args; public: CallExprAST(const std::string \u0026amp;Callee, std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args) : Callee(Callee), Args(std::move(Args)) {} Value *codegen() override; }; /// IfExprAST - Expression class for if/then/else. class IfExprAST : public ExprAST { std::unique_ptr\u0026lt;ExprAST\u0026gt; Cond, Then, Else; public: IfExprAST(std::unique_ptr\u0026lt;ExprAST\u0026gt; Cond, std::unique_ptr\u0026lt;ExprAST\u0026gt; Then, std::unique_ptr\u0026lt;ExprAST\u0026gt; Else) : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {} Value *codegen() override; }; /// ForExprAST - Expression class for for/in. class ForExprAST : public ExprAST { std::string VarName; std::unique_ptr\u0026lt;ExprAST\u0026gt; Start, End, Step, Body; public: ForExprAST(const std::string \u0026amp;VarName, std::unique_ptr\u0026lt;ExprAST\u0026gt; Start, std::unique_ptr\u0026lt;ExprAST\u0026gt; End, std::unique_ptr\u0026lt;ExprAST\u0026gt; Step, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : VarName(VarName), Start(std::move(Start)), End(std::move(End)), Step(std::move(Step)), Body(std::move(Body)) {} Value *codegen() override; }; /// VarExprAST - Expression class for var/in class VarExprAST : public ExprAST { std::vector\u0026lt;std::pair\u0026lt;std::string, std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt;\u0026gt; VarNames; std::unique_ptr\u0026lt;ExprAST\u0026gt; Body; public: VarExprAST( std::vector\u0026lt;std::pair\u0026lt;std::string, std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt;\u0026gt; VarNames, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : VarNames(std::move(VarNames)), Body(std::move(Body)) {} Value *codegen() override; }; /// PrototypeAST - This class represents the \u0026quot;prototype\u0026quot; for a function, /// which captures its name, and its argument names (thus implicitly the number /// of arguments the function takes), as well as if it is an operator. class PrototypeAST { std::string Name; std::vector\u0026lt;std::string\u0026gt; Args; bool IsOperator; unsigned Precedence; // Precedence if a binary op. public: PrototypeAST(const std::string \u0026amp;Name, std::vector\u0026lt;std::string\u0026gt; Args, bool IsOperator = false, unsigned Prec = 0) : Name(Name), Args(std::move(Args)), IsOperator(IsOperator), Precedence(Prec) {} Function *codegen(); const std::string \u0026amp;getName() const { return Name; } bool isUnaryOp() const { return IsOperator \u0026amp;\u0026amp; Args.size() == 1; } bool isBinaryOp() const { return IsOperator \u0026amp;\u0026amp; Args.size() == 2; } char getOperatorName() const { assert(isUnaryOp() || isBinaryOp()); return Name[Name.size() - 1]; } unsigned getBinaryPrecedence() const { return Precedence; } }; /// FunctionAST - This class represents a function definition itself. class FunctionAST { std::unique_ptr\u0026lt;PrototypeAST\u0026gt; Proto; std::unique_ptr\u0026lt;ExprAST\u0026gt; Body; public: FunctionAST(std::unique_ptr\u0026lt;PrototypeAST\u0026gt; Proto, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : Proto(std::move(Proto)), Body(std::move(Body)) {} Function *codegen(); }; } // end anonymous namespace //===----------------------------------------------------------------------===// // Parser //===----------------------------------------------------------------------===// /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current /// token the parser is looking at. getNextToken reads another token from the /// lexer and updates CurTok with its results. static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence - This holds the precedence for each binary operator that is /// defined. static std::map\u0026lt;char, int\u0026gt; BinopPrecedence; /// GetTokPrecedence - Get the precedence of the pending binary operator token. static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // Make sure it's a declared binop. int TokPrec = BinopPrecedence[CurTok]; if (TokPrec \u0026lt;= 0) return -1; return TokPrec; } /// LogError* - These are little helper functions for error handling. std::unique_ptr\u0026lt;ExprAST\u0026gt; LogError(const char *Str) { fprintf(stderr, \u0026quot;Error: %s\\n\u0026quot;, Str); return nullptr; } std::unique_ptr\u0026lt;PrototypeAST\u0026gt; LogErrorP(const char *Str) { LogError(Str); return nullptr; } static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseExpression(); /// numberexpr ::= number static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseNumberExpr() { auto Result = std::make_unique\u0026lt;NumberExprAST\u0026gt;(NumVal); getNextToken(); // consume the number return std::move(Result); } /// parenexpr ::= '(' expression ')' static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseParenExpr() { getNextToken(); // eat (. auto V = ParseExpression(); if (!V) return nullptr; if (CurTok != ')') return LogError(\u0026quot;expected ')'\u0026quot;); getNextToken(); // eat ). return V; } /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref. return std::make_unique\u0026lt;VariableExprAST\u0026gt;(IdName); // Call. getNextToken(); // eat ( std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args; if (CurTok != ')') { while (true) { if (auto Arg = ParseExpression()) Args.push_back(std::move(Arg)); else return nullptr; if (CurTok == ')') break; if (CurTok != ',') return LogError(\u0026quot;Expected ')' or ',' in argument list\u0026quot;); getNextToken(); } } // Eat the ')'. getNextToken(); return std::make_unique\u0026lt;CallExprAST\u0026gt;(IdName, std::move(Args)); } /// ifexpr ::= 'if' expression 'then' expression 'else' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseIfExpr() { getNextToken(); // eat the if. // condition. auto Cond = ParseExpression(); if (!Cond) return nullptr; if (CurTok != tok_then) return LogError(\u0026quot;expected then\u0026quot;); getNextToken(); // eat the then auto Then = ParseExpression(); if (!Then) return nullptr; if (CurTok != tok_else) return LogError(\u0026quot;expected else\u0026quot;); getNextToken(); auto Else = ParseExpression(); if (!Else) return nullptr; return std::make_unique\u0026lt;IfExprAST\u0026gt;(std::move(Cond), std::move(Then), std::move(Else)); } /// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseForExpr() { getNextToken(); // eat the for. if (CurTok != tok_identifier) return LogError(\u0026quot;expected identifier after for\u0026quot;); std::string IdName = IdentifierStr; getNextToken(); // eat identifier. if (CurTok != '=') return LogError(\u0026quot;expected '=' after for\u0026quot;); getNextToken(); // eat '='. auto Start = ParseExpression(); if (!Start) return nullptr; if (CurTok != ',') return LogError(\u0026quot;expected ',' after for start value\u0026quot;); getNextToken(); auto End = ParseExpression(); if (!End) return nullptr; // The step value is optional. std::unique_ptr\u0026lt;ExprAST\u0026gt; Step; if (CurTok == ',') { getNextToken(); Step = ParseExpression(); if (!Step) return nullptr; } if (CurTok != tok_in) return LogError(\u0026quot;expected 'in' after for\u0026quot;); getNextToken(); // eat 'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return std::make_unique\u0026lt;ForExprAST\u0026gt;(IdName, std::move(Start), std::move(End), std::move(Step), std::move(Body)); } /// varexpr ::= 'var' identifier ('=' expression)? // (',' identifier ('=' expression)?)* 'in' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseVarExpr() { getNextToken(); // eat the var. std::vector\u0026lt;std::pair\u0026lt;std::string, std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt;\u0026gt; VarNames; // At least one variable name is required. if (CurTok != tok_identifier) return LogError(\u0026quot;expected identifier after var\u0026quot;); while (true) { std::string Name = IdentifierStr; getNextToken(); // eat identifier. // Read the optional initializer. std::unique_ptr\u0026lt;ExprAST\u0026gt; Init = nullptr; if (CurTok == '=') { getNextToken(); // eat the '='. Init = ParseExpression(); if (!Init) return nullptr; } VarNames.push_back(std::make_pair(Name, std::move(Init))); // End of var list, exit loop. if (CurTok != ',') break; getNextToken(); // eat the ','. if (CurTok != tok_identifier) return LogError(\u0026quot;expected identifier list after var\u0026quot;); } // At this point, we have to have 'in'. if (CurTok != tok_in) return LogError(\u0026quot;expected 'in' keyword after 'var'\u0026quot;); getNextToken(); // eat 'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return std::make_unique\u0026lt;VarExprAST\u0026gt;(std::move(VarNames), std::move(Body)); } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr /// ::= ifexpr /// ::= forexpr /// ::= varexpr static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParsePrimary() { switch (CurTok) { default: return LogError(\u0026quot;unknown token when expecting an expression\u0026quot;); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); case tok_var: return ParseVarExpr(); } } /// unary /// ::= primary /// ::= '!' unary static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseUnary() { // If the current token is not an operator, it must be a primary expr. if (!isascii(CurTok) || CurTok == '(' || CurTok == ',') return ParsePrimary(); // If this is a unary operator, read it. int Opc = CurTok; getNextToken(); if (auto Operand = ParseUnary()) return std::make_unique\u0026lt;UnaryExprAST\u0026gt;(Opc, std::move(Operand)); return nullptr; } /// binoprhs /// ::= ('+' unary)* static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseBinOpRHS(int ExprPrec, std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS) { // If this is a binop, find its precedence. while (true) { int TokPrec = GetTokPrecedence(); // If this is a binop that binds at least as tightly as the current binop, // consume it, otherwise we are done. if (TokPrec \u0026lt; ExprPrec) return LHS; // Okay, we know this is a binop. int BinOp = CurTok; getNextToken(); // eat binop // Parse the unary expression after the binary operator. auto RHS = ParseUnary(); if (!RHS) return nullptr; // If BinOp binds less tightly with RHS than the operator after RHS, let // the pending operator take RHS as its LHS. int NextPrec = GetTokPrecedence(); if (TokPrec \u0026lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS)); if (!RHS) return nullptr; } // Merge LHS/RHS. LHS = std::make_unique\u0026lt;BinaryExprAST\u0026gt;(BinOp, std::move(LHS), std::move(RHS)); } } /// expression /// ::= unary binoprhs /// static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseExpression() { auto LHS = ParseUnary(); if (!LHS) return nullptr; return ParseBinOpRHS(0, std::move(LHS)); } /// prototype /// ::= id '(' id* ')' /// ::= binary LETTER number? (id, id) /// ::= unary LETTER (id) static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParsePrototype() { std::string FnName; unsigned Kind = 0; // 0 = identifier, 1 = unary, 2 = binary. unsigned BinaryPrecedence = 30; switch (CurTok) { default: return LogErrorP(\u0026quot;Expected function name in prototype\u0026quot;); case tok_identifier: FnName = IdentifierStr; Kind = 0; getNextToken(); break; case tok_unary: getNextToken(); if (!isascii(CurTok)) return LogErrorP(\u0026quot;Expected unary operator\u0026quot;); FnName = \u0026quot;unary\u0026quot;; FnName += (char)CurTok; Kind = 1; getNextToken(); break; case tok_binary: getNextToken(); if (!isascii(CurTok)) return LogErrorP(\u0026quot;Expected binary operator\u0026quot;); FnName = \u0026quot;binary\u0026quot;; FnName += (char)CurTok; Kind = 2; getNextToken(); // Read the precedence if present. if (CurTok == tok_number) { if (NumVal \u0026lt; 1 || NumVal \u0026gt; 100) return LogErrorP(\u0026quot;Invalid precedence: must be 1..100\u0026quot;); BinaryPrecedence = (unsigned)NumVal; getNextToken(); } break; } if (CurTok != '(') return LogErrorP(\u0026quot;Expected '(' in prototype\u0026quot;); std::vector\u0026lt;std::string\u0026gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return LogErrorP(\u0026quot;Expected ')' in prototype\u0026quot;); // success. getNextToken(); // eat ')'. // Verify right number of names for operator. if (Kind \u0026amp;\u0026amp; ArgNames.size() != Kind) return LogErrorP(\u0026quot;Invalid number of operands for operator\u0026quot;); return std::make_unique\u0026lt;PrototypeAST\u0026gt;(FnName, ArgNames, Kind != 0, BinaryPrecedence); } /// definition ::= 'def' prototype expression static std::unique_ptr\u0026lt;FunctionAST\u0026gt; ParseDefinition() { getNextToken(); // eat def. auto Proto = ParsePrototype(); if (!Proto) return nullptr; if (auto E = ParseExpression()) return std::make_unique\u0026lt;FunctionAST\u0026gt;(std::move(Proto), std::move(E)); return nullptr; } /// toplevelexpr ::= expression static std::unique_ptr\u0026lt;FunctionAST\u0026gt; ParseTopLevelExpr() { if (auto E = ParseExpression()) { // Make an anonymous proto. auto Proto = std::make_unique\u0026lt;PrototypeAST\u0026gt;(\u0026quot;__anon_expr\u0026quot;, std::vector\u0026lt;std::string\u0026gt;()); return std::make_unique\u0026lt;FunctionAST\u0026gt;(std::move(Proto), std::move(E)); } return nullptr; } /// external ::= 'extern' prototype static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParseExtern() { getNextToken(); // eat extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// // Code Generation //===----------------------------------------------------------------------===// static std::unique_ptr\u0026lt;LLVMContext\u0026gt; TheContext; static std::unique_ptr\u0026lt;Module\u0026gt; TheModule; static std::unique_ptr\u0026lt;IRBuilder\u0026lt;\u0026gt;\u0026gt; Builder; static std::map\u0026lt;std::string, AllocaInst *\u0026gt; NamedValues; static std::unique_ptr\u0026lt;legacy::FunctionPassManager\u0026gt; TheFPM; static std::unique_ptr\u0026lt;KaleidoscopeJIT\u0026gt; TheJIT; static std::map\u0026lt;std::string, std::unique_ptr\u0026lt;PrototypeAST\u0026gt;\u0026gt; FunctionProtos; static ExitOnError ExitOnErr; Value *LogErrorV(const char *Str) { LogError(Str); return nullptr; } Function *getFunction(std::string Name) { // First, see if the function has already been added to the current module. if (auto *F = TheModule-\u0026gt;getFunction(Name)) return F; // If not, check whether we can codegen the declaration from some existing // prototype. auto FI = FunctionProtos.find(Name); if (FI != FunctionProtos.end()) return FI-\u0026gt;second-\u0026gt;codegen(); // If no existing prototype exists, return null. return nullptr; } /// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of /// the function. This is used for mutable variables etc. static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction, StringRef VarName) { IRBuilder\u0026lt;\u0026gt; TmpB(\u0026amp;TheFunction-\u0026gt;getEntryBlock(), TheFunction-\u0026gt;getEntryBlock().begin()); return TmpB.CreateAlloca(Type::getDoubleTy(*TheContext), nullptr, VarName); } Value *NumberExprAST::codegen() { return ConstantFP::get(*TheContext, APFloat(Val)); } Value *VariableExprAST::codegen() { // Look this variable up in the function. AllocaInst *A = NamedValues[Name]; if (!A) return LogErrorV(\u0026quot;Unknown variable name\u0026quot;); // Load the value. return Builder-\u0026gt;CreateLoad(A-\u0026gt;getAllocatedType(), A, Name.c_str()); } Value *UnaryExprAST::codegen() { Value *OperandV = Operand-\u0026gt;codegen(); if (!OperandV) return nullptr; Function *F = getFunction(std::string(\u0026quot;unary\u0026quot;) + Opcode); if (!F) return LogErrorV(\u0026quot;Unknown unary operator\u0026quot;); return Builder-\u0026gt;CreateCall(F, OperandV, \u0026quot;unop\u0026quot;); } Value *BinaryExprAST::codegen() { // Special case '=' because we don't want to emit the LHS as an expression. if (Op == '=') { // Assignment requires the LHS to be an identifier. // This assume we're building without RTTI because LLVM builds that way by // default. If you build LLVM with RTTI this can be changed to a // dynamic_cast for automatic error checking. VariableExprAST *LHSE = static_cast\u0026lt;VariableExprAST *\u0026gt;(LHS.get()); if (!LHSE) return LogErrorV(\u0026quot;destination of '=' must be a variable\u0026quot;); // Codegen the RHS. Value *Val = RHS-\u0026gt;codegen(); if (!Val) return nullptr; // Look up the name. Value *Variable = NamedValues[LHSE-\u0026gt;getName()]; if (!Variable) return LogErrorV(\u0026quot;Unknown variable name\u0026quot;); Builder-\u0026gt;CreateStore(Val, Variable); return Val; } Value *L = LHS-\u0026gt;codegen(); Value *R = RHS-\u0026gt;codegen(); if (!L || !R) return nullptr; switch (Op) { case '+': return Builder-\u0026gt;CreateFAdd(L, R, \u0026quot;addtmp\u0026quot;); case '-': return Builder-\u0026gt;CreateFSub(L, R, \u0026quot;subtmp\u0026quot;); case '*': return Builder-\u0026gt;CreateFMul(L, R, \u0026quot;multmp\u0026quot;); case '\u0026lt;': L = Builder-\u0026gt;CreateFCmpULT(L, R, \u0026quot;cmptmp\u0026quot;); // Convert bool 0/1 to double 0.0 or 1.0 return Builder-\u0026gt;CreateUIToFP(L, Type::getDoubleTy(*TheContext), \u0026quot;booltmp\u0026quot;); default: break; } // If it wasn't a builtin binary operator, it must be a user defined one. Emit // a call to it. Function *F = getFunction(std::string(\u0026quot;binary\u0026quot;) + Op); assert(F \u0026amp;\u0026amp; \u0026quot;binary operator not found!\u0026quot;); Value *Ops[] = {L, R}; return Builder-\u0026gt;CreateCall(F, Ops, \u0026quot;binop\u0026quot;); } Value *CallExprAST::codegen() { // Look up the name in the global module table. Function *CalleeF = getFunction(Callee); if (!CalleeF) return LogErrorV(\u0026quot;Unknown function referenced\u0026quot;); // If argument mismatch error. if (CalleeF-\u0026gt;arg_size() != Args.size()) return LogErrorV(\u0026quot;Incorrect # arguments passed\u0026quot;); std::vector\u0026lt;Value *\u0026gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-\u0026gt;codegen()); if (!ArgsV.back()) return nullptr; } return Builder-\u0026gt;CreateCall(CalleeF, ArgsV, \u0026quot;calltmp\u0026quot;); } Value *IfExprAST::codegen() { Value *CondV = Cond-\u0026gt;codegen(); if (!CondV) return nullptr; // Convert condition to a bool by comparing non-equal to 0.0. CondV = Builder-\u0026gt;CreateFCmpONE( CondV, ConstantFP::get(*TheContext, APFloat(0.0)), \u0026quot;ifcond\u0026quot;); Function *TheFunction = Builder-\u0026gt;GetInsertBlock()-\u0026gt;getParent(); // Create blocks for the then and else cases. Insert the 'then' block at the // end of the function. BasicBlock *ThenBB = BasicBlock::Create(*TheContext, \u0026quot;then\u0026quot;, TheFunction); BasicBlock *ElseBB = BasicBlock::Create(*TheContext, \u0026quot;else\u0026quot;); BasicBlock *MergeBB = BasicBlock::Create(*TheContext, \u0026quot;ifcont\u0026quot;); Builder-\u0026gt;CreateCondBr(CondV, ThenBB, ElseBB); // Emit then value. Builder-\u0026gt;SetInsertPoint(ThenBB); Value *ThenV = Then-\u0026gt;codegen(); if (!ThenV) return nullptr; Builder-\u0026gt;CreateBr(MergeBB); // Codegen of 'Then' can change the current block, update ThenBB for the PHI. ThenBB = Builder-\u0026gt;GetInsertBlock(); // Emit else block. TheFunction-\u0026gt;getBasicBlockList().push_back(ElseBB); Builder-\u0026gt;SetInsertPoint(ElseBB); Value *ElseV = Else-\u0026gt;codegen(); if (!ElseV) return nullptr; Builder-\u0026gt;CreateBr(MergeBB); // Codegen of 'Else' can change the current block, update ElseBB for the PHI. ElseBB = Builder-\u0026gt;GetInsertBlock(); // Emit merge block. TheFunction-\u0026gt;getBasicBlockList().push_back(MergeBB); Builder-\u0026gt;SetInsertPoint(MergeBB); PHINode *PN = Builder-\u0026gt;CreatePHI(Type::getDoubleTy(*TheContext), 2, \u0026quot;iftmp\u0026quot;); PN-\u0026gt;addIncoming(ThenV, ThenBB); PN-\u0026gt;addIncoming(ElseV, ElseBB); return PN; } // Output for-loop as: // var = alloca double // ... // start = startexpr // store start -\u0026gt; var // goto loop // loop: // ... // bodyexpr // ... // loopend: // step = stepexpr // endcond = endexpr // // curvar = load var // nextvar = curvar + step // store nextvar -\u0026gt; var // br endcond, loop, endloop // outloop: Value *ForExprAST::codegen() { Function *TheFunction = Builder-\u0026gt;GetInsertBlock()-\u0026gt;getParent(); // Create an alloca for the variable in the entry block. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); // Emit the start code first, without 'variable' in scope. Value *StartVal = Start-\u0026gt;codegen(); if (!StartVal) return nullptr; // Store the value into the alloca. Builder-\u0026gt;CreateStore(StartVal, Alloca); // Make the new basic block for the loop header, inserting after current // block. BasicBlock *LoopBB = BasicBlock::Create(*TheContext, \u0026quot;loop\u0026quot;, TheFunction); // Insert an explicit fall through from the current block to the LoopBB. Builder-\u0026gt;CreateBr(LoopBB); // Start insertion in LoopBB. Builder-\u0026gt;SetInsertPoint(LoopBB); // Within the loop, the variable is defined equal to the PHI node. If it // shadows an existing variable, we have to restore it, so save it now. AllocaInst *OldVal = NamedValues[VarName]; NamedValues[VarName] = Alloca; // Emit the body of the loop. This, like any other expr, can change the // current BB. Note that we ignore the value computed by the body, but don't // allow an error. if (!Body-\u0026gt;codegen()) return nullptr; // Emit the step value. Value *StepVal = nullptr; if (Step) { StepVal = Step-\u0026gt;codegen(); if (!StepVal) return nullptr; } else { // If not specified, use 1.0. StepVal = ConstantFP::get(*TheContext, APFloat(1.0)); } // Compute the end condition. Value *EndCond = End-\u0026gt;codegen(); if (!EndCond) return nullptr; // Reload, increment, and restore the alloca. This handles the case where // the body of the loop mutates the variable. Value *CurVar = Builder-\u0026gt;CreateLoad(Alloca-\u0026gt;getAllocatedType(), Alloca, VarName.c_str()); Value *NextVar = Builder-\u0026gt;CreateFAdd(CurVar, StepVal, \u0026quot;nextvar\u0026quot;); Builder-\u0026gt;CreateStore(NextVar, Alloca); // Convert condition to a bool by comparing non-equal to 0.0. EndCond = Builder-\u0026gt;CreateFCmpONE( EndCond, ConstantFP::get(*TheContext, APFloat(0.0)), \u0026quot;loopcond\u0026quot;); // Create the \u0026quot;after loop\u0026quot; block and insert it. BasicBlock *AfterBB = BasicBlock::Create(*TheContext, \u0026quot;afterloop\u0026quot;, TheFunction); // Insert the conditional branch into the end of LoopEndBB. Builder-\u0026gt;CreateCondBr(EndCond, LoopBB, AfterBB); // Any new code will be inserted in AfterBB. Builder-\u0026gt;SetInsertPoint(AfterBB); // Restore the unshadowed variable. if (OldVal) NamedValues[VarName] = OldVal; else NamedValues.erase(VarName); // for expr always returns 0.0. return Constant::getNullValue(Type::getDoubleTy(*TheContext)); } Value *VarExprAST::codegen() { std::vector\u0026lt;AllocaInst *\u0026gt; OldBindings; Function *TheFunction = Builder-\u0026gt;GetInsertBlock()-\u0026gt;getParent(); // Register all variables and emit their initializer. for (unsigned i = 0, e = VarNames.size(); i != e; ++i) { const std::string \u0026amp;VarName = VarNames[i].first; ExprAST *Init = VarNames[i].second.get(); // Emit the initializer before adding the variable to scope, this prevents // the initializer from referencing the variable itself, and permits stuff // like this: // var a = 1 in // var a = a in ... # refers to outer 'a'. Value *InitVal; if (Init) { InitVal = Init-\u0026gt;codegen(); if (!InitVal) return nullptr; } else { // If not specified, use 0.0. InitVal = ConstantFP::get(*TheContext, APFloat(0.0)); } AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); Builder-\u0026gt;CreateStore(InitVal, Alloca); // Remember the old variable binding so that we can restore the binding when // we unrecurse. OldBindings.push_back(NamedValues[VarName]); // Remember this binding. NamedValues[VarName] = Alloca; } // Codegen the body, now that all vars are in scope. Value *BodyVal = Body-\u0026gt;codegen(); if (!BodyVal) return nullptr; // Pop all our variables from scope. for (unsigned i = 0, e = VarNames.size(); i != e; ++i) NamedValues[VarNames[i].first] = OldBindings[i]; // Return the body computation. return BodyVal; } Function *PrototypeAST::codegen() { // Make the function type: double(double,double) etc. std::vector\u0026lt;Type *\u0026gt; Doubles(Args.size(), Type::getDoubleTy(*TheContext)); FunctionType *FT = FunctionType::get(Type::getDoubleTy(*TheContext), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get()); // Set names for all arguments. unsigned Idx = 0; for (auto \u0026amp;Arg : F-\u0026gt;args()) Arg.setName(Args[Idx++]); return F; } Function *FunctionAST::codegen() { // Transfer ownership of the prototype to the FunctionProtos map, but keep a // reference to it for use below. auto \u0026amp;P = *Proto; FunctionProtos[Proto-\u0026gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr; // If this is an operator, install it. if (P.isBinaryOp()) BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence(); // Create a new basic block to start insertion into. BasicBlock *BB = BasicBlock::Create(*TheContext, \u0026quot;entry\u0026quot;, TheFunction); Builder-\u0026gt;SetInsertPoint(BB); // Record the function arguments in the NamedValues map. NamedValues.clear(); for (auto \u0026amp;Arg : TheFunction-\u0026gt;args()) { // Create an alloca for this variable. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName()); // Store the initial value into the alloca. Builder-\u0026gt;CreateStore(\u0026amp;Arg, Alloca); // Add arguments to variable symbol table. NamedValues[std::string(Arg.getName())] = Alloca; } if (Value *RetVal = Body-\u0026gt;codegen()) { // Finish off the function. Builder-\u0026gt;CreateRet(RetVal); // Validate the generated code, checking for consistency. verifyFunction(*TheFunction); // Run the optimizer on the function. TheFPM-\u0026gt;run(*TheFunction); return TheFunction; } // Error reading body, remove function. TheFunction-\u0026gt;eraseFromParent(); if (P.isBinaryOp()) BinopPrecedence.erase(P.getOperatorName()); return nullptr; } //===----------------------------------------------------------------------===// // Top-Level parsing and JIT Driver //===----------------------------------------------------------------------===// static void InitializeModuleAndPassManager() { // Open a new module. TheContext = std::make_unique\u0026lt;LLVMContext\u0026gt;(); TheModule = std::make_unique\u0026lt;Module\u0026gt;(\u0026quot;my cool jit\u0026quot;, *TheContext); TheModule-\u0026gt;setDataLayout(TheJIT-\u0026gt;getDataLayout()); // Create a new builder for the module. Builder = std::make_unique\u0026lt;IRBuilder\u0026lt;\u0026gt;\u0026gt;(*TheContext); // Create a new pass manager attached to it. TheFPM = std::make_unique\u0026lt;legacy::FunctionPassManager\u0026gt;(TheModule.get()); // Promote allocas to registers. TheFPM-\u0026gt;add(createPromoteMemoryToRegisterPass()); // Do simple \u0026quot;peephole\u0026quot; optimizations and bit-twiddling optzns. TheFPM-\u0026gt;add(createInstructionCombiningPass()); // Reassociate expressions. TheFPM-\u0026gt;add(createReassociatePass()); // Eliminate Common SubExpressions. TheFPM-\u0026gt;add(createGVNPass()); // Simplify the control flow graph (deleting unreachable blocks, etc). TheFPM-\u0026gt;add(createCFGSimplificationPass()); TheFPM-\u0026gt;doInitialization(); } static void HandleDefinition() { if (auto FnAST = ParseDefinition()) { if (auto *FnIR = FnAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read function definition:\u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); ExitOnErr(TheJIT-\u0026gt;addModule( ThreadSafeModule(std::move(TheModule), std::move(TheContext)))); InitializeModuleAndPassManager(); } } else { // Skip token for error recovery. getNextToken(); } } static void HandleExtern() { if (auto ProtoAST = ParseExtern()) { if (auto *FnIR = ProtoAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read extern: \u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); FunctionProtos[ProtoAST-\u0026gt;getName()] = std::move(ProtoAST); } } else { // Skip token for error recovery. getNextToken(); } } static void HandleTopLevelExpression() { // Evaluate a top-level expression into an anonymous function. if (auto FnAST = ParseTopLevelExpr()) { if (FnAST-\u0026gt;codegen()) { // Create a ResourceTracker to track JIT'd memory allocated to our // anonymous expression -- that way we can free it after executing. auto RT = TheJIT-\u0026gt;getMainJITDylib().createResourceTracker(); auto TSM = ThreadSafeModule(std::move(TheModule), std::move(TheContext)); ExitOnErr(TheJIT-\u0026gt;addModule(std::move(TSM), RT)); InitializeModuleAndPassManager(); // Search the JIT for the __anon_expr symbol. auto ExprSymbol = ExitOnErr(TheJIT-\u0026gt;lookup(\u0026quot;__anon_expr\u0026quot;)); // Get the symbol's address and cast it to the right type (takes no // arguments, returns a double) so we can call it as a native function. double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress(); fprintf(stderr, \u0026quot;Evaluated to %f\\n\u0026quot;, FP()); // Delete the anonymous expression module from the JIT. ExitOnErr(RT-\u0026gt;remove()); } } else { // Skip token for error recovery. getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (true) { fprintf(stderr, \u0026quot;ready\u0026gt; \u0026quot;); switch (CurTok) { case tok_eof: return; case ';': // ignore top-level semicolons. getNextToken(); break; case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // \u0026quot;Library\u0026quot; functions that can be \u0026quot;extern'd\u0026quot; from user code. //===----------------------------------------------------------------------===// #ifdef _WIN32 #define DLLEXPORT __declspec(dllexport) #else #define DLLEXPORT #endif /// putchard - putchar that takes a double and returns 0. extern \u0026quot;C\u0026quot; DLLEXPORT double putchard(double X) { fputc((char)X, stderr); return 0; } /// printd - printf that takes a double prints it as \u0026quot;%f\\n\u0026quot;, returning 0. extern \u0026quot;C\u0026quot; DLLEXPORT double printd(double X) { fprintf(stderr, \u0026quot;%f\\n\u0026quot;, X); return 0; } //===----------------------------------------------------------------------===// // Main driver code. //===----------------------------------------------------------------------===// int main() { InitializeNativeTarget(); InitializeNativeTargetAsmPrinter(); InitializeNativeTargetAsmParser(); // Install standard binary operators. // 1 is lowest precedence. BinopPrecedence['='] = 2; BinopPrecedence['\u0026lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; // highest. // Prime the first token. fprintf(stderr, \u0026quot;ready\u0026gt; \u0026quot;); getNextToken(); TheJIT = ExitOnErr(KaleidoscopeJIT::Create()); InitializeModuleAndPassManager(); // Run the main \u0026quot;interpreter loop\u0026quot; now. MainLoop(); return 0; } ","date":"2022-01-21","permalink":"https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-7/","tags":["编译原理","编译前端","LLVM","翻译"],"title":"LLVM Kaleidoscope 第 7 章：可变量"},{"content":"8.1 前言 欢迎来到 我的第一个基于 LLVM 的语言前端 教程第八章。本章将描述如何将我们实现的语言编译到目标文件 (object file)。\n8.2 选择目标平台 LLVM 对交叉编译 (cross-compilation) 有原生支持，你既可以编译到你当前的机器架构上，也可以很轻松地编译到其他架构上。在本章，我们将为当前机器生成目标文件。\n为了指定目标平台，我们使用一种名为 \u0026ldquo;目标三元组 (target triple)\u0026rdquo; 的字符串，其形如 \u0026lt;arch\u0026gt;\u0026lt;sub\u0026gt;-\u0026lt;vendor\u0026gt;-\u0026lt;sys\u0026gt;-\u0026lt;abi\u0026gt;. (参见交叉编译的文档)\n作为示例，我们可以看看 clang 认定的当前平台的目标三元组：\n$ clang --version | grep Target Target: x86_64-unknown-linux-gnu  如果你使用不同架构的计算机或者不同的操作系统，那么上面的输出有可能会不一样。\n幸运的是，我们并不需要将当前平台的目标三元组硬编码到我们的代码里。LLVM 提供了函数 sys::getDefaultTargetTriple, 可以获得当前机器的目标三元组。\nauto TargetTriple = sys::getDefaultTargetTriple();  LLVM 并不要求我们链接上目标平台的所有功能 (target functionality)。比如说，假设我们只想运行 JIT，我们并不需要汇编输出函数 (assembly printers) 支持。同样，假如我们只关心某个特定目标架构，我们也可以只为那些架构链接功能。\n对于本章，我们将为目标代码的生成初始化所有的目标平台。\nInitializeAllTargetInfos(); InitializeAllTargets(); InitializeAllTargetMCs(); InitializeAllAsmParsers(); InitializeAllAsmPrinters();  现在我们可以通过目标三元组获得到目标平台的信息了：\nstd::string Error; auto Target = TargetRegistry::lookupTarget(TargetTriple, Error); // Print an error and exit if we couldn't find the requested target. // This generally occurs if we've forgotten to initialise the // TargetRegistry or we have a bogus target triple. // 如果找不到目标平台，那么就报错 // 当我们忘记初始化 TargetRegistry 或者传入了不合法的目标三元组的时候 // 这就会发生 if (!Target) { errs() \u0026lt;\u0026lt; Error; return 1; }  8.3 目标机器 (TargetMachine) 我们还需要创建一个 TargetMachine. 这个类提供了对目标机器完整的机器级信息描述。如果我们需要生成某个目标机器上特定的功能 (比如 SSE) 或者是对特定 CPU 生成代码 (比如对 Intel Sandylake), 那么现在就是指定这些的时候了。\n如果想知道 LLVM 支持哪些 CPU 或者是哪些特性，我们可以使用 llc 命令。比如说，对于 x86:\n$ llvm-as \u0026lt; /dev/null | llc -march=x86 -mattr=help Available CPUs for this target: amdfam10 - Select the amdfam10 processor. athlon - Select the athlon processor. athlon-4 - Select the athlon-4 processor. ... Available features for this target: 16bit-mode - 16-bit mode (i8086). 32bit-mode - 32-bit mode (80386). 3dnow - Enable 3DNow! instructions. 3dnowa - Enable 3DNow! Athlon instructions. ...  对于本章，我们将为通用的 CPU 生成代码，并且不指定任何特定功能、选项或重定位模型。\nauto CPU = \u0026quot;generic\u0026quot;; auto Features = \u0026quot;\u0026quot;; TargetOptions opt; auto RM = Optional\u0026lt;Reloc::Model\u0026gt;(); auto TargetMachine = Target-\u0026gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);  8.4 配置模块 我们现在可以开始配置我们的模块使其适应于特定的目标平台和数据布局 (data layout) 了。事实上，这一步并非必须，但前端性能指南推荐我们这样做。优化过程将受益于知道更多目标平台的信息。\nTheModule-\u0026gt;setDataLayout(TargetMachine-\u0026gt;createDataLayout()); TheModule-\u0026gt;setTargetTriple(TargetTriple);  8.5 生成的目标代码的指针并将其转换为合适的类型 终于，我们可以开始生成目标代码了。首先让我们设定输出文件：\nauto Filename = \u0026quot;output.o\u0026quot;; std::error_code EC; raw_fd_ostream dest(Filename, EC, sys::fs::OF_None); if (EC) { errs() \u0026lt;\u0026lt; \u0026quot;Could not open file: \u0026quot; \u0026lt;\u0026lt; EC.message(); return 1; }  随后，我们为生成目标文件定义一个过程 (pass), 然后运行它：\nlegacy::PassManager pass; auto FileType = CGFT_ObjectFile; if (TargetMachine-\u0026gt;addPassesToEmitFile(pass, dest, nullptr, FileType)) { errs() \u0026lt;\u0026lt; \u0026quot;TargetMachine can't emit a file of this type\u0026quot;; return 1; } pass.run(*TheModule); dest.flush();  8.6 最后组装 我们成功了吗？让我们来测试一下。首先我们编译我们的代码，注意此处 llvm-config 的参数与前几章不同：\n$ clang++ -g -O3 toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs all` -o toy  然后运行我们的程序，然后定义一个简单的 average (求平均值) 函数。输入完成后键入 Ctrl+D.\n$ ./toy ready\u0026gt; def average(x y) (x + y) * 0.5; ^D Wrote output.o  现在我们有一个目标文件了。为了测试它，我们来写一个简单的程序并将目标文件链接到其上：\n#include \u0026lt;iostream\u0026gt; extern \u0026quot;C\u0026quot; { double average(double, double); } int main() { std::cout \u0026lt;\u0026lt; \u0026quot;average of 3.0 and 4.0: \u0026quot; \u0026lt;\u0026lt; average(3.0, 4.0) \u0026lt;\u0026lt; std::endl; }  在编译并链接好程序之后，我们就可以检查输出是否符合我们的预期了：\n$ clang++ main.cpp output.o -o main $ ./main average of 3.0 and 4.0: 3.5  8.7 完整代码 #include \u0026quot;llvm/ADT/APFloat.h\u0026quot; #include \u0026quot;llvm/ADT/Optional.h\u0026quot; #include \u0026quot;llvm/ADT/STLExtras.h\u0026quot; #include \u0026quot;llvm/IR/BasicBlock.h\u0026quot; #include \u0026quot;llvm/IR/Constants.h\u0026quot; #include \u0026quot;llvm/IR/DerivedTypes.h\u0026quot; #include \u0026quot;llvm/IR/Function.h\u0026quot; #include \u0026quot;llvm/IR/IRBuilder.h\u0026quot; #include \u0026quot;llvm/IR/Instructions.h\u0026quot; #include \u0026quot;llvm/IR/LLVMContext.h\u0026quot; #include \u0026quot;llvm/IR/LegacyPassManager.h\u0026quot; #include \u0026quot;llvm/IR/Module.h\u0026quot; #include \u0026quot;llvm/IR/Type.h\u0026quot; #include \u0026quot;llvm/IR/Verifier.h\u0026quot; #include \u0026quot;llvm/MC/TargetRegistry.h\u0026quot; #include \u0026quot;llvm/Support/FileSystem.h\u0026quot; #include \u0026quot;llvm/Support/Host.h\u0026quot; #include \u0026quot;llvm/Support/TargetSelect.h\u0026quot; #include \u0026quot;llvm/Support/raw_ostream.h\u0026quot; #include \u0026quot;llvm/Target/TargetMachine.h\u0026quot; #include \u0026quot;llvm/Target/TargetOptions.h\u0026quot; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;system_error\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; using namespace llvm; using namespace llvm::sys; //===----------------------------------------------------------------------===// // Lexer //===----------------------------------------------------------------------===// // The lexer returns tokens [0-255] if it is an unknown character, otherwise one // of these for known things. enum Token { tok_eof = -1, // commands tok_def = -2, tok_extern = -3, // primary tok_identifier = -4, tok_number = -5, // control tok_if = -6, tok_then = -7, tok_else = -8, tok_for = -9, tok_in = -10, // operators tok_binary = -11, tok_unary = -12, // var definition tok_var = -13 }; static std::string IdentifierStr; // Filled in if tok_identifier static double NumVal; // Filled in if tok_number /// gettok - Return the next token from standard input. static int gettok() { static int LastChar = ' '; // Skip any whitespace. while (isspace(LastChar)) LastChar = getchar(); if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == \u0026quot;def\u0026quot;) return tok_def; if (IdentifierStr == \u0026quot;extern\u0026quot;) return tok_extern; if (IdentifierStr == \u0026quot;if\u0026quot;) return tok_if; if (IdentifierStr == \u0026quot;then\u0026quot;) return tok_then; if (IdentifierStr == \u0026quot;else\u0026quot;) return tok_else; if (IdentifierStr == \u0026quot;for\u0026quot;) return tok_for; if (IdentifierStr == \u0026quot;in\u0026quot;) return tok_in; if (IdentifierStr == \u0026quot;binary\u0026quot;) return tok_binary; if (IdentifierStr == \u0026quot;unary\u0026quot;) return tok_unary; if (IdentifierStr == \u0026quot;var\u0026quot;) return tok_var; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), nullptr); return tok_number; } if (LastChar == '#') { // Comment until end of line. do LastChar = getchar(); while (LastChar != EOF \u0026amp;\u0026amp; LastChar != '\\n' \u0026amp;\u0026amp; LastChar != '\\r'); if (LastChar != EOF) return gettok(); } // Check for end of file. Don't eat the EOF. if (LastChar == EOF) return tok_eof; // Otherwise, just return the character as its ascii value. int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// // Abstract Syntax Tree (aka Parse Tree) //===----------------------------------------------------------------------===// namespace { /// ExprAST - Base class for all expression nodes. class ExprAST { public: virtual ~ExprAST() = default; virtual Value *codegen() = 0; }; /// NumberExprAST - Expression class for numeric literals like \u0026quot;1.0\u0026quot;. class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double Val) : Val(Val) {} Value *codegen() override; }; /// VariableExprAST - Expression class for referencing a variable, like \u0026quot;a\u0026quot;. class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string \u0026amp;Name) : Name(Name) {} Value *codegen() override; const std::string \u0026amp;getName() const { return Name; } }; /// UnaryExprAST - Expression class for a unary operator. class UnaryExprAST : public ExprAST { char Opcode; std::unique_ptr\u0026lt;ExprAST\u0026gt; Operand; public: UnaryExprAST(char Opcode, std::unique_ptr\u0026lt;ExprAST\u0026gt; Operand) : Opcode(Opcode), Operand(std::move(Operand)) {} Value *codegen() override; }; /// BinaryExprAST - Expression class for a binary operator. class BinaryExprAST : public ExprAST { char Op; std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS, RHS; public: BinaryExprAST(char Op, std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS, std::unique_ptr\u0026lt;ExprAST\u0026gt; RHS) : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {} Value *codegen() override; }; /// CallExprAST - Expression class for function calls. class CallExprAST : public ExprAST { std::string Callee; std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args; public: CallExprAST(const std::string \u0026amp;Callee, std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args) : Callee(Callee), Args(std::move(Args)) {} Value *codegen() override; }; /// IfExprAST - Expression class for if/then/else. class IfExprAST : public ExprAST { std::unique_ptr\u0026lt;ExprAST\u0026gt; Cond, Then, Else; public: IfExprAST(std::unique_ptr\u0026lt;ExprAST\u0026gt; Cond, std::unique_ptr\u0026lt;ExprAST\u0026gt; Then, std::unique_ptr\u0026lt;ExprAST\u0026gt; Else) : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {} Value *codegen() override; }; /// ForExprAST - Expression class for for/in. class ForExprAST : public ExprAST { std::string VarName; std::unique_ptr\u0026lt;ExprAST\u0026gt; Start, End, Step, Body; public: ForExprAST(const std::string \u0026amp;VarName, std::unique_ptr\u0026lt;ExprAST\u0026gt; Start, std::unique_ptr\u0026lt;ExprAST\u0026gt; End, std::unique_ptr\u0026lt;ExprAST\u0026gt; Step, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : VarName(VarName), Start(std::move(Start)), End(std::move(End)), Step(std::move(Step)), Body(std::move(Body)) {} Value *codegen() override; }; /// VarExprAST - Expression class for var/in class VarExprAST : public ExprAST { std::vector\u0026lt;std::pair\u0026lt;std::string, std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt;\u0026gt; VarNames; std::unique_ptr\u0026lt;ExprAST\u0026gt; Body; public: VarExprAST( std::vector\u0026lt;std::pair\u0026lt;std::string, std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt;\u0026gt; VarNames, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : VarNames(std::move(VarNames)), Body(std::move(Body)) {} Value *codegen() override; }; /// PrototypeAST - This class represents the \u0026quot;prototype\u0026quot; for a function, /// which captures its name, and its argument names (thus implicitly the number /// of arguments the function takes), as well as if it is an operator. class PrototypeAST { std::string Name; std::vector\u0026lt;std::string\u0026gt; Args; bool IsOperator; unsigned Precedence; // Precedence if a binary op. public: PrototypeAST(const std::string \u0026amp;Name, std::vector\u0026lt;std::string\u0026gt; Args, bool IsOperator = false, unsigned Prec = 0) : Name(Name), Args(std::move(Args)), IsOperator(IsOperator), Precedence(Prec) {} Function *codegen(); const std::string \u0026amp;getName() const { return Name; } bool isUnaryOp() const { return IsOperator \u0026amp;\u0026amp; Args.size() == 1; } bool isBinaryOp() const { return IsOperator \u0026amp;\u0026amp; Args.size() == 2; } char getOperatorName() const { assert(isUnaryOp() || isBinaryOp()); return Name[Name.size() - 1]; } unsigned getBinaryPrecedence() const { return Precedence; } }; /// FunctionAST - This class represents a function definition itself. class FunctionAST { std::unique_ptr\u0026lt;PrototypeAST\u0026gt; Proto; std::unique_ptr\u0026lt;ExprAST\u0026gt; Body; public: FunctionAST(std::unique_ptr\u0026lt;PrototypeAST\u0026gt; Proto, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : Proto(std::move(Proto)), Body(std::move(Body)) {} Function *codegen(); }; } // end anonymous namespace //===----------------------------------------------------------------------===// // Parser //===----------------------------------------------------------------------===// /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current /// token the parser is looking at. getNextToken reads another token from the /// lexer and updates CurTok with its results. static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence - This holds the precedence for each binary operator that is /// defined. static std::map\u0026lt;char, int\u0026gt; BinopPrecedence; /// GetTokPrecedence - Get the precedence of the pending binary operator token. static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // Make sure it's a declared binop. int TokPrec = BinopPrecedence[CurTok]; if (TokPrec \u0026lt;= 0) return -1; return TokPrec; } /// LogError* - These are little helper functions for error handling. std::unique_ptr\u0026lt;ExprAST\u0026gt; LogError(const char *Str) { fprintf(stderr, \u0026quot;Error: %s\\n\u0026quot;, Str); return nullptr; } std::unique_ptr\u0026lt;PrototypeAST\u0026gt; LogErrorP(const char *Str) { LogError(Str); return nullptr; } static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseExpression(); /// numberexpr ::= number static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseNumberExpr() { auto Result = std::make_unique\u0026lt;NumberExprAST\u0026gt;(NumVal); getNextToken(); // consume the number return std::move(Result); } /// parenexpr ::= '(' expression ')' static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseParenExpr() { getNextToken(); // eat (. auto V = ParseExpression(); if (!V) return nullptr; if (CurTok != ')') return LogError(\u0026quot;expected ')'\u0026quot;); getNextToken(); // eat ). return V; } /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref. return std::make_unique\u0026lt;VariableExprAST\u0026gt;(IdName); // Call. getNextToken(); // eat ( std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args; if (CurTok != ')') { while (true) { if (auto Arg = ParseExpression()) Args.push_back(std::move(Arg)); else return nullptr; if (CurTok == ')') break; if (CurTok != ',') return LogError(\u0026quot;Expected ')' or ',' in argument list\u0026quot;); getNextToken(); } } // Eat the ')'. getNextToken(); return std::make_unique\u0026lt;CallExprAST\u0026gt;(IdName, std::move(Args)); } /// ifexpr ::= 'if' expression 'then' expression 'else' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseIfExpr() { getNextToken(); // eat the if. // condition. auto Cond = ParseExpression(); if (!Cond) return nullptr; if (CurTok != tok_then) return LogError(\u0026quot;expected then\u0026quot;); getNextToken(); // eat the then auto Then = ParseExpression(); if (!Then) return nullptr; if (CurTok != tok_else) return LogError(\u0026quot;expected else\u0026quot;); getNextToken(); auto Else = ParseExpression(); if (!Else) return nullptr; return std::make_unique\u0026lt;IfExprAST\u0026gt;(std::move(Cond), std::move(Then), std::move(Else)); } /// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseForExpr() { getNextToken(); // eat the for. if (CurTok != tok_identifier) return LogError(\u0026quot;expected identifier after for\u0026quot;); std::string IdName = IdentifierStr; getNextToken(); // eat identifier. if (CurTok != '=') return LogError(\u0026quot;expected '=' after for\u0026quot;); getNextToken(); // eat '='. auto Start = ParseExpression(); if (!Start) return nullptr; if (CurTok != ',') return LogError(\u0026quot;expected ',' after for start value\u0026quot;); getNextToken(); auto End = ParseExpression(); if (!End) return nullptr; // The step value is optional. std::unique_ptr\u0026lt;ExprAST\u0026gt; Step; if (CurTok == ',') { getNextToken(); Step = ParseExpression(); if (!Step) return nullptr; } if (CurTok != tok_in) return LogError(\u0026quot;expected 'in' after for\u0026quot;); getNextToken(); // eat 'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return std::make_unique\u0026lt;ForExprAST\u0026gt;(IdName, std::move(Start), std::move(End), std::move(Step), std::move(Body)); } /// varexpr ::= 'var' identifier ('=' expression)? // (',' identifier ('=' expression)?)* 'in' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseVarExpr() { getNextToken(); // eat the var. std::vector\u0026lt;std::pair\u0026lt;std::string, std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt;\u0026gt; VarNames; // At least one variable name is required. if (CurTok != tok_identifier) return LogError(\u0026quot;expected identifier after var\u0026quot;); while (true) { std::string Name = IdentifierStr; getNextToken(); // eat identifier. // Read the optional initializer. std::unique_ptr\u0026lt;ExprAST\u0026gt; Init = nullptr; if (CurTok == '=') { getNextToken(); // eat the '='. Init = ParseExpression(); if (!Init) return nullptr; } VarNames.push_back(std::make_pair(Name, std::move(Init))); // End of var list, exit loop. if (CurTok != ',') break; getNextToken(); // eat the ','. if (CurTok != tok_identifier) return LogError(\u0026quot;expected identifier list after var\u0026quot;); } // At this point, we have to have 'in'. if (CurTok != tok_in) return LogError(\u0026quot;expected 'in' keyword after 'var'\u0026quot;); getNextToken(); // eat 'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return std::make_unique\u0026lt;VarExprAST\u0026gt;(std::move(VarNames), std::move(Body)); } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr /// ::= ifexpr /// ::= forexpr /// ::= varexpr static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParsePrimary() { switch (CurTok) { default: return LogError(\u0026quot;unknown token when expecting an expression\u0026quot;); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); case tok_var: return ParseVarExpr(); } } /// unary /// ::= primary /// ::= '!' unary static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseUnary() { // If the current token is not an operator, it must be a primary expr. if (!isascii(CurTok) || CurTok == '(' || CurTok == ',') return ParsePrimary(); // If this is a unary operator, read it. int Opc = CurTok; getNextToken(); if (auto Operand = ParseUnary()) return std::make_unique\u0026lt;UnaryExprAST\u0026gt;(Opc, std::move(Operand)); return nullptr; } /// binoprhs /// ::= ('+' unary)* static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseBinOpRHS(int ExprPrec, std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS) { // If this is a binop, find its precedence. while (true) { int TokPrec = GetTokPrecedence(); // If this is a binop that binds at least as tightly as the current binop, // consume it, otherwise we are done. if (TokPrec \u0026lt; ExprPrec) return LHS; // Okay, we know this is a binop. int BinOp = CurTok; getNextToken(); // eat binop // Parse the unary expression after the binary operator. auto RHS = ParseUnary(); if (!RHS) return nullptr; // If BinOp binds less tightly with RHS than the operator after RHS, let // the pending operator take RHS as its LHS. int NextPrec = GetTokPrecedence(); if (TokPrec \u0026lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS)); if (!RHS) return nullptr; } // Merge LHS/RHS. LHS = std::make_unique\u0026lt;BinaryExprAST\u0026gt;(BinOp, std::move(LHS), std::move(RHS)); } } /// expression /// ::= unary binoprhs /// static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseExpression() { auto LHS = ParseUnary(); if (!LHS) return nullptr; return ParseBinOpRHS(0, std::move(LHS)); } /// prototype /// ::= id '(' id* ')' /// ::= binary LETTER number? (id, id) /// ::= unary LETTER (id) static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParsePrototype() { std::string FnName; unsigned Kind = 0; // 0 = identifier, 1 = unary, 2 = binary. unsigned BinaryPrecedence = 30; switch (CurTok) { default: return LogErrorP(\u0026quot;Expected function name in prototype\u0026quot;); case tok_identifier: FnName = IdentifierStr; Kind = 0; getNextToken(); break; case tok_unary: getNextToken(); if (!isascii(CurTok)) return LogErrorP(\u0026quot;Expected unary operator\u0026quot;); FnName = \u0026quot;unary\u0026quot;; FnName += (char)CurTok; Kind = 1; getNextToken(); break; case tok_binary: getNextToken(); if (!isascii(CurTok)) return LogErrorP(\u0026quot;Expected binary operator\u0026quot;); FnName = \u0026quot;binary\u0026quot;; FnName += (char)CurTok; Kind = 2; getNextToken(); // Read the precedence if present. if (CurTok == tok_number) { if (NumVal \u0026lt; 1 || NumVal \u0026gt; 100) return LogErrorP(\u0026quot;Invalid precedence: must be 1..100\u0026quot;); BinaryPrecedence = (unsigned)NumVal; getNextToken(); } break; } if (CurTok != '(') return LogErrorP(\u0026quot;Expected '(' in prototype\u0026quot;); std::vector\u0026lt;std::string\u0026gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return LogErrorP(\u0026quot;Expected ')' in prototype\u0026quot;); // success. getNextToken(); // eat ')'. // Verify right number of names for operator. if (Kind \u0026amp;\u0026amp; ArgNames.size() != Kind) return LogErrorP(\u0026quot;Invalid number of operands for operator\u0026quot;); return std::make_unique\u0026lt;PrototypeAST\u0026gt;(FnName, ArgNames, Kind != 0, BinaryPrecedence); } /// definition ::= 'def' prototype expression static std::unique_ptr\u0026lt;FunctionAST\u0026gt; ParseDefinition() { getNextToken(); // eat def. auto Proto = ParsePrototype(); if (!Proto) return nullptr; if (auto E = ParseExpression()) return std::make_unique\u0026lt;FunctionAST\u0026gt;(std::move(Proto), std::move(E)); return nullptr; } /// toplevelexpr ::= expression static std::unique_ptr\u0026lt;FunctionAST\u0026gt; ParseTopLevelExpr() { if (auto E = ParseExpression()) { // Make an anonymous proto. auto Proto = std::make_unique\u0026lt;PrototypeAST\u0026gt;(\u0026quot;__anon_expr\u0026quot;, std::vector\u0026lt;std::string\u0026gt;()); return std::make_unique\u0026lt;FunctionAST\u0026gt;(std::move(Proto), std::move(E)); } return nullptr; } /// external ::= 'extern' prototype static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParseExtern() { getNextToken(); // eat extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// // Code Generation //===----------------------------------------------------------------------===// static std::unique_ptr\u0026lt;LLVMContext\u0026gt; TheContext; static std::unique_ptr\u0026lt;Module\u0026gt; TheModule; static std::unique_ptr\u0026lt;IRBuilder\u0026lt;\u0026gt;\u0026gt; Builder; static std::map\u0026lt;std::string, AllocaInst *\u0026gt; NamedValues; static std::map\u0026lt;std::string, std::unique_ptr\u0026lt;PrototypeAST\u0026gt;\u0026gt; FunctionProtos; static ExitOnError ExitOnErr; Value *LogErrorV(const char *Str) { LogError(Str); return nullptr; } Function *getFunction(std::string Name) { // First, see if the function has already been added to the current module. if (auto *F = TheModule-\u0026gt;getFunction(Name)) return F; // If not, check whether we can codegen the declaration from some existing // prototype. auto FI = FunctionProtos.find(Name); if (FI != FunctionProtos.end()) return FI-\u0026gt;second-\u0026gt;codegen(); // If no existing prototype exists, return null. return nullptr; } /// CreateEntryBlockAlloca - Create an alloca instruction in the entry block of /// the function. This is used for mutable variables etc. static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction, StringRef VarName) { IRBuilder\u0026lt;\u0026gt; TmpB(\u0026amp;TheFunction-\u0026gt;getEntryBlock(), TheFunction-\u0026gt;getEntryBlock().begin()); return TmpB.CreateAlloca(Type::getDoubleTy(*TheContext), nullptr, VarName); } Value *NumberExprAST::codegen() { return ConstantFP::get(*TheContext, APFloat(Val)); } Value *VariableExprAST::codegen() { // Look this variable up in the function. Value *V = NamedValues[Name]; if (!V) return LogErrorV(\u0026quot;Unknown variable name\u0026quot;); // Load the value. return Builder-\u0026gt;CreateLoad(Type::getDoubleTy(*TheContext), V, Name.c_str()); } Value *UnaryExprAST::codegen() { Value *OperandV = Operand-\u0026gt;codegen(); if (!OperandV) return nullptr; Function *F = getFunction(std::string(\u0026quot;unary\u0026quot;) + Opcode); if (!F) return LogErrorV(\u0026quot;Unknown unary operator\u0026quot;); return Builder-\u0026gt;CreateCall(F, OperandV, \u0026quot;unop\u0026quot;); } Value *BinaryExprAST::codegen() { // Special case '=' because we don't want to emit the LHS as an expression. if (Op == '=') { // Assignment requires the LHS to be an identifier. // This assume we're building without RTTI because LLVM builds that way by // default. If you build LLVM with RTTI this can be changed to a // dynamic_cast for automatic error checking. VariableExprAST *LHSE = static_cast\u0026lt;VariableExprAST *\u0026gt;(LHS.get()); if (!LHSE) return LogErrorV(\u0026quot;destination of '=' must be a variable\u0026quot;); // Codegen the RHS. Value *Val = RHS-\u0026gt;codegen(); if (!Val) return nullptr; // Look up the name. Value *Variable = NamedValues[LHSE-\u0026gt;getName()]; if (!Variable) return LogErrorV(\u0026quot;Unknown variable name\u0026quot;); Builder-\u0026gt;CreateStore(Val, Variable); return Val; } Value *L = LHS-\u0026gt;codegen(); Value *R = RHS-\u0026gt;codegen(); if (!L || !R) return nullptr; switch (Op) { case '+': return Builder-\u0026gt;CreateFAdd(L, R, \u0026quot;addtmp\u0026quot;); case '-': return Builder-\u0026gt;CreateFSub(L, R, \u0026quot;subtmp\u0026quot;); case '*': return Builder-\u0026gt;CreateFMul(L, R, \u0026quot;multmp\u0026quot;); case '\u0026lt;': L = Builder-\u0026gt;CreateFCmpULT(L, R, \u0026quot;cmptmp\u0026quot;); // Convert bool 0/1 to double 0.0 or 1.0 return Builder-\u0026gt;CreateUIToFP(L, Type::getDoubleTy(*TheContext), \u0026quot;booltmp\u0026quot;); default: break; } // If it wasn't a builtin binary operator, it must be a user defined one. Emit // a call to it. Function *F = getFunction(std::string(\u0026quot;binary\u0026quot;) + Op); assert(F \u0026amp;\u0026amp; \u0026quot;binary operator not found!\u0026quot;); Value *Ops[] = {L, R}; return Builder-\u0026gt;CreateCall(F, Ops, \u0026quot;binop\u0026quot;); } Value *CallExprAST::codegen() { // Look up the name in the global module table. Function *CalleeF = getFunction(Callee); if (!CalleeF) return LogErrorV(\u0026quot;Unknown function referenced\u0026quot;); // If argument mismatch error. if (CalleeF-\u0026gt;arg_size() != Args.size()) return LogErrorV(\u0026quot;Incorrect # arguments passed\u0026quot;); std::vector\u0026lt;Value *\u0026gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-\u0026gt;codegen()); if (!ArgsV.back()) return nullptr; } return Builder-\u0026gt;CreateCall(CalleeF, ArgsV, \u0026quot;calltmp\u0026quot;); } Value *IfExprAST::codegen() { Value *CondV = Cond-\u0026gt;codegen(); if (!CondV) return nullptr; // Convert condition to a bool by comparing non-equal to 0.0. CondV = Builder-\u0026gt;CreateFCmpONE( CondV, ConstantFP::get(*TheContext, APFloat(0.0)), \u0026quot;ifcond\u0026quot;); Function *TheFunction = Builder-\u0026gt;GetInsertBlock()-\u0026gt;getParent(); // Create blocks for the then and else cases. Insert the 'then' block at the // end of the function. BasicBlock *ThenBB = BasicBlock::Create(*TheContext, \u0026quot;then\u0026quot;, TheFunction); BasicBlock *ElseBB = BasicBlock::Create(*TheContext, \u0026quot;else\u0026quot;); BasicBlock *MergeBB = BasicBlock::Create(*TheContext, \u0026quot;ifcont\u0026quot;); Builder-\u0026gt;CreateCondBr(CondV, ThenBB, ElseBB); // Emit then value. Builder-\u0026gt;SetInsertPoint(ThenBB); Value *ThenV = Then-\u0026gt;codegen(); if (!ThenV) return nullptr; Builder-\u0026gt;CreateBr(MergeBB); // Codegen of 'Then' can change the current block, update ThenBB for the PHI. ThenBB = Builder-\u0026gt;GetInsertBlock(); // Emit else block. TheFunction-\u0026gt;getBasicBlockList().push_back(ElseBB); Builder-\u0026gt;SetInsertPoint(ElseBB); Value *ElseV = Else-\u0026gt;codegen(); if (!ElseV) return nullptr; Builder-\u0026gt;CreateBr(MergeBB); // Codegen of 'Else' can change the current block, update ElseBB for the PHI. ElseBB = Builder-\u0026gt;GetInsertBlock(); // Emit merge block. TheFunction-\u0026gt;getBasicBlockList().push_back(MergeBB); Builder-\u0026gt;SetInsertPoint(MergeBB); PHINode *PN = Builder-\u0026gt;CreatePHI(Type::getDoubleTy(*TheContext), 2, \u0026quot;iftmp\u0026quot;); PN-\u0026gt;addIncoming(ThenV, ThenBB); PN-\u0026gt;addIncoming(ElseV, ElseBB); return PN; } // Output for-loop as: // var = alloca double // ... // start = startexpr // store start -\u0026gt; var // goto loop // loop: // ... // bodyexpr // ... // loopend: // step = stepexpr // endcond = endexpr // // curvar = load var // nextvar = curvar + step // store nextvar -\u0026gt; var // br endcond, loop, endloop // outloop: Value *ForExprAST::codegen() { Function *TheFunction = Builder-\u0026gt;GetInsertBlock()-\u0026gt;getParent(); // Create an alloca for the variable in the entry block. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); // Emit the start code first, without 'variable' in scope. Value *StartVal = Start-\u0026gt;codegen(); if (!StartVal) return nullptr; // Store the value into the alloca. Builder-\u0026gt;CreateStore(StartVal, Alloca); // Make the new basic block for the loop header, inserting after current // block. BasicBlock *LoopBB = BasicBlock::Create(*TheContext, \u0026quot;loop\u0026quot;, TheFunction); // Insert an explicit fall through from the current block to the LoopBB. Builder-\u0026gt;CreateBr(LoopBB); // Start insertion in LoopBB. Builder-\u0026gt;SetInsertPoint(LoopBB); // Within the loop, the variable is defined equal to the PHI node. If it // shadows an existing variable, we have to restore it, so save it now. AllocaInst *OldVal = NamedValues[VarName]; NamedValues[VarName] = Alloca; // Emit the body of the loop. This, like any other expr, can change the // current BB. Note that we ignore the value computed by the body, but don't // allow an error. if (!Body-\u0026gt;codegen()) return nullptr; // Emit the step value. Value *StepVal = nullptr; if (Step) { StepVal = Step-\u0026gt;codegen(); if (!StepVal) return nullptr; } else { // If not specified, use 1.0. StepVal = ConstantFP::get(*TheContext, APFloat(1.0)); } // Compute the end condition. Value *EndCond = End-\u0026gt;codegen(); if (!EndCond) return nullptr; // Reload, increment, and restore the alloca. This handles the case where // the body of the loop mutates the variable. Value *CurVar = Builder-\u0026gt;CreateLoad(Type::getDoubleTy(*TheContext), Alloca, VarName.c_str()); Value *NextVar = Builder-\u0026gt;CreateFAdd(CurVar, StepVal, \u0026quot;nextvar\u0026quot;); Builder-\u0026gt;CreateStore(NextVar, Alloca); // Convert condition to a bool by comparing non-equal to 0.0. EndCond = Builder-\u0026gt;CreateFCmpONE( EndCond, ConstantFP::get(*TheContext, APFloat(0.0)), \u0026quot;loopcond\u0026quot;); // Create the \u0026quot;after loop\u0026quot; block and insert it. BasicBlock *AfterBB = BasicBlock::Create(*TheContext, \u0026quot;afterloop\u0026quot;, TheFunction); // Insert the conditional branch into the end of LoopEndBB. Builder-\u0026gt;CreateCondBr(EndCond, LoopBB, AfterBB); // Any new code will be inserted in AfterBB. Builder-\u0026gt;SetInsertPoint(AfterBB); // Restore the unshadowed variable. if (OldVal) NamedValues[VarName] = OldVal; else NamedValues.erase(VarName); // for expr always returns 0.0. return Constant::getNullValue(Type::getDoubleTy(*TheContext)); } Value *VarExprAST::codegen() { std::vector\u0026lt;AllocaInst *\u0026gt; OldBindings; Function *TheFunction = Builder-\u0026gt;GetInsertBlock()-\u0026gt;getParent(); // Register all variables and emit their initializer. for (unsigned i = 0, e = VarNames.size(); i != e; ++i) { const std::string \u0026amp;VarName = VarNames[i].first; ExprAST *Init = VarNames[i].second.get(); // Emit the initializer before adding the variable to scope, this prevents // the initializer from referencing the variable itself, and permits stuff // like this: // var a = 1 in // var a = a in ... # refers to outer 'a'. Value *InitVal; if (Init) { InitVal = Init-\u0026gt;codegen(); if (!InitVal) return nullptr; } else { // If not specified, use 0.0. InitVal = ConstantFP::get(*TheContext, APFloat(0.0)); } AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); Builder-\u0026gt;CreateStore(InitVal, Alloca); // Remember the old variable binding so that we can restore the binding when // we unrecurse. OldBindings.push_back(NamedValues[VarName]); // Remember this binding. NamedValues[VarName] = Alloca; } // Codegen the body, now that all vars are in scope. Value *BodyVal = Body-\u0026gt;codegen(); if (!BodyVal) return nullptr; // Pop all our variables from scope. for (unsigned i = 0, e = VarNames.size(); i != e; ++i) NamedValues[VarNames[i].first] = OldBindings[i]; // Return the body computation. return BodyVal; } Function *PrototypeAST::codegen() { // Make the function type: double(double,double) etc. std::vector\u0026lt;Type *\u0026gt; Doubles(Args.size(), Type::getDoubleTy(*TheContext)); FunctionType *FT = FunctionType::get(Type::getDoubleTy(*TheContext), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get()); // Set names for all arguments. unsigned Idx = 0; for (auto \u0026amp;Arg : F-\u0026gt;args()) Arg.setName(Args[Idx++]); return F; } Function *FunctionAST::codegen() { // Transfer ownership of the prototype to the FunctionProtos map, but keep a // reference to it for use below. auto \u0026amp;P = *Proto; FunctionProtos[Proto-\u0026gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr; // If this is an operator, install it. if (P.isBinaryOp()) BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence(); // Create a new basic block to start insertion into. BasicBlock *BB = BasicBlock::Create(*TheContext, \u0026quot;entry\u0026quot;, TheFunction); Builder-\u0026gt;SetInsertPoint(BB); // Record the function arguments in the NamedValues map. NamedValues.clear(); for (auto \u0026amp;Arg : TheFunction-\u0026gt;args()) { // Create an alloca for this variable. AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName()); // Store the initial value into the alloca. Builder-\u0026gt;CreateStore(\u0026amp;Arg, Alloca); // Add arguments to variable symbol table. NamedValues[std::string(Arg.getName())] = Alloca; } if (Value *RetVal = Body-\u0026gt;codegen()) { // Finish off the function. Builder-\u0026gt;CreateRet(RetVal); // Validate the generated code, checking for consistency. verifyFunction(*TheFunction); return TheFunction; } // Error reading body, remove function. TheFunction-\u0026gt;eraseFromParent(); if (P.isBinaryOp()) BinopPrecedence.erase(P.getOperatorName()); return nullptr; } //===----------------------------------------------------------------------===// // Top-Level parsing and JIT Driver //===----------------------------------------------------------------------===// static void InitializeModuleAndPassManager() { // Open a new module. TheContext = std::make_unique\u0026lt;LLVMContext\u0026gt;(); TheModule = std::make_unique\u0026lt;Module\u0026gt;(\u0026quot;my cool jit\u0026quot;, *TheContext); // Create a new builder for the module. Builder = std::make_unique\u0026lt;IRBuilder\u0026lt;\u0026gt;\u0026gt;(*TheContext); } static void HandleDefinition() { if (auto FnAST = ParseDefinition()) { if (auto *FnIR = FnAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read function definition:\u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); } } else { // Skip token for error recovery. getNextToken(); } } static void HandleExtern() { if (auto ProtoAST = ParseExtern()) { if (auto *FnIR = ProtoAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read extern: \u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); FunctionProtos[ProtoAST-\u0026gt;getName()] = std::move(ProtoAST); } } else { // Skip token for error recovery. getNextToken(); } } static void HandleTopLevelExpression() { // Evaluate a top-level expression into an anonymous function. if (auto FnAST = ParseTopLevelExpr()) { FnAST-\u0026gt;codegen(); } else { // Skip token for error recovery. getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (true) { switch (CurTok) { case tok_eof: return; case ';': // ignore top-level semicolons. getNextToken(); break; case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // \u0026quot;Library\u0026quot; functions that can be \u0026quot;extern'd\u0026quot; from user code. //===----------------------------------------------------------------------===// #ifdef _WIN32 #define DLLEXPORT __declspec(dllexport) #else #define DLLEXPORT #endif /// putchard - putchar that takes a double and returns 0. extern \u0026quot;C\u0026quot; DLLEXPORT double putchard(double X) { fputc((char)X, stderr); return 0; } /// printd - printf that takes a double prints it as \u0026quot;%f\\n\u0026quot;, returning 0. extern \u0026quot;C\u0026quot; DLLEXPORT double printd(double X) { fprintf(stderr, \u0026quot;%f\\n\u0026quot;, X); return 0; } //===----------------------------------------------------------------------===// // Main driver code. //===----------------------------------------------------------------------===// int main() { // Install standard binary operators. // 1 is lowest precedence. BinopPrecedence['\u0026lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; // highest. // Prime the first token. fprintf(stderr, \u0026quot;ready\u0026gt; \u0026quot;); getNextToken(); InitializeModuleAndPassManager(); // Run the main \u0026quot;interpreter loop\u0026quot; now. MainLoop(); // Initialize the target registry etc. InitializeAllTargetInfos(); InitializeAllTargets(); InitializeAllTargetMCs(); InitializeAllAsmParsers(); InitializeAllAsmPrinters(); auto TargetTriple = sys::getDefaultTargetTriple(); TheModule-\u0026gt;setTargetTriple(TargetTriple); std::string Error; auto Target = TargetRegistry::lookupTarget(TargetTriple, Error); // Print an error and exit if we couldn't find the requested target. // This generally occurs if we've forgotten to initialise the // TargetRegistry or we have a bogus target triple. if (!Target) { errs() \u0026lt;\u0026lt; Error; return 1; } auto CPU = \u0026quot;generic\u0026quot;; auto Features = \u0026quot;\u0026quot;; TargetOptions opt; auto RM = Optional\u0026lt;Reloc::Model\u0026gt;(); auto TheTargetMachine = Target-\u0026gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM); TheModule-\u0026gt;setDataLayout(TheTargetMachine-\u0026gt;createDataLayout()); auto Filename = \u0026quot;output.o\u0026quot;; std::error_code EC; raw_fd_ostream dest(Filename, EC, sys::fs::OF_None); if (EC) { errs() \u0026lt;\u0026lt; \u0026quot;Could not open file: \u0026quot; \u0026lt;\u0026lt; EC.message(); return 1; } legacy::PassManager pass; auto FileType = CGFT_ObjectFile; if (TheTargetMachine-\u0026gt;addPassesToEmitFile(pass, dest, nullptr, FileType)) { errs() \u0026lt;\u0026lt; \u0026quot;TheTargetMachine can't emit a file of this type\u0026quot;; return 1; } pass.run(*TheModule); dest.flush(); outs() \u0026lt;\u0026lt; \u0026quot;Wrote \u0026quot; \u0026lt;\u0026lt; Filename \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; } ","date":"2022-01-18","permalink":"https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-8/","tags":["编译原理","编译前端","LLVM","翻译"],"title":"LLVM Kaleidoscope 第 8 章：编译到目标文件"},{"content":"6.1 前言 欢迎来到 我的第一个基于 LLVM 的语言前端 教程第六章。麻雀虽小，五脏俱全，现在我们已经有了一个相对完备的小型函数式编程语言。但目前我们的语言还有一个大缺点：它缺少很多有用的运算符 (比如除法和逻辑非，我们甚至还没有除了小于之外的任何比较运算符！)\n本章将会讨论如何让语言支持自定义运算符。诚然，自定义运算符可能让我们的语言变得丑陋 \u0026ndash; 但同时它也能给予我们的语言强大的表达力。自创语言的醍醐味就在于你可以 (并且需要！) 做出你自己的判断，不论是好是坏。本教程将选择允许用户自定义运算符，同时在实现它的过程中讨论一些有趣的语法解析技术。\n在本教程的结尾，我们将编写一个渲染曼德博集合的 Kaleidoscope 程序。它同时也会作为一个示范，告诉你 Kaleidoscope 的强大之处，以及如何使用 Kaleidoscope 做出更多有趣的事情。\n6.2 自定义运算符：思想 我们将要加入的 \u0026ldquo;运算符重载\u0026rdquo; 比其他语言 (比如 C++) 中的更加泛用。在 C++, 你只能重载已有的运算符，并不能通过程序来改变语法，加入新运算符或者改变运算符的优先级。本章我们将让 Kaleidoscope 拥有这些 C++ 也没有的能力，让语言的使用者摆脱已有运算符的限制。\n实现自定义运算符的过程突显了手写 parser 的灵活与可扩展性。目前，在我们使用的 parser 中，递归下降法被用于处理大部分语法，而运算符优先级解析法 (operator precedence parsing) 被用于处理表达式 (如果你忘记了它们，请复习第二章！) 基于优先级解析法，我们很容易在语法中加入新的运算符：语法可以随着 JIT 的运行动态地扩展。\n我们将要添加两个主要特性：一元运算符与二元运算符。(目前，Kaleidoscope 还不支持任何形式的一元运算符) 使用它们的例子如下：\n# Logical unary not. # 一元运算符：逻辑非 def unary!(v) if v then 0 else 1; # Define \u0026gt; with the same precedence as \u0026lt;. # 定义 \u0026gt; 并使其与 \u0026lt; 有相同的优先级 def binary\u0026gt; 10 (LHS RHS) RHS \u0026lt; LHS; # Binary \u0026quot;logical or\u0026quot;, (note that it does not \u0026quot;short circuit\u0026quot;) # 二元运算符：逻辑或 (注意！它并不会 \u0026quot;短路\u0026quot; 执行) def binary| 5 (LHS RHS) if LHS then 1 else if RHS then 1 else 0; # Define = with slightly lower precedence than relationals. # 将 = 的优先级定义得比其他关系运算符低一点 def binary= 9 (LHS RHS) !(LHS \u0026lt; RHS | LHS \u0026gt; RHS);  许多语言都希望它们标准库的绝大部分能使用语言自身实现; 但在 Kaleidoscope，我们甚至能用语言实现语言的绝大部分！\n我们将会分两步实现这些特性：实现自定义二元运算符，随后再实现自定义一元运算符。\n6.3 自定义二元运算符 在目前框架下实现自定义二元运算符比较简单。我们首先加入对 unary / binary 关键字的支持。\nenum Token { ... // operators tok_binary = -11, tok_unary = -12 }; ... static int gettok() { ... if (IdentifierStr == \u0026quot;for\u0026quot;) return tok_for; if (IdentifierStr == \u0026quot;in\u0026quot;) return tok_in; if (IdentifierStr == \u0026quot;binary\u0026quot;) return tok_binary; if (IdentifierStr == \u0026quot;unary\u0026quot;) return tok_unary; return tok_identifier;  就像前几章一样，我们简单地修改一下我们的 lexer 使之能识别新的关键字。更幸运的是，我们 AST 的设计直接就支持表示任意二元运算符 \u0026ndash; 我们直接在 opcode 成员中储存了运算符的 ASCII 码 \u0026ndash; 所以我们不需要修改 AST 来支持新的二元运算符。\n但是，我们还需要表示新运算符的定义的 AST. 我们修改 PrototypeAST 的定义，将其扩展如下以支持新的类似于 def binary| 5的运算符定义语法：\n/// PrototypeAST - This class represents the \u0026quot;prototype\u0026quot; for a function, /// which captures its argument names as well as if it is an operator. class PrototypeAST { std::string Name; std::vector\u0026lt;std::string\u0026gt; Args; bool IsOperator; unsigned Precedence; // Precedence if a binary op. public: PrototypeAST(const std::string \u0026amp;name, std::vector\u0026lt;std::string\u0026gt; Args, bool IsOperator = false, unsigned Prec = 0) : Name(name), Args(std::move(Args)), IsOperator(IsOperator), Precedence(Prec) {} Function *codegen(); const std::string \u0026amp;getName() const { return Name; } bool isUnaryOp() const { return IsOperator \u0026amp;\u0026amp; Args.size() == 1; } bool isBinaryOp() const { return IsOperator \u0026amp;\u0026amp; Args.size() == 2; } char getOperatorName() const { assert(isUnaryOp() || isBinaryOp()); return Name[Name.size() - 1]; } unsigned getBinaryPrecedence() const { return Precedence; } };  我们所做的基本上就是记住该定义是否是一个运算符定义。注意运算符优先级的仅仅适用于二元运算符 (一元运算符根本不需要优先级). 现在我们有了表示自定义优先级函数原型的 AST 了，我们来修改 parser 以支持它：\n/// prototype /// ::= id '(' id* ')' /// ::= binary LETTER number? (id, id) static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParsePrototype() { std::string FnName; unsigned Kind = 0; // 0 = identifier, 1 = unary, 2 = binary. unsigned BinaryPrecedence = 30; switch (CurTok) { default: return LogErrorP(\u0026quot;Expected function name in prototype\u0026quot;); case tok_identifier: FnName = IdentifierStr; Kind = 0; getNextToken(); break; case tok_binary: getNextToken(); if (!isascii(CurTok)) return LogErrorP(\u0026quot;Expected binary operator\u0026quot;); FnName = \u0026quot;binary\u0026quot;; FnName += (char)CurTok; Kind = 2; getNextToken(); // Read the precedence if present. // 如果优先级那个数字存在的话，就读取并解析它 if (CurTok == tok_number) { if (NumVal \u0026lt; 1 || NumVal \u0026gt; 100) return LogErrorP(\u0026quot;Invalid precedence: must be 1..100\u0026quot;); BinaryPrecedence = (unsigned)NumVal; getNextToken(); } break; } if (CurTok != '(') return LogErrorP(\u0026quot;Expected '(' in prototype\u0026quot;); std::vector\u0026lt;std::string\u0026gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return LogErrorP(\u0026quot;Expected ')' in prototype\u0026quot;); // success. getNextToken(); // eat ')'. // Verify right number of names for operator. // 检查自定义运算符的函数的形参数量是否合法 // 我们在上面以 Kind = 0 表示普通函数，Kind = 1/2 分别表示一元/二元函数 if (Kind \u0026amp;\u0026amp; ArgNames.size() != Kind) return LogErrorP(\u0026quot;Invalid number of operands for operator\u0026quot;); return std::make_unique\u0026lt;PrototypeAST\u0026gt;(FnName, std::move(ArgNames), Kind != 0, BinaryPrecedence); }  类似上面的代码我们已经写得很多了。值得注意的是我们为运算符函数起的名字：我们直接使用为二元运算符@使用形如 binary@ 的名字。事实上，LLVM 的符号名称支持任意字符 \u0026ndash; 甚至包括内嵌的空字符 (NUL)！\n接下来要做的是为二元运算符生成中间代码。基于我们目前的代码，我们只需要简单修改一下就可以了：\nValue *BinaryExprAST::codegen() { Value *L = LHS-\u0026gt;codegen(); Value *R = RHS-\u0026gt;codegen(); if (!L || !R) return nullptr; switch (Op) { case '+': return Builder.CreateFAdd(L, R, \u0026quot;addtmp\u0026quot;); case '-': return Builder.CreateFSub(L, R, \u0026quot;subtmp\u0026quot;); case '*': return Builder.CreateFMul(L, R, \u0026quot;multmp\u0026quot;); case '\u0026lt;': L = Builder.CreateFCmpULT(L, R, \u0026quot;cmptmp\u0026quot;); // Convert bool 0/1 to double 0.0 or 1.0 // 将 bool/i1 值转换为浮点 0.0 或 1.0 return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), \u0026quot;booltmp\u0026quot;); default: break; } // If it wasn't a builtin binary operator, it must be a user defined one. Emit // a call to it. // 如果一个二元运算符不是内建的，那么它就是用户自定义的 // 在这种情况下，我们为其产生一个函数调用 Function *F = getFunction(std::string(\u0026quot;binary\u0026quot;) + Op); assert(F \u0026amp;\u0026amp; \u0026quot;binary operator not found!\u0026quot;); Value *Ops[2] = { L, R }; return Builder.CreateCall(F, Ops, \u0026quot;binop\u0026quot;); }  由于所谓的\u0026quot;自定义运算符\u0026quot;不过是一些普通的函数，我们只需要在默认情况下增加一个从符号表查找对应函数的操作就可以了。\n最后一步就是在顶层表达式中解析我们的自定义运算符：\nFunction *FunctionAST::codegen() { // Transfer ownership of the prototype to the FunctionProtos map, but keep a // reference to it for use below. auto \u0026amp;P = *Proto; FunctionProtos[Proto-\u0026gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr; // If this is an operator, install it. // 如果新定义的函数是一个对运算符的自定义函数，那么就处理一下 if (P.isBinaryOp()) BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence(); // Create a new basic block to start insertion into. BasicBlock *BB = BasicBlock::Create(TheContext, \u0026quot;entry\u0026quot;, TheFunction); ...  为了支持自定义运算符，我们在真正产生函数体的中间代码之前，首先检查其是否为自定义运算符函数; 如果是的话则先将其注册。有了这些代码，我们就完整地支持了自定义二元运算符了。\n对自定义二元运算符的支持利用了我们之前实现的很多代码，因而比较简单。接下来对自定义一元运算符的实现比较困难，毕竟我们甚至还没有在语言里实现过任何一个一元运算符。不管怎样，让我们开始吧。\n6.4 自定义一元运算符 我们的语言里还没有任何对一元运算符的支持，所以我们要白手起家了。在上面对 lexer 的修改中，我们已经加入了对 unary 关键字的支持。现在我们来创建一个新的 AST 节点类型：\n/// UnaryExprAST - Expression class for a unary operator. class UnaryExprAST : public ExprAST { char Opcode; std::unique_ptr\u0026lt;ExprAST\u0026gt; Operand; public: UnaryExprAST(char Opcode, std::unique_ptr\u0026lt;ExprAST\u0026gt; Operand) : Opcode(Opcode), Operand(std::move(Operand)) {} Value *codegen() override; };  上面的代码基本上跟二元运算符的 AST 是一样的，唯一不同的是它只有一个子节点。随后我们来解析一元表达式，我们实现一个新的函数：\n/// unary /// ::= primary /// ::= '!' unary static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseUnary() { // If the current token is not an operator, it must be a primary expr. // 如果现在的 token 不是一个运算符，那么它就必定是一个主表达式 if (!isascii(CurTok) || CurTok == '(' || CurTok == ',') return ParsePrimary(); // If this is a unary operator, read it. // 如果它是一个一元运算符，那么我们就读取它 int Opc = CurTok; getNextToken(); if (auto Operand = ParseUnary()) return std::make_unique\u0026lt;UnaryExprAST\u0026gt;(Opc, std::move(Operand)); return nullptr; }  如果我们在解析主表达式的时候遇到了一个一元运算符，我们就吞掉那个运算符并且把剩下的表达式当作另一个一元表达式来解析。借此我们得以处理表达式由多个一元运算符开头的情况 (比如 !!x). 值得注意的是，一元运算符并不会像二元一样出现二义性，所以我们并不需要对一元运算符设定优先级。\n剩下的问题就是我们要在什么时候调用这个函数了。我们修改解析二元表达式的函数如下，使之调用解析一元表达式的函数而不是解析主表达式的函数：\n/// binoprhs /// ::= ('+' unary)* static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseBinOpRHS(int ExprPrec, std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS) { ... // Parse the unary expression after the binary operator. // 解析完二元运算符之后接着解析一元运算符 auto RHS = ParseUnary(); if (!RHS) return nullptr; ... } /// expression /// ::= unary binoprhs /// static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseExpression() { auto LHS = ParseUnary(); if (!LHS) return nullptr; return ParseBinOpRHS(0, std::move(LHS)); }  改动两处后，我们现在可以解析包含一元表达式的代码并构建其 AST 了。下一步，我们修改函数原型的解析使其支持自定义一元运算符的特殊语法：\n/// prototype /// ::= id '(' id* ')' /// ::= binary LETTER number? (id, id) /// ::= unary LETTER (id) static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParsePrototype() { std::string FnName; unsigned Kind = 0; // 0 = identifier, 1 = unary, 2 = binary. unsigned BinaryPrecedence = 30; switch (CurTok) { default: return LogErrorP(\u0026quot;Expected function name in prototype\u0026quot;); case tok_identifier: FnName = IdentifierStr; Kind = 0; getNextToken(); break; case tok_unary: getNextToken(); if (!isascii(CurTok)) return LogErrorP(\u0026quot;Expected unary operator\u0026quot;); FnName = \u0026quot;unary\u0026quot;; FnName += (char)CurTok; Kind = 1; getNextToken(); break; case tok_binary: ...  就像我们对二元运算符定义函数做的那样，我们使用一个包含一元运算符字符的名字来命名这个函数。最后，我们生成一元运算表达式的中间代码：\nValue *UnaryExprAST::codegen() { Value *OperandV = Operand-\u0026gt;codegen(); if (!OperandV) return nullptr; Function *F = getFunction(std::string(\u0026quot;unary\u0026quot;) + Opcode); if (!F) return LogErrorV(\u0026quot;Unknown unary operator\u0026quot;); return Builder.CreateCall(F, OperandV, \u0026quot;unop\u0026quot;); }  上面的代码类似于二元表达式，但更为简单 \u0026ndash; 我们不需要为任何内建运算符做特殊处理。\n6.5 拉出来溜溜 即便是只做了上面这些小小的扩展，Kaleidoscope 现在也已经有了难以置信的表达力。俗话说，是驴子是马，拉出来溜溜。我们现在就来加入一个 \u0026ldquo;逗号运算符\u0026rdquo;(顺序执行运算符):\n printd 输出传递给它值与一个换行\n ready\u0026gt; extern printd(x); Read extern: declare double @printd(double) ready\u0026gt; def binary : 1 (x y) 0; # Low-precedence operator that ignores operands. # 它是一个忽略操作数的低优先级运算符 (因为函数参数本身就会被求值，我们只关注其副作用) ... ready\u0026gt; printd(123) : printd(456) : printd(789); 123.000000 456.000000 789.000000 Evaluated to 0.000000  我们也可以定义一系列的 \u0026ldquo;基本\u0026rdquo; 运算符如下：\n# Logical unary not. # 一元逻辑非 def unary!(v) if v then 0 else 1; # Unary negate. # 一元负号 def unary-(v) 0-v; # Define \u0026gt; with the same precedence as \u0026lt;. # 将 \u0026gt; 的优先级设为与 \u0026lt; 相同 def binary\u0026gt; 10 (LHS RHS) RHS \u0026lt; LHS; # Binary logical or, which does not short circuit. # 不短路的逻辑或 def binary| 5 (LHS RHS) if LHS then 1 else if RHS then 1 else 0; # Binary logical and, which does not short circuit. # 不短路的逻辑与 def binary\u0026amp; 6 (LHS RHS) if !LHS then 0 else !!RHS; # Define = with slightly lower precedence than relationals. # 将 = 的优先级设得比关系运算符稍低 def binary = 9 (LHS RHS) !(LHS \u0026lt; RHS | LHS \u0026gt; RHS); # Define ':' for sequencing: as a low-precedence operator that ignores operands # and just returns the RHS. # 定义用于顺序执行代码的 : 运算符，其忽略第一个参数并返回第二个参数的值。 def binary : 1 (x y) y;  有了 if/then/else 表达式的支持，我们可以定义一个有趣的 IO 函数。这个函数接受一个值，根据值的大小打印 \u0026ldquo;密度\u0026rdquo; 不同的一个字符，值越小，字符看起来越 \u0026ldquo;稀疏\u0026rdquo;：\nready\u0026gt; extern putchard(char); ... ready\u0026gt; def printdensity(d) if d \u0026gt; 8 then putchard(32) # ' ' else if d \u0026gt; 4 then putchard(46) # '.' else if d \u0026gt; 2 then putchard(43) # '+' else putchard(42); # '*' ... ready\u0026gt; printdensity(1): printdensity(2): printdensity(3): printdensity(4): printdensity(5): printdensity(9): putchard(10); **++. Evaluated to 0.000000  有了上面这些基本的工具，我们就可以开始做更有趣的事了。比如说，我们可以写出下面这个小函数，它能确定一个开始点在被函数迭代了多少次之后开始逃离原点：\n# Determine whether the specific location diverges. # Solve for z = z^2 + c in the complex plane. # 下面的函数从复平面的点 z_0 = (real, imag) 开始，计算 z_{n+1} = z_n^2 + c，然后递归迭代 # 其中 c = (creal cimag). 重复迭代多次后，如果 z_n 距离原点的距离大于 4，那么就认为那个点 \u0026quot;逃离\u0026quot; 了原点 # 随后返回迭代的次数 def mandelconverger(real imag iters creal cimag) if iters \u0026gt; 255 | (real*real + imag*imag \u0026gt; 4) then iters else mandelconverger(real*real - imag*imag + creal, 2*real*imag + cimag, iters+1, creal, cimag); # Return the number of iterations required for the iteration to escape # 包装函数，返回迭代的次数 def mandelconverge(real imag) mandelconverger(real, imag, 0, real, imag);  函数 $z_{n+1} = z_n^2 + c$ 是计算曼德博集合的基础。mandelconverge 返回一个复平面上的一个特定起始点的该函数轨迹逃离原点所需要的次数，最多为 255. 它本身没什么用处 \u0026ndash; 直到你开始用它来在二维平面上画画。即便我们只能使用 printd 来输出字符，我们也可以将各种函数组合，然后画出漂亮的密度图：\n# Compute and plot the mandelbrot set with the specified 2 dimensional range # info. # 在给定的二维区域内画出曼德博集合 def mandelhelp(xmin xmax xstep ymin ymax ystep) for y = ymin, y \u0026lt; ymax, ystep in ( (for x = xmin, x \u0026lt; xmax, xstep in printdensity(mandelconverge(x,y))) : putchard(10) ) # mandel - This is a convenient helper function for plotting the mandelbrot set # from the specified position with the specified Magnification. # 给定位置与缩放倍数，画出曼德博集合 def mandel(realstart imagstart realmag imagmag) mandelhelp(realstart, realstart+realmag*78, realmag, imagstart, imagstart+imagmag*40, imagmag);  然后我们可以像这样画出曼德博集合的密度图来：\nready\u0026gt; mandel(-2.3, -1.3, 0.05, 0.07); *******************************+++++++++++************************************* *************************+++++++++++++++++++++++******************************* **********************+++++++++++++++++++++++++++++**************************** *******************+++++++++++++++++++++.. ...++++++++************************* *****************++++++++++++++++++++++.... ...+++++++++*********************** ***************+++++++++++++++++++++++..... ...+++++++++********************* **************+++++++++++++++++++++++.... ....+++++++++******************** *************++++++++++++++++++++++...... .....++++++++******************* ************+++++++++++++++++++++....... .......+++++++****************** ***********+++++++++++++++++++.... ... .+++++++***************** **********+++++++++++++++++....... .+++++++**************** *********++++++++++++++........... ...+++++++*************** ********++++++++++++............ ...++++++++************** ********++++++++++... .......... .++++++++************** *******+++++++++..... .+++++++++************* *******++++++++...... ..+++++++++************* *******++++++....... ..+++++++++************* *******+++++...... ..+++++++++************* *******.... .... ...+++++++++************* *******.... . ...+++++++++************* *******+++++...... ...+++++++++************* *******++++++....... ..+++++++++************* *******++++++++...... .+++++++++************* *******+++++++++..... ..+++++++++************* ********++++++++++... .......... .++++++++************** ********++++++++++++............ ...++++++++************** *********++++++++++++++.......... ...+++++++*************** **********++++++++++++++++........ .+++++++**************** **********++++++++++++++++++++.... ... ..+++++++**************** ***********++++++++++++++++++++++....... .......++++++++***************** ************+++++++++++++++++++++++...... ......++++++++****************** **************+++++++++++++++++++++++.... ....++++++++******************** ***************+++++++++++++++++++++++..... ...+++++++++********************* *****************++++++++++++++++++++++.... ...++++++++*********************** *******************+++++++++++++++++++++......++++++++************************* *********************++++++++++++++++++++++.++++++++*************************** *************************+++++++++++++++++++++++******************************* ******************************+++++++++++++************************************ ******************************************************************************* ******************************************************************************* ******************************************************************************* Evaluated to 0.000000 ready\u0026gt; mandel(-2, -1, 0.02, 0.04); **************************+++++++++++++++++++++++++++++++++++++++++++++++++++++ ***********************++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *********************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++. *******************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++... *****************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++..... ***************++++++++++++++++++++++++++++++++++++++++++++++++++++++++........ **************++++++++++++++++++++++++++++++++++++++++++++++++++++++........... ************+++++++++++++++++++++++++++++++++++++++++++++++++++++.............. ***********++++++++++++++++++++++++++++++++++++++++++++++++++........ . **********++++++++++++++++++++++++++++++++++++++++++++++............. ********+++++++++++++++++++++++++++++++++++++++++++.................. *******+++++++++++++++++++++++++++++++++++++++....................... ******+++++++++++++++++++++++++++++++++++........................... *****++++++++++++++++++++++++++++++++............................ *****++++++++++++++++++++++++++++............................... ****++++++++++++++++++++++++++...... ......................... ***++++++++++++++++++++++++......... ...... ........... ***++++++++++++++++++++++............ **+++++++++++++++++++++.............. **+++++++++++++++++++................ *++++++++++++++++++................. *++++++++++++++++............ ... *++++++++++++++.............. *+++....++++................ *.......... ........... * *.......... ........... *+++....++++................ *++++++++++++++.............. *++++++++++++++++............ ... *++++++++++++++++++................. **+++++++++++++++++++................ **+++++++++++++++++++++.............. ***++++++++++++++++++++++............ ***++++++++++++++++++++++++......... ...... ........... ****++++++++++++++++++++++++++...... ......................... *****++++++++++++++++++++++++++++............................... *****++++++++++++++++++++++++++++++++............................ ******+++++++++++++++++++++++++++++++++++........................... *******+++++++++++++++++++++++++++++++++++++++....................... ********+++++++++++++++++++++++++++++++++++++++++++.................. Evaluated to 0.000000 ready\u0026gt; mandel(-0.9, -1.4, 0.02, 0.03); ******************************************************************************* ******************************************************************************* ******************************************************************************* **********+++++++++++++++++++++************************************************ *+++++++++++++++++++++++++++++++++++++++*************************************** +++++++++++++++++++++++++++++++++++++++++++++********************************** ++++++++++++++++++++++++++++++++++++++++++++++++++***************************** ++++++++++++++++++++++++++++++++++++++++++++++++++++++************************* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++********************** +++++++++++++++++++++++++++++++++.........++++++++++++++++++******************* +++++++++++++++++++++++++++++++.... ......+++++++++++++++++++**************** +++++++++++++++++++++++++++++....... ........+++++++++++++++++++************** ++++++++++++++++++++++++++++........ ........++++++++++++++++++++************ +++++++++++++++++++++++++++......... .. ...+++++++++++++++++++++********** ++++++++++++++++++++++++++........... ....++++++++++++++++++++++******** ++++++++++++++++++++++++............. .......++++++++++++++++++++++****** +++++++++++++++++++++++............. ........+++++++++++++++++++++++**** ++++++++++++++++++++++........... ..........++++++++++++++++++++++*** ++++++++++++++++++++........... .........++++++++++++++++++++++* ++++++++++++++++++............ ...........++++++++++++++++++++ ++++++++++++++++............... .............++++++++++++++++++ ++++++++++++++................. ...............++++++++++++++++ ++++++++++++.................. .................++++++++++++++ +++++++++.................. .................+++++++++++++ ++++++........ . ......... ..++++++++++++ ++............ ...... ....++++++++++ .............. ...++++++++++ .............. ....+++++++++ .............. .....++++++++ ............. ......++++++++ ........... .......++++++++ ......... ........+++++++ ......... ........+++++++ ......... ....+++++++ ........ ...+++++++ ....... ...+++++++ ....+++++++ .....+++++++ ....+++++++ ....+++++++ ....+++++++ Evaluated to 0.000000 ready\u0026gt; ^D  现在，也许你已经开始觉得 Kaleidoscope 是一门强大的、\u0026ldquo;真正的\u0026rdquo; 语言了。抛开 \u0026ldquo;自家孩子就是行\u0026rdquo; 的错觉，它居然可以用来输出这么炫酷的图案！\n本章教程到这里就结束了。我们不但扩展了我们的语言，还使其具有了通过库函数进一步扩展的能力。我们还知道了如何使用 Kaleidoscope 构建简单但有趣的用户程序。现在，Kaleidoscope 可以构建许多函数式的应用或者是调用带有副作用的函数了，但我们还不能在 Kaleidoscope 里使用变量。\n显然，变量是一项非常重要的特性，而且目前很难看出在不构造 SSA Form 的情况下于前端实现这一特性的可能。在下一章，我们将介绍如何为 Kaleidoscope 加入变量 \u0026ndash; 并且不用构造 SSA Form !\n6.6 全部代码 下面是本章例子包含的完整代码，包括了自定义运算符的支持。使用下面的命令构建这个例子：\n# Compile clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy # Run ./toy  在某些平台上，你可能需要在链接时手动加入 -rdynamic 或 -Wl,-export-dynamic 选项使得定义在程序中的符号得以被导出给动态链接器，从而使得运行时的符号解析规则能正常工作。如果你将导出给 Kaleidoscope 使用的 C++ 函数编译为动态链接库，这些选项就不是必要的 (尽管这样做也许可能会在 Windows 上出现问题).\n#include \u0026quot;../include/KaleidoscopeJIT.h\u0026quot; #include \u0026quot;llvm/ADT/APFloat.h\u0026quot; #include \u0026quot;llvm/ADT/STLExtras.h\u0026quot; #include \u0026quot;llvm/IR/BasicBlock.h\u0026quot; #include \u0026quot;llvm/IR/Constants.h\u0026quot; #include \u0026quot;llvm/IR/DerivedTypes.h\u0026quot; #include \u0026quot;llvm/IR/Function.h\u0026quot; #include \u0026quot;llvm/IR/IRBuilder.h\u0026quot; #include \u0026quot;llvm/IR/Instructions.h\u0026quot; #include \u0026quot;llvm/IR/LLVMContext.h\u0026quot; #include \u0026quot;llvm/IR/LegacyPassManager.h\u0026quot; #include \u0026quot;llvm/IR/Module.h\u0026quot; #include \u0026quot;llvm/IR/Type.h\u0026quot; #include \u0026quot;llvm/IR/Verifier.h\u0026quot; #include \u0026quot;llvm/Support/TargetSelect.h\u0026quot; #include \u0026quot;llvm/Target/TargetMachine.h\u0026quot; #include \u0026quot;llvm/Transforms/InstCombine/InstCombine.h\u0026quot; #include \u0026quot;llvm/Transforms/Scalar.h\u0026quot; #include \u0026quot;llvm/Transforms/Scalar/GVN.h\u0026quot; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace llvm; using namespace llvm::orc; //===----------------------------------------------------------------------===// // Lexer //===----------------------------------------------------------------------===// // The lexer returns tokens [0-255] if it is an unknown character, otherwise one // of these for known things. enum Token { tok_eof = -1, // commands tok_def = -2, tok_extern = -3, // primary tok_identifier = -4, tok_number = -5, // control tok_if = -6, tok_then = -7, tok_else = -8, tok_for = -9, tok_in = -10, // operators tok_binary = -11, tok_unary = -12 }; static std::string IdentifierStr; // Filled in if tok_identifier static double NumVal; // Filled in if tok_number /// gettok - Return the next token from standard input. static int gettok() { static int LastChar = ' '; // Skip any whitespace. while (isspace(LastChar)) LastChar = getchar(); if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == \u0026quot;def\u0026quot;) return tok_def; if (IdentifierStr == \u0026quot;extern\u0026quot;) return tok_extern; if (IdentifierStr == \u0026quot;if\u0026quot;) return tok_if; if (IdentifierStr == \u0026quot;then\u0026quot;) return tok_then; if (IdentifierStr == \u0026quot;else\u0026quot;) return tok_else; if (IdentifierStr == \u0026quot;for\u0026quot;) return tok_for; if (IdentifierStr == \u0026quot;in\u0026quot;) return tok_in; if (IdentifierStr == \u0026quot;binary\u0026quot;) return tok_binary; if (IdentifierStr == \u0026quot;unary\u0026quot;) return tok_unary; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), nullptr); return tok_number; } if (LastChar == '#') { // Comment until end of line. do LastChar = getchar(); while (LastChar != EOF \u0026amp;\u0026amp; LastChar != '\\n' \u0026amp;\u0026amp; LastChar != '\\r'); if (LastChar != EOF) return gettok(); } // Check for end of file. Don't eat the EOF. if (LastChar == EOF) return tok_eof; // Otherwise, just return the character as its ascii value. int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// // Abstract Syntax Tree (aka Parse Tree) //===----------------------------------------------------------------------===// namespace { /// ExprAST - Base class for all expression nodes. class ExprAST { public: virtual ~ExprAST() = default; virtual Value *codegen() = 0; }; /// NumberExprAST - Expression class for numeric literals like \u0026quot;1.0\u0026quot;. class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double Val) : Val(Val) {} Value *codegen() override; }; /// VariableExprAST - Expression class for referencing a variable, like \u0026quot;a\u0026quot;. class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string \u0026amp;Name) : Name(Name) {} Value *codegen() override; }; /// UnaryExprAST - Expression class for a unary operator. class UnaryExprAST : public ExprAST { char Opcode; std::unique_ptr\u0026lt;ExprAST\u0026gt; Operand; public: UnaryExprAST(char Opcode, std::unique_ptr\u0026lt;ExprAST\u0026gt; Operand) : Opcode(Opcode), Operand(std::move(Operand)) {} Value *codegen() override; }; /// BinaryExprAST - Expression class for a binary operator. class BinaryExprAST : public ExprAST { char Op; std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS, RHS; public: BinaryExprAST(char Op, std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS, std::unique_ptr\u0026lt;ExprAST\u0026gt; RHS) : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {} Value *codegen() override; }; /// CallExprAST - Expression class for function calls. class CallExprAST : public ExprAST { std::string Callee; std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args; public: CallExprAST(const std::string \u0026amp;Callee, std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args) : Callee(Callee), Args(std::move(Args)) {} Value *codegen() override; }; /// IfExprAST - Expression class for if/then/else. class IfExprAST : public ExprAST { std::unique_ptr\u0026lt;ExprAST\u0026gt; Cond, Then, Else; public: IfExprAST(std::unique_ptr\u0026lt;ExprAST\u0026gt; Cond, std::unique_ptr\u0026lt;ExprAST\u0026gt; Then, std::unique_ptr\u0026lt;ExprAST\u0026gt; Else) : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {} Value *codegen() override; }; /// ForExprAST - Expression class for for/in. class ForExprAST : public ExprAST { std::string VarName; std::unique_ptr\u0026lt;ExprAST\u0026gt; Start, End, Step, Body; public: ForExprAST(const std::string \u0026amp;VarName, std::unique_ptr\u0026lt;ExprAST\u0026gt; Start, std::unique_ptr\u0026lt;ExprAST\u0026gt; End, std::unique_ptr\u0026lt;ExprAST\u0026gt; Step, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : VarName(VarName), Start(std::move(Start)), End(std::move(End)), Step(std::move(Step)), Body(std::move(Body)) {} Value *codegen() override; }; /// PrototypeAST - This class represents the \u0026quot;prototype\u0026quot; for a function, /// which captures its name, and its argument names (thus implicitly the number /// of arguments the function takes), as well as if it is an operator. class PrototypeAST { std::string Name; std::vector\u0026lt;std::string\u0026gt; Args; bool IsOperator; unsigned Precedence; // Precedence if a binary op. public: PrototypeAST(const std::string \u0026amp;Name, std::vector\u0026lt;std::string\u0026gt; Args, bool IsOperator = false, unsigned Prec = 0) : Name(Name), Args(std::move(Args)), IsOperator(IsOperator), Precedence(Prec) {} Function *codegen(); const std::string \u0026amp;getName() const { return Name; } bool isUnaryOp() const { return IsOperator \u0026amp;\u0026amp; Args.size() == 1; } bool isBinaryOp() const { return IsOperator \u0026amp;\u0026amp; Args.size() == 2; } char getOperatorName() const { assert(isUnaryOp() || isBinaryOp()); return Name[Name.size() - 1]; } unsigned getBinaryPrecedence() const { return Precedence; } }; /// FunctionAST - This class represents a function definition itself. class FunctionAST { std::unique_ptr\u0026lt;PrototypeAST\u0026gt; Proto; std::unique_ptr\u0026lt;ExprAST\u0026gt; Body; public: FunctionAST(std::unique_ptr\u0026lt;PrototypeAST\u0026gt; Proto, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : Proto(std::move(Proto)), Body(std::move(Body)) {} Function *codegen(); }; } // end anonymous namespace //===----------------------------------------------------------------------===// // Parser //===----------------------------------------------------------------------===// /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current /// token the parser is looking at. getNextToken reads another token from the /// lexer and updates CurTok with its results. static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence - This holds the precedence for each binary operator that is /// defined. static std::map\u0026lt;char, int\u0026gt; BinopPrecedence; /// GetTokPrecedence - Get the precedence of the pending binary operator token. static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // Make sure it's a declared binop. int TokPrec = BinopPrecedence[CurTok]; if (TokPrec \u0026lt;= 0) return -1; return TokPrec; } /// Error* - These are little helper functions for error handling. std::unique_ptr\u0026lt;ExprAST\u0026gt; LogError(const char *Str) { fprintf(stderr, \u0026quot;Error: %s\\n\u0026quot;, Str); return nullptr; } std::unique_ptr\u0026lt;PrototypeAST\u0026gt; LogErrorP(const char *Str) { LogError(Str); return nullptr; } static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseExpression(); /// numberexpr ::= number static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseNumberExpr() { auto Result = std::make_unique\u0026lt;NumberExprAST\u0026gt;(NumVal); getNextToken(); // consume the number return std::move(Result); } /// parenexpr ::= '(' expression ')' static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseParenExpr() { getNextToken(); // eat (. auto V = ParseExpression(); if (!V) return nullptr; if (CurTok != ')') return LogError(\u0026quot;expected ')'\u0026quot;); getNextToken(); // eat ). return V; } /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref. return std::make_unique\u0026lt;VariableExprAST\u0026gt;(IdName); // Call. getNextToken(); // eat ( std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args; if (CurTok != ')') { while (true) { if (auto Arg = ParseExpression()) Args.push_back(std::move(Arg)); else return nullptr; if (CurTok == ')') break; if (CurTok != ',') return LogError(\u0026quot;Expected ')' or ',' in argument list\u0026quot;); getNextToken(); } } // Eat the ')'. getNextToken(); return std::make_unique\u0026lt;CallExprAST\u0026gt;(IdName, std::move(Args)); } /// ifexpr ::= 'if' expression 'then' expression 'else' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseIfExpr() { getNextToken(); // eat the if. // condition. auto Cond = ParseExpression(); if (!Cond) return nullptr; if (CurTok != tok_then) return LogError(\u0026quot;expected then\u0026quot;); getNextToken(); // eat the then auto Then = ParseExpression(); if (!Then) return nullptr; if (CurTok != tok_else) return LogError(\u0026quot;expected else\u0026quot;); getNextToken(); auto Else = ParseExpression(); if (!Else) return nullptr; return std::make_unique\u0026lt;IfExprAST\u0026gt;(std::move(Cond), std::move(Then), std::move(Else)); } /// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseForExpr() { getNextToken(); // eat the for. if (CurTok != tok_identifier) return LogError(\u0026quot;expected identifier after for\u0026quot;); std::string IdName = IdentifierStr; getNextToken(); // eat identifier. if (CurTok != '=') return LogError(\u0026quot;expected '=' after for\u0026quot;); getNextToken(); // eat '='. auto Start = ParseExpression(); if (!Start) return nullptr; if (CurTok != ',') return LogError(\u0026quot;expected ',' after for start value\u0026quot;); getNextToken(); auto End = ParseExpression(); if (!End) return nullptr; // The step value is optional. std::unique_ptr\u0026lt;ExprAST\u0026gt; Step; if (CurTok == ',') { getNextToken(); Step = ParseExpression(); if (!Step) return nullptr; } if (CurTok != tok_in) return LogError(\u0026quot;expected 'in' after for\u0026quot;); getNextToken(); // eat 'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return std::make_unique\u0026lt;ForExprAST\u0026gt;(IdName, std::move(Start), std::move(End), std::move(Step), std::move(Body)); } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr /// ::= ifexpr /// ::= forexpr static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParsePrimary() { switch (CurTok) { default: return LogError(\u0026quot;unknown token when expecting an expression\u0026quot;); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); } } /// unary /// ::= primary /// ::= '!' unary static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseUnary() { // If the current token is not an operator, it must be a primary expr. if (!isascii(CurTok) || CurTok == '(' || CurTok == ',') return ParsePrimary(); // If this is a unary operator, read it. int Opc = CurTok; getNextToken(); if (auto Operand = ParseUnary()) return std::make_unique\u0026lt;UnaryExprAST\u0026gt;(Opc, std::move(Operand)); return nullptr; } /// binoprhs /// ::= ('+' unary)* static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseBinOpRHS(int ExprPrec, std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS) { // If this is a binop, find its precedence. while (true) { int TokPrec = GetTokPrecedence(); // If this is a binop that binds at least as tightly as the current binop, // consume it, otherwise we are done. if (TokPrec \u0026lt; ExprPrec) return LHS; // Okay, we know this is a binop. int BinOp = CurTok; getNextToken(); // eat binop // Parse the unary expression after the binary operator. auto RHS = ParseUnary(); if (!RHS) return nullptr; // If BinOp binds less tightly with RHS than the operator after RHS, let // the pending operator take RHS as its LHS. int NextPrec = GetTokPrecedence(); if (TokPrec \u0026lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS)); if (!RHS) return nullptr; } // Merge LHS/RHS. LHS = std::make_unique\u0026lt;BinaryExprAST\u0026gt;(BinOp, std::move(LHS), std::move(RHS)); } } /// expression /// ::= unary binoprhs /// static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseExpression() { auto LHS = ParseUnary(); if (!LHS) return nullptr; return ParseBinOpRHS(0, std::move(LHS)); } /// prototype /// ::= id '(' id* ')' /// ::= binary LETTER number? (id, id) /// ::= unary LETTER (id) static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParsePrototype() { std::string FnName; unsigned Kind = 0; // 0 = identifier, 1 = unary, 2 = binary. unsigned BinaryPrecedence = 30; switch (CurTok) { default: return LogErrorP(\u0026quot;Expected function name in prototype\u0026quot;); case tok_identifier: FnName = IdentifierStr; Kind = 0; getNextToken(); break; case tok_unary: getNextToken(); if (!isascii(CurTok)) return LogErrorP(\u0026quot;Expected unary operator\u0026quot;); FnName = \u0026quot;unary\u0026quot;; FnName += (char)CurTok; Kind = 1; getNextToken(); break; case tok_binary: getNextToken(); if (!isascii(CurTok)) return LogErrorP(\u0026quot;Expected binary operator\u0026quot;); FnName = \u0026quot;binary\u0026quot;; FnName += (char)CurTok; Kind = 2; getNextToken(); // Read the precedence if present. if (CurTok == tok_number) { if (NumVal \u0026lt; 1 || NumVal \u0026gt; 100) return LogErrorP(\u0026quot;Invalid precedence: must be 1..100\u0026quot;); BinaryPrecedence = (unsigned)NumVal; getNextToken(); } break; } if (CurTok != '(') return LogErrorP(\u0026quot;Expected '(' in prototype\u0026quot;); std::vector\u0026lt;std::string\u0026gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return LogErrorP(\u0026quot;Expected ')' in prototype\u0026quot;); // success. getNextToken(); // eat ')'. // Verify right number of names for operator. if (Kind \u0026amp;\u0026amp; ArgNames.size() != Kind) return LogErrorP(\u0026quot;Invalid number of operands for operator\u0026quot;); return std::make_unique\u0026lt;PrototypeAST\u0026gt;(FnName, ArgNames, Kind != 0, BinaryPrecedence); } /// definition ::= 'def' prototype expression static std::unique_ptr\u0026lt;FunctionAST\u0026gt; ParseDefinition() { getNextToken(); // eat def. auto Proto = ParsePrototype(); if (!Proto) return nullptr; if (auto E = ParseExpression()) return std::make_unique\u0026lt;FunctionAST\u0026gt;(std::move(Proto), std::move(E)); return nullptr; } /// toplevelexpr ::= expression static std::unique_ptr\u0026lt;FunctionAST\u0026gt; ParseTopLevelExpr() { if (auto E = ParseExpression()) { // Make an anonymous proto. auto Proto = std::make_unique\u0026lt;PrototypeAST\u0026gt;(\u0026quot;__anon_expr\u0026quot;, std::vector\u0026lt;std::string\u0026gt;()); return std::make_unique\u0026lt;FunctionAST\u0026gt;(std::move(Proto), std::move(E)); } return nullptr; } /// external ::= 'extern' prototype static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParseExtern() { getNextToken(); // eat extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// // Code Generation //===----------------------------------------------------------------------===// static std::unique_ptr\u0026lt;LLVMContext\u0026gt; TheContext; static std::unique_ptr\u0026lt;Module\u0026gt; TheModule; static std::unique_ptr\u0026lt;IRBuilder\u0026lt;\u0026gt;\u0026gt; Builder; static std::map\u0026lt;std::string, Value *\u0026gt; NamedValues; static std::unique_ptr\u0026lt;legacy::FunctionPassManager\u0026gt; TheFPM; static std::unique_ptr\u0026lt;KaleidoscopeJIT\u0026gt; TheJIT; static std::map\u0026lt;std::string, std::unique_ptr\u0026lt;PrototypeAST\u0026gt;\u0026gt; FunctionProtos; static ExitOnError ExitOnErr; Value *LogErrorV(const char *Str) { LogError(Str); return nullptr; } Function *getFunction(std::string Name) { // First, see if the function has already been added to the current module. if (auto *F = TheModule-\u0026gt;getFunction(Name)) return F; // If not, check whether we can codegen the declaration from some existing // prototype. auto FI = FunctionProtos.find(Name); if (FI != FunctionProtos.end()) return FI-\u0026gt;second-\u0026gt;codegen(); // If no existing prototype exists, return null. return nullptr; } Value *NumberExprAST::codegen() { return ConstantFP::get(*TheContext, APFloat(Val)); } Value *VariableExprAST::codegen() { // Look this variable up in the function. Value *V = NamedValues[Name]; if (!V) return LogErrorV(\u0026quot;Unknown variable name\u0026quot;); return V; } Value *UnaryExprAST::codegen() { Value *OperandV = Operand-\u0026gt;codegen(); if (!OperandV) return nullptr; Function *F = getFunction(std::string(\u0026quot;unary\u0026quot;) + Opcode); if (!F) return LogErrorV(\u0026quot;Unknown unary operator\u0026quot;); return Builder-\u0026gt;CreateCall(F, OperandV, \u0026quot;unop\u0026quot;); } Value *BinaryExprAST::codegen() { Value *L = LHS-\u0026gt;codegen(); Value *R = RHS-\u0026gt;codegen(); if (!L || !R) return nullptr; switch (Op) { case '+': return Builder-\u0026gt;CreateFAdd(L, R, \u0026quot;addtmp\u0026quot;); case '-': return Builder-\u0026gt;CreateFSub(L, R, \u0026quot;subtmp\u0026quot;); case '*': return Builder-\u0026gt;CreateFMul(L, R, \u0026quot;multmp\u0026quot;); case '\u0026lt;': L = Builder-\u0026gt;CreateFCmpULT(L, R, \u0026quot;cmptmp\u0026quot;); // Convert bool 0/1 to double 0.0 or 1.0 return Builder-\u0026gt;CreateUIToFP(L, Type::getDoubleTy(*TheContext), \u0026quot;booltmp\u0026quot;); default: break; } // If it wasn't a builtin binary operator, it must be a user defined one. Emit // a call to it. Function *F = getFunction(std::string(\u0026quot;binary\u0026quot;) + Op); assert(F \u0026amp;\u0026amp; \u0026quot;binary operator not found!\u0026quot;); Value *Ops[] = {L, R}; return Builder-\u0026gt;CreateCall(F, Ops, \u0026quot;binop\u0026quot;); } Value *CallExprAST::codegen() { // Look up the name in the global module table. Function *CalleeF = getFunction(Callee); if (!CalleeF) return LogErrorV(\u0026quot;Unknown function referenced\u0026quot;); // If argument mismatch error. if (CalleeF-\u0026gt;arg_size() != Args.size()) return LogErrorV(\u0026quot;Incorrect # arguments passed\u0026quot;); std::vector\u0026lt;Value *\u0026gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-\u0026gt;codegen()); if (!ArgsV.back()) return nullptr; } return Builder-\u0026gt;CreateCall(CalleeF, ArgsV, \u0026quot;calltmp\u0026quot;); } Value *IfExprAST::codegen() { Value *CondV = Cond-\u0026gt;codegen(); if (!CondV) return nullptr; // Convert condition to a bool by comparing non-equal to 0.0. CondV = Builder-\u0026gt;CreateFCmpONE( CondV, ConstantFP::get(*TheContext, APFloat(0.0)), \u0026quot;ifcond\u0026quot;); Function *TheFunction = Builder-\u0026gt;GetInsertBlock()-\u0026gt;getParent(); // Create blocks for the then and else cases. Insert the 'then' block at the // end of the function. BasicBlock *ThenBB = BasicBlock::Create(*TheContext, \u0026quot;then\u0026quot;, TheFunction); BasicBlock *ElseBB = BasicBlock::Create(*TheContext, \u0026quot;else\u0026quot;); BasicBlock *MergeBB = BasicBlock::Create(*TheContext, \u0026quot;ifcont\u0026quot;); Builder-\u0026gt;CreateCondBr(CondV, ThenBB, ElseBB); // Emit then value. Builder-\u0026gt;SetInsertPoint(ThenBB); Value *ThenV = Then-\u0026gt;codegen(); if (!ThenV) return nullptr; Builder-\u0026gt;CreateBr(MergeBB); // Codegen of 'Then' can change the current block, update ThenBB for the PHI. ThenBB = Builder-\u0026gt;GetInsertBlock(); // Emit else block. TheFunction-\u0026gt;getBasicBlockList().push_back(ElseBB); Builder-\u0026gt;SetInsertPoint(ElseBB); Value *ElseV = Else-\u0026gt;codegen(); if (!ElseV) return nullptr; Builder-\u0026gt;CreateBr(MergeBB); // Codegen of 'Else' can change the current block, update ElseBB for the PHI. ElseBB = Builder-\u0026gt;GetInsertBlock(); // Emit merge block. TheFunction-\u0026gt;getBasicBlockList().push_back(MergeBB); Builder-\u0026gt;SetInsertPoint(MergeBB); PHINode *PN = Builder-\u0026gt;CreatePHI(Type::getDoubleTy(*TheContext), 2, \u0026quot;iftmp\u0026quot;); PN-\u0026gt;addIncoming(ThenV, ThenBB); PN-\u0026gt;addIncoming(ElseV, ElseBB); return PN; } // Output for-loop as: // ... // start = startexpr // goto loop // loop: // variable = phi [start, loopheader], [nextvariable, loopend] // ... // bodyexpr // ... // loopend: // step = stepexpr // nextvariable = variable + step // endcond = endexpr // br endcond, loop, endloop // outloop: Value *ForExprAST::codegen() { // Emit the start code first, without 'variable' in scope. Value *StartVal = Start-\u0026gt;codegen(); if (!StartVal) return nullptr; // Make the new basic block for the loop header, inserting after current // block. Function *TheFunction = Builder-\u0026gt;GetInsertBlock()-\u0026gt;getParent(); BasicBlock *PreheaderBB = Builder-\u0026gt;GetInsertBlock(); BasicBlock *LoopBB = BasicBlock::Create(*TheContext, \u0026quot;loop\u0026quot;, TheFunction); // Insert an explicit fall through from the current block to the LoopBB. Builder-\u0026gt;CreateBr(LoopBB); // Start insertion in LoopBB. Builder-\u0026gt;SetInsertPoint(LoopBB); // Start the PHI node with an entry for Start. PHINode *Variable = Builder-\u0026gt;CreatePHI(Type::getDoubleTy(*TheContext), 2, VarName); Variable-\u0026gt;addIncoming(StartVal, PreheaderBB); // Within the loop, the variable is defined equal to the PHI node. If it // shadows an existing variable, we have to restore it, so save it now. Value *OldVal = NamedValues[VarName]; NamedValues[VarName] = Variable; // Emit the body of the loop. This, like any other expr, can change the // current BB. Note that we ignore the value computed by the body, but don't // allow an error. if (!Body-\u0026gt;codegen()) return nullptr; // Emit the step value. Value *StepVal = nullptr; if (Step) { StepVal = Step-\u0026gt;codegen(); if (!StepVal) return nullptr; } else { // If not specified, use 1.0. StepVal = ConstantFP::get(*TheContext, APFloat(1.0)); } Value *NextVar = Builder-\u0026gt;CreateFAdd(Variable, StepVal, \u0026quot;nextvar\u0026quot;); // Compute the end condition. Value *EndCond = End-\u0026gt;codegen(); if (!EndCond) return nullptr; // Convert condition to a bool by comparing non-equal to 0.0. EndCond = Builder-\u0026gt;CreateFCmpONE( EndCond, ConstantFP::get(*TheContext, APFloat(0.0)), \u0026quot;loopcond\u0026quot;); // Create the \u0026quot;after loop\u0026quot; block and insert it. BasicBlock *LoopEndBB = Builder-\u0026gt;GetInsertBlock(); BasicBlock *AfterBB = BasicBlock::Create(*TheContext, \u0026quot;afterloop\u0026quot;, TheFunction); // Insert the conditional branch into the end of LoopEndBB. Builder-\u0026gt;CreateCondBr(EndCond, LoopBB, AfterBB); // Any new code will be inserted in AfterBB. Builder-\u0026gt;SetInsertPoint(AfterBB); // Add a new entry to the PHI node for the backedge. Variable-\u0026gt;addIncoming(NextVar, LoopEndBB); // Restore the unshadowed variable. if (OldVal) NamedValues[VarName] = OldVal; else NamedValues.erase(VarName); // for expr always returns 0.0. return Constant::getNullValue(Type::getDoubleTy(*TheContext)); } Function *PrototypeAST::codegen() { // Make the function type: double(double,double) etc. std::vector\u0026lt;Type *\u0026gt; Doubles(Args.size(), Type::getDoubleTy(*TheContext)); FunctionType *FT = FunctionType::get(Type::getDoubleTy(*TheContext), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get()); // Set names for all arguments. unsigned Idx = 0; for (auto \u0026amp;Arg : F-\u0026gt;args()) Arg.setName(Args[Idx++]); return F; } Function *FunctionAST::codegen() { // Transfer ownership of the prototype to the FunctionProtos map, but keep a // reference to it for use below. auto \u0026amp;P = *Proto; FunctionProtos[Proto-\u0026gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr; // If this is an operator, install it. if (P.isBinaryOp()) BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence(); // Create a new basic block to start insertion into. BasicBlock *BB = BasicBlock::Create(*TheContext, \u0026quot;entry\u0026quot;, TheFunction); Builder-\u0026gt;SetInsertPoint(BB); // Record the function arguments in the NamedValues map. NamedValues.clear(); for (auto \u0026amp;Arg : TheFunction-\u0026gt;args()) NamedValues[std::string(Arg.getName())] = \u0026amp;Arg; if (Value *RetVal = Body-\u0026gt;codegen()) { // Finish off the function. Builder-\u0026gt;CreateRet(RetVal); // Validate the generated code, checking for consistency. verifyFunction(*TheFunction); // Run the optimizer on the function. TheFPM-\u0026gt;run(*TheFunction); return TheFunction; } // Error reading body, remove function. TheFunction-\u0026gt;eraseFromParent(); if (P.isBinaryOp()) BinopPrecedence.erase(P.getOperatorName()); return nullptr; } //===----------------------------------------------------------------------===// // Top-Level parsing and JIT Driver //===----------------------------------------------------------------------===// static void InitializeModuleAndPassManager() { // Open a new module. TheContext = std::make_unique\u0026lt;LLVMContext\u0026gt;(); TheModule = std::make_unique\u0026lt;Module\u0026gt;(\u0026quot;my cool jit\u0026quot;, *TheContext); TheModule-\u0026gt;setDataLayout(TheJIT-\u0026gt;getDataLayout()); // Create a new builder for the module. Builder = std::make_unique\u0026lt;IRBuilder\u0026lt;\u0026gt;\u0026gt;(*TheContext); // Create a new pass manager attached to it. TheFPM = std::make_unique\u0026lt;legacy::FunctionPassManager\u0026gt;(TheModule.get()); // Do simple \u0026quot;peephole\u0026quot; optimizations and bit-twiddling optzns. TheFPM-\u0026gt;add(createInstructionCombiningPass()); // Reassociate expressions. TheFPM-\u0026gt;add(createReassociatePass()); // Eliminate Common SubExpressions. TheFPM-\u0026gt;add(createGVNPass()); // Simplify the control flow graph (deleting unreachable blocks, etc). TheFPM-\u0026gt;add(createCFGSimplificationPass()); TheFPM-\u0026gt;doInitialization(); } static void HandleDefinition() { if (auto FnAST = ParseDefinition()) { if (auto *FnIR = FnAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read function definition:\u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); ExitOnErr(TheJIT-\u0026gt;addModule( ThreadSafeModule(std::move(TheModule), std::move(TheContext)))); InitializeModuleAndPassManager(); } } else { // Skip token for error recovery. getNextToken(); } } static void HandleExtern() { if (auto ProtoAST = ParseExtern()) { if (auto *FnIR = ProtoAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read extern: \u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); FunctionProtos[ProtoAST-\u0026gt;getName()] = std::move(ProtoAST); } } else { // Skip token for error recovery. getNextToken(); } } static void HandleTopLevelExpression() { // Evaluate a top-level expression into an anonymous function. if (auto FnAST = ParseTopLevelExpr()) { if (FnAST-\u0026gt;codegen()) { // Create a ResourceTracker to track JIT'd memory allocated to our // anonymous expression -- that way we can free it after executing. auto RT = TheJIT-\u0026gt;getMainJITDylib().createResourceTracker(); auto TSM = ThreadSafeModule(std::move(TheModule), std::move(TheContext)); ExitOnErr(TheJIT-\u0026gt;addModule(std::move(TSM), RT)); InitializeModuleAndPassManager(); // Search the JIT for the __anon_expr symbol. auto ExprSymbol = ExitOnErr(TheJIT-\u0026gt;lookup(\u0026quot;__anon_expr\u0026quot;)); // Get the symbol's address and cast it to the right type (takes no // arguments, returns a double) so we can call it as a native function. double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress(); fprintf(stderr, \u0026quot;Evaluated to %f\\n\u0026quot;, FP()); // Delete the anonymous expression module from the JIT. ExitOnErr(RT-\u0026gt;remove()); } } else { // Skip token for error recovery. getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (true) { fprintf(stderr, \u0026quot;ready\u0026gt; \u0026quot;); switch (CurTok) { case tok_eof: return; case ';': // ignore top-level semicolons. getNextToken(); break; case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // \u0026quot;Library\u0026quot; functions that can be \u0026quot;extern'd\u0026quot; from user code. //===----------------------------------------------------------------------===// #ifdef _WIN32 #define DLLEXPORT __declspec(dllexport) #else #define DLLEXPORT #endif /// putchard - putchar that takes a double and returns 0. extern \u0026quot;C\u0026quot; DLLEXPORT double putchard(double X) { fputc((char)X, stderr); return 0; } /// printd - printf that takes a double prints it as \u0026quot;%f\\n\u0026quot;, returning 0. extern \u0026quot;C\u0026quot; DLLEXPORT double printd(double X) { fprintf(stderr, \u0026quot;%f\\n\u0026quot;, X); return 0; } //===----------------------------------------------------------------------===// // Main driver code. //===----------------------------------------------------------------------===// int main() { InitializeNativeTarget(); InitializeNativeTargetAsmPrinter(); InitializeNativeTargetAsmParser(); // Install standard binary operators. // 1 is lowest precedence. BinopPrecedence['\u0026lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; // highest. // Prime the first token. fprintf(stderr, \u0026quot;ready\u0026gt; \u0026quot;); getNextToken(); TheJIT = ExitOnErr(KaleidoscopeJIT::Create()); InitializeModuleAndPassManager(); // Run the main \u0026quot;interpreter loop\u0026quot; now. MainLoop(); return 0; } ","date":"2022-01-17","permalink":"https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-6/","tags":["编译原理","编译前端","LLVM","翻译"],"title":"LLVM Kaleidoscope 第 6 章：扩展语言：自定义运算符"},{"content":"本教程原文于 LLVM Tutorial.\n网上现见有一些翻译：\n 连城 翻译的：用 LLVM 开发新语言: 比较老，里面的警告还是在警告 LLVM 2.7 版的，而且只有前三章，但其翻译被众多网友引用。 LLVM 中文网 翻译的：LLVM 开发新语言: 翻译来源不能确定，并且同样只有前三章 + 第四章开头。  作为一个编译技术的入门菜鸟，我很感谢上面这些 (以及千千万万的) 无私付出的翻译者。\n鄙人最近又开始了学习编译技术的学习，在学习之余，也想为社区做一份贡献。于是我斗胆尝试翻译一下本篇教程，重点在之前译者没有翻译的章节上，尽量保证在今年 4 月前翻译完成整个教程。\n因本人水平有限，如有错误，请多多指正、包涵。如有勘误，欢迎提出 issue/pr 于此 仓库. 也可以直接联系本人 Origami404 at foxmail.com\n本翻译同时也发布在 HITsz LUG wiki 上.\n本翻译使用 CC BY-NC-SA 4.0 协议发布到公共领域.\n目录位于 这里.\n","date":"2022-01-15","permalink":"https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch--1/","tags":["编译原理","编译前端","LLVM","翻译"],"title":"LLVM Kaleidoscope 第 -1 章 翻译者的话"},{"content":"前置技能： 本教程要求你有 C++ 基础，但你并不需要先去做一个编译器再来看这个教程。\n欢迎来到“我的第一个基于 LLVM 的语言前端”教程。在本教程我们将会自己动手实现一个简单的语言，你将会看到这有多简单以及有趣。在接下来的教程里，你将会快速而确切地学习到使用 LLVM 来生成程序的方法。\n本教程引入了一门简单的叫 Kaleidoscope(万花筒) 的语言。在接下来的几章内，我们将会一步步向你展示构建它的过程。在这个过程中我们会介绍一系列的语言设计与 LLVM 思想，给予你实现这门语言的程序的详细代码，并尽量减少各种各样的细节。我们强烈建议你跟着教程一起动手，在我们给予的代码的基础上去 hack，去实验，去探索新的可能。\n警告： 为了专注于教授编译技术与 LLVM，本教程 不会 展示最佳的工程实践代码。比如说，我们的代码将会到处全局变量，并且不使用访问者模式 (来从 AST 生成代码/干其他活). 这种风格有助于我们保持代码简单并且专注于主题。\n本教程分为以下几章，分别介绍了不同领域的内容。如果你想跳过某些章节的话，请随意：\n 译者注：每章的最后有直到本章为止的全部代码，可以直接去复制一下然后跳到下一章\n  第一章: Kaleidoscope 与 lexer (未翻译): 本章介绍了我们要实现的语言 Kaleidoscope 的基础功能。构建 lexer 是构建一门语言的 parser 的第一步，我们将手写一个简单易懂的 C++ lexer. 第二章：实现 Parser 与 AST (未翻译): 有了 lexer，我们就可以着手于解析技术与简单的 AST 构建了。本章描述了递归下降解析法与运算符优先级解析法 (operator-precedence parsing). 第三章：生成 LLVM IR (未翻译): 一旦有了 AST，生成 LLVM IR 就不在话下了。在本章我们将会讨论从 AST 生成 IR 的方法，与此同时你也能学习到将 LLVM 集成进你的项目里的一个简单方法。 第四章：增加 JIT 与优化: LLVM 的一个优势在于它支持 JIT 编译，所以我们稍微深入地去介绍一下这项技术。有了 LLVM，仅需 3 行代码就能使你的语言具有 JIT 功能！在后续章节中我们将会介绍如何生成目标文件。 第五章：扩展语言：控制流: 现在我们有了一个能跑的语言了！我们将会给它加上控制流操作符 (if 与 for). 我们也将趁此机会介绍 SSA 构造与控制流。 第六章：扩展语言：自定义运算符: 本章扩展了语言，使用户能自定义他们自己的一元与二元操作符 \u0026ndash; 包括其优先级！这将允许我们将显著规模的 \u0026ldquo;语言特性\u0026rdquo; 改为由基本库实现。 第七章：扩展语言：变量: 本章将介绍如何为语言增加用户定义的局部变量与赋值运算符。这也将会展示出在 LLVM 里构造 SSA Form 的简单 \u0026ndash; 使用 LLVM 并 不 要求前端直接生成 SSA Form! 第八章：编译到目标文件: 本章解释了如何像普通的编译器一样生成目标文件 \u0026ndash; 产生 LLVM IR 并将其编译到目标文件。 第九章：调试信息 (未翻译): 一门实用的语言需要支持调试器，所以我们要给 Kaleidoscope 增加在函数内设置断点、打印参数、调用函数的能力！ 第十章：结语与其他 (未翻译): 本章讨论扩展语言的不同方式，借此串联起整个教程。本章还包括了指向特定主题的\u0026quot;指针\u0026quot;, 比如 GC，异常，调试与对 \u0026ldquo;意大利面条式调用栈 (spaghetti stacks)\u0026rdquo; 的支持。  当教程介绍后，我们将写出大概 1000 行少一点的代码 (不计空白与注释). 仅仅是使用这么少的代码，我们就能实现一个不平凡的语言的编译器，包括了一个手写的 lexer, parser, AST 与代码生成 \u0026ndash; 同时支持 JIT 与静态代码生成！这一千行代码所实现的广泛功能只是 LLVM 力量的冰山一角 \u0026ndash; 这正是 LLVM 在语言设计者与优化者里如此流行的原因。\n","date":"2022-01-15","permalink":"https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-0/","tags":["编译原理","编译前端","LLVM","翻译"],"title":"LLVM Kaleidoscope 第 0 章 我的第一个基于 LLVM 的语言前端"},{"content":"暂未翻译，敬请参阅连城大佬的译文.\n 译文较老，请与原文对比以确保自己的代码是更新之后的。\n  本教程其他翻译将基于新版本教程。\n 下一章在此。\n","date":"2022-01-15","permalink":"https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-1/","tags":["编译原理","编译前端","LLVM","翻译"],"title":"LLVM Kaleidoscope 第 1 章 Kaleidoscope 与 lexer"},{"content":"暂未翻译，敬请参阅连城大佬的译文.\n 译文较老，请与原文对比以确保自己的代码是更新之后的。\n  本教程其他翻译将基于新版本教程。\n 下一章在此。\n","date":"2022-01-15","permalink":"https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-2/","tags":["编译原理","编译前端","LLVM","翻译"],"title":"LLVM Kaleidoscope 第 2 章 实现 Parser 与 AST"},{"content":"暂未翻译，敬请参阅连城大佬的译文.\n 译文较老，请与原文对比以确保自己的代码是更新之后的。\n  本教程其他翻译将基于新版本教程。\n 下一章在此。\n","date":"2022-01-15","permalink":"https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-3/","tags":["编译原理","编译前端","LLVM","翻译"],"title":"LLVM Kaleidoscope 第 3 章 生成 LLVM IR"},{"content":"4.1 前言 欢迎来到 我的第一个基于 LLVM 的语言前端 教程第四章。前三章描述了一门简单语言的实现与生成 LLVM IR 的过程，而本章将要描述两种新技术 \u0026ndash; 增加优化器 (optimizer) 与 JIT 编译器支持 \u0026ndash; 它们将会告诉你如何生成优雅高效的中间代码。\n4.2 平凡的常数折叠 我们在第三章的实现非常优雅，且易于扩展。但美中不足的是，它并不会生成很好的中间代码。虽然 IRBuilder 在我们编译简单的代码的时候确实为我们做了一些显然的优化：\nready\u0026gt; def test(x) 1+2+x; Read function definition: define double @test(double %x) { entry: %addtmp = fadd double 3.000000e+00, %x ret double %addtmp }  上面的中间代码并不是解析出的 AST 的简单翻译 \u0026ndash; 它并不是下面这样：\nready\u0026gt; def test(x) 1+2+x; Read function definition: define double @test(double %x) { entry: %addtmp = fadd double 2.000000e+00, 1.000000e+00 %addtmp1 = fadd double %addtmp, %x ret double %addtmp1 }  正如你所见，常数折叠 (Constant folding) 在实践中是一项非常普遍并且重要的优化：许多语言实现者直接在 AST 构建中就实现了常数折叠优化。\n有了 LLVM，你就不必直接在 AST 中支持它了。因为构造 LLVM IR 的所有调用都经过了 IRBuilder, 所以 IRBuilder 便能自行确定它是否有进行常数折叠优化的可能。如果可能，它就直接折叠并且返回那个常数，而不是创建新的指令。\n好吧，上面的优化是很简单的 :). 实践中，我们建议你总是使用 IRBuilder 来生成中间代码。以它来实现常数折叠可以避免在 AST 构造的代码中引入过多的 \u0026ldquo;语法杂音\u0026rdquo; (你肯定不希望你的编译器里到处都是丑陋的常数判断！), 并且 IRBuilder 在特定情况下可以令人惊叹地减少要生成的 IR 数量 (特别是对那些有预处理宏的或者是大量使用常量的语言而言).\n另一方面，IRBuilder 只能分析它当下那一条指令，如果你使用下面这个复杂一点的例子：\nready\u0026gt; def test(x) (1+2+x)*(x+(1+2)); ready\u0026gt; Read function definition: define double @test(double %x) { entry: %addtmp = fadd double 3.000000e+00, %x %addtmp1 = fadd double %x, 3.000000e+00 %multmp = fmul double %addtmp, %addtmp1 ret double %multmp }  在这种情况下，我们可以看到乘法的左右子表达式是相同的。比起计算 x+3 两次，我们更想看见我们的编译器生成 tmp = x+3; result = tmp * tmp 这样的代码。\n不幸的是，没有任何一种 (指令层面的) 局部分析可以检测并优化这种情况。我们至少需要两种变换才能消除冗余的加法指令：重新关联表达式 (以便使加法在词法上等同) 与公共子表达式消除 (Common Subexpression Elimination, CSE). 幸运的是，LLVM 以 \u0026ldquo;pass\u0026rdquo; 的形式提供了广泛的优化选择。\n4.3 LLVM 优化过程 (pass)  Warning: 因为 PassManager 正转向新架构，本教程使用的 PassManager 将会基于 LegacyPassManager.h 中的 llvm::legacy::FunctionPassManager. 基于教程的目的，老的 PassManager 将被继续使用直到新 PassManager 彻底转向新架构为止。\n LLVM 提供了许多优化过程，它们都有不同的作用，也有不一样的折中。LLVM 并不会奢望某一套特定的优化可以适用于所有语言的所有情况，所以它允许编译器实现者来完全决定要在何处以何种顺序使用何种特定优化。\n作为一个具体的例子，LLVM 既支持 \u0026ldquo;全模块\u0026rdquo; 优化过程 (\u0026ldquo;whole module\u0026rdquo; passes) \u0026ndash; 这种过程可以搜集一大块中间代码的信息 (一般而言，这指一整份代码文件; 但如果此种优化在链接时发生，其包含代码的范围可能是一整个程序的一大部分), 也支持函数内优化过程 (\u0026ldquo;per-function\u0026rdquo; passes) \u0026ndash; 这种过程专注于单个函数内部的优化。如果你对优化过程的细节与运行方式很感兴趣，请查阅 How to Write a Pass 与 List of LLVM Passes.\n对 Kaleidoscope 而言，我们现在只能动态地一个一个在用户输入的时候生成函数的中间代码，我们不会指望在这种情况下获得最好的优化体验，但至少我们希望我们的编译器可以执行一些快速简单的可能优化。所以，当用户键入函数时，我们将只执行一小些函数内优化过程。如果我们想要创造一个 \u0026ldquo;静态 Kaleidoscope 编译器\u0026rdquo;, 我们将会拥有整份我们将要编译的代码的信息，在那时我们就可以在解析完整个文件之后再运行优化器了。\n为了让函数内优化过程正常工作，我们需要初始化一个 FunctionPassManager 来管理与组织我们想要运行的优化过程。一旦它被初始化了，我们就可以向它加入一系列的优化并加以运行。对每一个我们想要优化的模块，我们都需要一个新的 FunctionPassManager，所以我们编写一个函数来为每一个模块创建并初始化一个优化过程管理器：\nvoid InitializeModuleAndPassManager(void) { // Open a new module. // 打开一个新的模块 TheModule = std::make_unique\u0026lt;Module\u0026gt;(\u0026quot;my cool jit\u0026quot;, TheContext); // Create a new pass manager attached to it. // 创建一个新的优化过程管理器并将其关联到模块上 TheFPM = std::make_unique\u0026lt;legacy::FunctionPassManager\u0026gt;(TheModule.get()); // Do simple \u0026quot;peephole\u0026quot; optimizations and bit-twiddling optzns. // 做一些简单的窥孔优化与位运算黑魔法 TheFPM-\u0026gt;add(createInstructionCombiningPass()); // Reassociate expressions. // 重关联表达式 TheFPM-\u0026gt;add(createReassociatePass()); // Eliminate Common SubExpressions. // 消除公共子表达式 TheFPM-\u0026gt;add(createGVNPass()); // Simplify the control flow graph (deleting unreachable blocks, etc). // 简化控制流图 (比如删除不可达的基本块) TheFPM-\u0026gt;add(createCFGSimplificationPass()); TheFPM-\u0026gt;doInitialization(); }  上面的代码初始化了一个全局模块 TheModule 和与之关联的函数优化过程管理器 TheFPM, 随后通过一系列 add 方法加入了一些了 LLVM 优化过程。\n我们挑选的这四个优化过程基本上就是一组被广泛使用的通用 \u0026ldquo;打扫\u0026rdquo; 级优化。本教程不会深入去将它们都干了什么，但这可以成为你学习优化技术的一个起点。\n一旦优化过程管理器好了，我们就可以使用它了。我们在构造完函数的中间代码并返回之前 (FunctionAST::codegen() 中) 使用这个优化过程管理器：\nif (Value *RetVal = Body-\u0026gt;codegen()) { // Finish off the function. // 结束函数 Builder.CreateRet(RetVal); // Validate the generated code, checking for consistency. // 检查生成的中间代码的有效性 verifyFunction(*TheFunction); // Optimize the function. // 优化函数 TheFPM-\u0026gt;run(*TheFunction); return TheFunction; }  正如你所见，上面的代码相当直观。FunctionPassManager 优化并原地更新了 LLVM Function*, (可能) 优化了其函数体。改好之后，我们可以再次尝试我们上面的测试：\nready\u0026gt; def test(x) (1+2+x)*(x+(1+2)); ready\u0026gt; Read function definition: define double @test(double %x) { entry: %addtmp = fadd double %x, 3.000000e+00 %multmp = fmul double %addtmp, %addtmp ret double %multmp }  如我们期待的那样，我们现在拥有了非常棒的优化后的中间代码，为每一次函数调用节省了一句浮点加法指令。\nLLVM 提供了许多在特定情况下可以使用的优化过程，有 一些优化过程的文档，但并非非常完整。另一个了解它们的使用方法的好方式是去看看 Clang 是如何使用它们的。工具 opt 允许你在命令行实验这些优化过程，看看它们都干了什么。\n现在我们自前端获得了合理的中间代码，让我们来讨论如何执行它吧。\n4.4 加入即时编译器 (JIT Compiler) 对于 LLVM IR，我们有一系列的处理工具。比如，你可以在其上运行优化 (正如上面一样), 或者是将其输出为文本或二进制格式。你也可以将其编译为某个目标平台上的汇编语言，或是即时编译它。LLVM IR 的好处就在于它是编译器里不同部分的\u0026quot;通用货币\u0026quot;。\n在本节，我们将会为我们的解释器加入即时编译支持。我们对于 Kaleidoscope 的基本需要就是，当用户输入了一个函数体之后，其马上求值其顶层表达式。比如，假设用户输入了 \u0026ldquo;1+2\u0026rdquo;, 我们应该求值该表达式并输出 \u0026ldquo;3\u0026rdquo;. 如果用户定义了一个函数，在之后它们应该可以被调用。\n为了做到上面这些，我们首先要准备好为当前平台生成机器码的环境，声明并初始化 JIT. 通过调用一些 InitializeNativeTarget 开头的函数与初始化一个全局变量 TheJIT, 我们便能完成这些：\nstatic std::unique_ptr\u0026lt;KaleidoscopeJIT\u0026gt; TheJIT; ... int main() { InitializeNativeTarget(); InitializeNativeTargetAsmPrinter(); InitializeNativeTargetAsmParser(); // Install standard binary operators. // 1 is lowest precedence. BinopPrecedence['\u0026lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; // highest. // Prime the first token. fprintf(stderr, \u0026quot;ready\u0026gt; \u0026quot;); getNextToken(); TheJIT = std::make_unique\u0026lt;KaleidoscopeJIT\u0026gt;(); // Run the main \u0026quot;interpreter loop\u0026quot; now. MainLoop(); return 0; }  我们还需要设置 JIT 的数据布局 (data layout):\nvoid InitializeModuleAndPassManager(void) { // Open a new module. TheModule = std::make_unique\u0026lt;Module\u0026gt;(\u0026quot;my cool jit\u0026quot;, TheContext); TheModule-\u0026gt;setDataLayout(TheJIT-\u0026gt;getTargetMachine().createDataLayout()); // Create a new pass manager attached to it. TheFPM = std::make_unique\u0026lt;legacy::FunctionPassManager\u0026gt;(TheModule.get()); ...  类 KaleidoscopeJIT 是一个简单的专为本教程定义的 JIT. 其位于头文件 llvm-src/examples/Kaleidoscope/include/KaleidoscopeJIT.h 中。在之后的章节我们将会探索其运行的方法并扩展它的功能，但现在我们就先直接使用它了。它的 API 十分简单：addModule 增加一个 LLVM IR 模块到 JIT，使其中的函数得以运行; removeModule 从 JIT 中删除一个模块并释放其所有内存; findSymbol 则让我们可以查找编译后的代码的指针。\n利用上面的 API，我们可以修改我们对于顶层表达式的解析代码如下：\nstatic void HandleTopLevelExpression() { // Evaluate a top-level expression into an anonymous function. if (auto FnAST = ParseTopLevelExpr()) { if (FnAST-\u0026gt;codegen()) { // JIT the module containing the anonymous expression, keeping a handle so // we can free it later. // 即时编译包含了匿名表达式的模块，保留其一个句柄以便于之后我们释放它 auto H = TheJIT-\u0026gt;addModule(std::move(TheModule)); InitializeModuleAndPassManager(); // Search the JIT for the __anon_expr symbol. // 在 JIT 中查找 __anon_expr 符号 auto ExprSymbol = TheJIT-\u0026gt;findSymbol(\u0026quot;__anon_expr\u0026quot;); assert(ExprSymbol \u0026amp;\u0026amp; \u0026quot;Function not found\u0026quot;); // Get the symbol's address and cast it to the right type (takes no // arguments, returns a double) so we can call it as a native function. // 获得那个符号对应的表达式的地址，将其转换为正确的类型 (不接受参数，返回一个 double) // 随后我们便能像调用一个本地函数一样调用它。 double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress(); fprintf(stderr, \u0026quot;Evaluated to %f\\n\u0026quot;, FP()); // Delete the anonymous expression module from the JIT. // 在 JIT 中删除包含匿名表达式的那个模块 TheJIT-\u0026gt;removeModule(H); }  如果解析与代码生成都成功了，下一步便是向 JIT 中加入包含顶层表达式的模块。我们通过 addModule 来实现它，其将会编译该模块内所有函数并且返回一个句柄以供我们后续删除它。模块被加入 JIT 以后它就不能再被修改了，所以我们要重新初始化全局的模块与优化过程管理器。\n将模块加入 JIT 后，我们通过调用 findSymbol 方法得到最终生成的目标代码。因为我们刚刚才把 __anon_expr 加入到 JIT，我们就直接断言我们找到了那个函数。\n接下来，我们通过 getAddress 方法获得 __anon_expr 生成的目标代码的指针并将其转换为合适的类型。因为 JIT 编译器可以自动使用目标平台上的二进制接口 (ABI), 所以我们直接转换并调用那个函数指针就可以了。这意味着 JIT 编译出的代码与你自己编写并编译出的本地代码在使用上是没有区别的。\n最后，因为我们不支持对于顶层表达式的重新求值，我们直接从 JIT 中删除编译好的模块来释放其内存。因为我们在之前已经重新初始化了全局的模块了，所以整个程序仍能继续运行并等待用户键入新的函数。\n修改上述两个地方之后，让我们来看看现在 Kaleidoscope 的运行结果吧！\nready\u0026gt; 4+5; Read top-level expression: define double @0() { entry: ret double 9.000000e+00 } Evaluated to 9.000000  它看起来好像是基本能跑了。函数的输出显示我们将输入的顶层表达式解析为一个没有参数，返回 double 的函数。上面测试了基本的工具，让我们来试试更加复杂的：\nready\u0026gt; def testfunc(x y) x + y*2; Read function definition: define double @testfunc(double %x, double %y) { entry: %multmp = fmul double %y, 2.000000e+00 %addtmp = fadd double %multmp, %x ret double %addtmp } ready\u0026gt; testfunc(4, 10); Read top-level expression: define double @1() { entry: %calltmp = call double @testfunc(double 4.000000e+00, double 1.000000e+01) ret double %calltmp } Evaluated to 24.000000 ready\u0026gt; testfunc(5, 10); ready\u0026gt; LLVM ERROR: Program used external function 'testfunc' which could not be resolved!  函数定义与调用看起来如期工作，但在最后一行发生了意想不到的事！这个函数调用看起来是有效的，所以发生了什么呢？你也许从 API 里猜到了，模块是 JIT 分配与删除的单位，并且 testfunc 与匿名的顶层表达式包含在同一个模块里。当我们从 JIT 里删除包含着顶层表达式的模块的时候，我们也顺带把 testfunc 的定义删除了。所以，当我们第二次调用 testfunc 时，JIT 就再也找不到它了。\n修正这个 bug 的简单方法是将匿名表达式放在与其他函数不同的另一个模块之中。只要被调用的函数的原型在调用前被加入到 JIT, JIT 就可以跨越模块搜寻被调用的函数。将匿名表达式放入不同的模块之中可以让我们在不影响其他函数的前提下删除匿名表达式。\n事实上，我们将更进一步：我们将把每一个函数都放入一个单独的模块。这样做利用了 KaleidoscopeJIT 的一个有用的性质：当查找一个被多次加入的函数时，JIT 将会返回其最后一次定义。利用这个性质，我们的程序就更加地 \u0026ldquo;REPL\u0026rdquo; 化了：\nready\u0026gt; def foo(x) x + 1; Read function definition: define double @foo(double %x) { entry: %addtmp = fadd double %x, 1.000000e+00 ret double %addtmp } ready\u0026gt; foo(2); Evaluated to 3.000000 ready\u0026gt; def foo(x) x + 2; define double @foo(double %x) { entry: %addtmp = fadd double %x, 2.000000e+00 ret double %addtmp } ready\u0026gt; foo(2); Evaluated to 4.000000  为了让每一个函数都存在于其自己的模块内，我们需要在每一个我们新建的模块内加入之前定义的所有函数的声明：\nstatic std::unique_ptr\u0026lt;KaleidoscopeJIT\u0026gt; TheJIT; ... Function *getFunction(std::string Name) { // First, see if the function has already been added to the current module. // 首先，看看这个函数是不是已经加入过这个模块了 if (auto *F = TheModule-\u0026gt;getFunction(Name)) return F; // If not, check whether we can codegen the declaration from some existing // prototype. // 若否，则查找已经有的函数声明，生成其声明的中间代码并返回 auto FI = FunctionProtos.find(Name); if (FI != FunctionProtos.end()) return FI-\u0026gt;second-\u0026gt;codegen(); // If no existing prototype exists, return null. // 如果这个函数的原型不存在，我们就返回 null return nullptr; } ... Value *CallExprAST::codegen() { // Look up the name in the global module table. // 在全局模块表中查找这个名字 Function *CalleeF = getFunction(Callee); ... Function *FunctionAST::codegen() { // Transfer ownership of the prototype to the FunctionProtos map, but keep a // reference to it for use below. // 将函数原型的所有权转移到 FunctionProtos map 中去，但保留一个引用以供后续使用 auto \u0026amp;P = *Proto; FunctionProtos[Proto-\u0026gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr;  为了实现它，我们首先加入一个新的全局变量 FunctionProtos, 它保存着每一个函数最后一次定义的原型。我们还加入了一个便利的函数 getFunction 来代替对 TheModule-\u0026gt;getFunction() 的直接调用。我们的便利函数查找 TheModule 尝试获取本模块可能存在的该函数的原型中间代码，如果没有就尝试从原型表中查找原型并生成对应的中间代码。 在 CallExprAST::codegen() 中我们直接将 TheModule-\u0026gt;getFunction() 替换为 getFunction() 即可。在 FunctionAST::codegen() 中，我们首先更新全局的函数原型表 FunctionProtos, 然后再调用 getFunction() 来获取它。做完这些以后，我们就可以在当前模块中获取任何之前声明过的函数了 (即使它们可能并不在同一模块).\n我们还需要更新 HandleDefinition 与 HandleExtern:\nstatic void HandleDefinition() { if (auto FnAST = ParseDefinition()) { if (auto *FnIR = FnAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read function definition:\u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); TheJIT-\u0026gt;addModule(std::move(TheModule)); InitializeModuleAndPassManager(); } } else { // Skip token for error recovery. getNextToken(); } } static void HandleExtern() { if (auto ProtoAST = ParseExtern()) { if (auto *FnIR = ProtoAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read extern: \u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); FunctionProtos[ProtoAST-\u0026gt;getName()] = std::move(ProtoAST); } } else { // Skip token for error recovery. getNextToken(); } }  在 HandleDefinition 中，我们增加两行来将新定义的函数放入 JIT 中并打开一个新的全局模块。在 HandleExtern, 我们只需要增加一行来将函数的原型放入全局原型表中 FunctionProtos.\n改完后，让我们再次来试试我们的 REPL 吧: (匿名函数的输出被省略了)\nready\u0026gt; def foo(x) x + 1; ready\u0026gt; foo(2); Evaluated to 3.000000 ready\u0026gt; def foo(x) x + 2; ready\u0026gt; foo(2); Evaluated to 4.000000  它好了！\n即便只写了这么一点简单的代码，我们的 Kaleidoscope 已经拥有了强大的能力：\nready\u0026gt; extern sin(x); Read extern: declare double @sin(double) ready\u0026gt; extern cos(x); Read extern: declare double @cos(double) ready\u0026gt; sin(1.0); Read top-level expression: define double @2() { entry: ret double 0x3FEAED548F090CEE } Evaluated to 0.841471 ready\u0026gt; def foo(x) sin(x)*sin(x) + cos(x)*cos(x); Read function definition: define double @foo(double %x) { entry: %calltmp = call double @sin(double %x) %multmp = fmul double %calltmp, %calltmp %calltmp2 = call double @cos(double %x) %multmp4 = fmul double %calltmp2, %calltmp2 %addtmp = fadd double %multmp, %multmp4 ret double %addtmp } ready\u0026gt; foo(4.0); Read top-level expression: define double @3() { entry: %calltmp = call double @foo(double 4.000000e+00) ret double %calltmp } Evaluated to 1.000000  JIT 怎么认得 sin 跟 cos 呢？答案很简单，KaleidoscopeJIT 拥有简单直接的未定义符号解析规则：首先它依加入次序从新自旧去查找所有已经被加入了 JIT 的模块，如果找不到，那么它就会在 Kaleidoscope 的进程空间调用 dlsym(\u0026quot;sin\u0026quot;). 因为 sin 在 JIT 的地址空间中已经被定义了，于是 JIT 在遇到 sin 时就会直接调用 libm 里面的 sin 函数。但在一些情况下它甚至能做更多事情：因为 sin 与 cos 是标准数学函数的名字，所以常数折叠会直接将函数调用优化为计算后的值，就像上面的 sin(1.0) 一样。\n在后续的章节我们将看到如何改进符号解析规则以使用更多更有用的特性。从安全性 (限制 JIT 生成的代码能访问的符号集合) 到基于符号名称的代码生成，甚至可以做到懒惰计算 (lazy compilation).\n符号解析规则的一个直接的好处就是我们可以通过直接定义新的 C++ 函数来扩展我们的语言。举个例子，如果我们在我们的代码中加入：\n#ifdef _WIN32 #define DLLEXPORT __declspec(dllexport) #else #define DLLEXPORT #endif /// putchard - putchar that takes a double and returns 0. extern \u0026quot;C\u0026quot; DLLEXPORT double putchard(double X) { fputc((char)X, stderr); return 0; }  注意在 Windows 上我们还需要导出这个函数，因为动态符号加载器 (the dynamic symbol loader) 会使用 GetProcAddress 来查找符号。\n现在通过使用形如 extern putchard(x); putchard(120); 的 Kaleidoscope 代码，我们可以往终端输出简单的文字了。(它将输出小写 x, 因为 120 是 x 的 ASCII 码). 类似的代码可以用于实现文件 IO，终端输入，以及其他各种能力。\n本章到这里就结束了。现在，我们可以编译一门非图灵完备的语言，优化并即时编译用户输入的代码。下一步我们将为语言加入控制流结构, 同时探索一些有趣的 LLVM IR 相关问题。\n4.5 全部代码 这里是本章例子的完整代码，包括 LLVM JIT 与优化器。若要构建这个例子，请使用：\n# Compile clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy # Run ./toy  如果您在 Linux 上编译这个程序，确保您加入了 -rdynamic 选项，这使得外部函数 (external function) 在运行时得以被正确解析。\n完整代码如下：\n#include \u0026quot;../include/KaleidoscopeJIT.h\u0026quot; #include \u0026quot;llvm/ADT/APFloat.h\u0026quot; #include \u0026quot;llvm/ADT/STLExtras.h\u0026quot; #include \u0026quot;llvm/IR/BasicBlock.h\u0026quot; #include \u0026quot;llvm/IR/Constants.h\u0026quot; #include \u0026quot;llvm/IR/DerivedTypes.h\u0026quot; #include \u0026quot;llvm/IR/Function.h\u0026quot; #include \u0026quot;llvm/IR/IRBuilder.h\u0026quot; #include \u0026quot;llvm/IR/LLVMContext.h\u0026quot; #include \u0026quot;llvm/IR/LegacyPassManager.h\u0026quot; #include \u0026quot;llvm/IR/Module.h\u0026quot; #include \u0026quot;llvm/IR/Type.h\u0026quot; #include \u0026quot;llvm/IR/Verifier.h\u0026quot; #include \u0026quot;llvm/Support/TargetSelect.h\u0026quot; #include \u0026quot;llvm/Target/TargetMachine.h\u0026quot; #include \u0026quot;llvm/Transforms/InstCombine/InstCombine.h\u0026quot; #include \u0026quot;llvm/Transforms/Scalar.h\u0026quot; #include \u0026quot;llvm/Transforms/Scalar/GVN.h\u0026quot; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace llvm; using namespace llvm::orc; //===----------------------------------------------------------------------===// // Lexer //===----------------------------------------------------------------------===// // The lexer returns tokens [0-255] if it is an unknown character, otherwise one // of these for known things. enum Token { tok_eof = -1, // commands tok_def = -2, tok_extern = -3, // primary tok_identifier = -4, tok_number = -5 }; static std::string IdentifierStr; // Filled in if tok_identifier static double NumVal; // Filled in if tok_number /// gettok - Return the next token from standard input. static int gettok() { static int LastChar = ' '; // Skip any whitespace. while (isspace(LastChar)) LastChar = getchar(); if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == \u0026quot;def\u0026quot;) return tok_def; if (IdentifierStr == \u0026quot;extern\u0026quot;) return tok_extern; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), nullptr); return tok_number; } if (LastChar == '#') { // Comment until end of line. do LastChar = getchar(); while (LastChar != EOF \u0026amp;\u0026amp; LastChar != '\\n' \u0026amp;\u0026amp; LastChar != '\\r'); if (LastChar != EOF) return gettok(); } // Check for end of file. Don't eat the EOF. if (LastChar == EOF) return tok_eof; // Otherwise, just return the character as its ascii value. int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// // Abstract Syntax Tree (aka Parse Tree) //===----------------------------------------------------------------------===// namespace { /// ExprAST - Base class for all expression nodes. class ExprAST { public: virtual ~ExprAST() = default; virtual Value *codegen() = 0; }; /// NumberExprAST - Expression class for numeric literals like \u0026quot;1.0\u0026quot;. class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double Val) : Val(Val) {} Value *codegen() override; }; /// VariableExprAST - Expression class for referencing a variable, like \u0026quot;a\u0026quot;. class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string \u0026amp;Name) : Name(Name) {} Value *codegen() override; }; /// BinaryExprAST - Expression class for a binary operator. class BinaryExprAST : public ExprAST { char Op; std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS, RHS; public: BinaryExprAST(char Op, std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS, std::unique_ptr\u0026lt;ExprAST\u0026gt; RHS) : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {} Value *codegen() override; }; /// CallExprAST - Expression class for function calls. class CallExprAST : public ExprAST { std::string Callee; std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args; public: CallExprAST(const std::string \u0026amp;Callee, std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args) : Callee(Callee), Args(std::move(Args)) {} Value *codegen() override; }; /// PrototypeAST - This class represents the \u0026quot;prototype\u0026quot; for a function, /// which captures its name, and its argument names (thus implicitly the number /// of arguments the function takes). class PrototypeAST { std::string Name; std::vector\u0026lt;std::string\u0026gt; Args; public: PrototypeAST(const std::string \u0026amp;Name, std::vector\u0026lt;std::string\u0026gt; Args) : Name(Name), Args(std::move(Args)) {} Function *codegen(); const std::string \u0026amp;getName() const { return Name; } }; /// FunctionAST - This class represents a function definition itself. class FunctionAST { std::unique_ptr\u0026lt;PrototypeAST\u0026gt; Proto; std::unique_ptr\u0026lt;ExprAST\u0026gt; Body; public: FunctionAST(std::unique_ptr\u0026lt;PrototypeAST\u0026gt; Proto, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : Proto(std::move(Proto)), Body(std::move(Body)) {} Function *codegen(); }; } // end anonymous namespace //===----------------------------------------------------------------------===// // Parser //===----------------------------------------------------------------------===// /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current /// token the parser is looking at. getNextToken reads another token from the /// lexer and updates CurTok with its results. static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence - This holds the precedence for each binary operator that is /// defined. static std::map\u0026lt;char, int\u0026gt; BinopPrecedence; /// GetTokPrecedence - Get the precedence of the pending binary operator token. static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // Make sure it's a declared binop. int TokPrec = BinopPrecedence[CurTok]; if (TokPrec \u0026lt;= 0) return -1; return TokPrec; } /// LogError* - These are little helper functions for error handling. std::unique_ptr\u0026lt;ExprAST\u0026gt; LogError(const char *Str) { fprintf(stderr, \u0026quot;Error: %s\\n\u0026quot;, Str); return nullptr; } std::unique_ptr\u0026lt;PrototypeAST\u0026gt; LogErrorP(const char *Str) { LogError(Str); return nullptr; } static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseExpression(); /// numberexpr ::= number static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseNumberExpr() { auto Result = std::make_unique\u0026lt;NumberExprAST\u0026gt;(NumVal); getNextToken(); // consume the number return std::move(Result); } /// parenexpr ::= '(' expression ')' static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseParenExpr() { getNextToken(); // eat (. auto V = ParseExpression(); if (!V) return nullptr; if (CurTok != ')') return LogError(\u0026quot;expected ')'\u0026quot;); getNextToken(); // eat ). return V; } /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref. return std::make_unique\u0026lt;VariableExprAST\u0026gt;(IdName); // Call. getNextToken(); // eat ( std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args; if (CurTok != ')') { while (true) { if (auto Arg = ParseExpression()) Args.push_back(std::move(Arg)); else return nullptr; if (CurTok == ')') break; if (CurTok != ',') return LogError(\u0026quot;Expected ')' or ',' in argument list\u0026quot;); getNextToken(); } } // Eat the ')'. getNextToken(); return std::make_unique\u0026lt;CallExprAST\u0026gt;(IdName, std::move(Args)); } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParsePrimary() { switch (CurTok) { default: return LogError(\u0026quot;unknown token when expecting an expression\u0026quot;); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); } } /// binoprhs /// ::= ('+' primary)* static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseBinOpRHS(int ExprPrec, std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS) { // If this is a binop, find its precedence. while (true) { int TokPrec = GetTokPrecedence(); // If this is a binop that binds at least as tightly as the current binop, // consume it, otherwise we are done. if (TokPrec \u0026lt; ExprPrec) return LHS; // Okay, we know this is a binop. int BinOp = CurTok; getNextToken(); // eat binop // Parse the primary expression after the binary operator. auto RHS = ParsePrimary(); if (!RHS) return nullptr; // If BinOp binds less tightly with RHS than the operator after RHS, let // the pending operator take RHS as its LHS. int NextPrec = GetTokPrecedence(); if (TokPrec \u0026lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS)); if (!RHS) return nullptr; } // Merge LHS/RHS. LHS = std::make_unique\u0026lt;BinaryExprAST\u0026gt;(BinOp, std::move(LHS), std::move(RHS)); } } /// expression /// ::= primary binoprhs /// static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseExpression() { auto LHS = ParsePrimary(); if (!LHS) return nullptr; return ParseBinOpRHS(0, std::move(LHS)); } /// prototype /// ::= id '(' id* ')' static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParsePrototype() { if (CurTok != tok_identifier) return LogErrorP(\u0026quot;Expected function name in prototype\u0026quot;); std::string FnName = IdentifierStr; getNextToken(); if (CurTok != '(') return LogErrorP(\u0026quot;Expected '(' in prototype\u0026quot;); std::vector\u0026lt;std::string\u0026gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return LogErrorP(\u0026quot;Expected ')' in prototype\u0026quot;); // success. getNextToken(); // eat ')'. return std::make_unique\u0026lt;PrototypeAST\u0026gt;(FnName, std::move(ArgNames)); } /// definition ::= 'def' prototype expression static std::unique_ptr\u0026lt;FunctionAST\u0026gt; ParseDefinition() { getNextToken(); // eat def. auto Proto = ParsePrototype(); if (!Proto) return nullptr; if (auto E = ParseExpression()) return std::make_unique\u0026lt;FunctionAST\u0026gt;(std::move(Proto), std::move(E)); return nullptr; } /// toplevelexpr ::= expression static std::unique_ptr\u0026lt;FunctionAST\u0026gt; ParseTopLevelExpr() { if (auto E = ParseExpression()) { // Make an anonymous proto. auto Proto = std::make_unique\u0026lt;PrototypeAST\u0026gt;(\u0026quot;__anon_expr\u0026quot;, std::vector\u0026lt;std::string\u0026gt;()); return std::make_unique\u0026lt;FunctionAST\u0026gt;(std::move(Proto), std::move(E)); } return nullptr; } /// external ::= 'extern' prototype static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParseExtern() { getNextToken(); // eat extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// // Code Generation //===----------------------------------------------------------------------===// static std::unique_ptr\u0026lt;LLVMContext\u0026gt; TheContext; static std::unique_ptr\u0026lt;Module\u0026gt; TheModule; static std::unique_ptr\u0026lt;IRBuilder\u0026lt;\u0026gt;\u0026gt; Builder; static std::map\u0026lt;std::string, Value *\u0026gt; NamedValues; static std::unique_ptr\u0026lt;legacy::FunctionPassManager\u0026gt; TheFPM; static std::unique_ptr\u0026lt;KaleidoscopeJIT\u0026gt; TheJIT; static std::map\u0026lt;std::string, std::unique_ptr\u0026lt;PrototypeAST\u0026gt;\u0026gt; FunctionProtos; static ExitOnError ExitOnErr; Value *LogErrorV(const char *Str) { LogError(Str); return nullptr; } Function *getFunction(std::string Name) { // First, see if the function has already been added to the current module. if (auto *F = TheModule-\u0026gt;getFunction(Name)) return F; // If not, check whether we can codegen the declaration from some existing // prototype. auto FI = FunctionProtos.find(Name); if (FI != FunctionProtos.end()) return FI-\u0026gt;second-\u0026gt;codegen(); // If no existing prototype exists, return null. return nullptr; } Value *NumberExprAST::codegen() { return ConstantFP::get(*TheContext, APFloat(Val)); } Value *VariableExprAST::codegen() { // Look this variable up in the function. Value *V = NamedValues[Name]; if (!V) return LogErrorV(\u0026quot;Unknown variable name\u0026quot;); return V; } Value *BinaryExprAST::codegen() { Value *L = LHS-\u0026gt;codegen(); Value *R = RHS-\u0026gt;codegen(); if (!L || !R) return nullptr; switch (Op) { case '+': return Builder-\u0026gt;CreateFAdd(L, R, \u0026quot;addtmp\u0026quot;); case '-': return Builder-\u0026gt;CreateFSub(L, R, \u0026quot;subtmp\u0026quot;); case '*': return Builder-\u0026gt;CreateFMul(L, R, \u0026quot;multmp\u0026quot;); case '\u0026lt;': L = Builder-\u0026gt;CreateFCmpULT(L, R, \u0026quot;cmptmp\u0026quot;); // Convert bool 0/1 to double 0.0 or 1.0 return Builder-\u0026gt;CreateUIToFP(L, Type::getDoubleTy(*TheContext), \u0026quot;booltmp\u0026quot;); default: return LogErrorV(\u0026quot;invalid binary operator\u0026quot;); } } Value *CallExprAST::codegen() { // Look up the name in the global module table. Function *CalleeF = getFunction(Callee); if (!CalleeF) return LogErrorV(\u0026quot;Unknown function referenced\u0026quot;); // If argument mismatch error. if (CalleeF-\u0026gt;arg_size() != Args.size()) return LogErrorV(\u0026quot;Incorrect # arguments passed\u0026quot;); std::vector\u0026lt;Value *\u0026gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-\u0026gt;codegen()); if (!ArgsV.back()) return nullptr; } return Builder-\u0026gt;CreateCall(CalleeF, ArgsV, \u0026quot;calltmp\u0026quot;); } Function *PrototypeAST::codegen() { // Make the function type: double(double,double) etc. std::vector\u0026lt;Type *\u0026gt; Doubles(Args.size(), Type::getDoubleTy(*TheContext)); FunctionType *FT = FunctionType::get(Type::getDoubleTy(*TheContext), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get()); // Set names for all arguments. unsigned Idx = 0; for (auto \u0026amp;Arg : F-\u0026gt;args()) Arg.setName(Args[Idx++]); return F; } Function *FunctionAST::codegen() { // Transfer ownership of the prototype to the FunctionProtos map, but keep a // reference to it for use below. auto \u0026amp;P = *Proto; FunctionProtos[Proto-\u0026gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr; // Create a new basic block to start insertion into. BasicBlock *BB = BasicBlock::Create(*TheContext, \u0026quot;entry\u0026quot;, TheFunction); Builder-\u0026gt;SetInsertPoint(BB); // Record the function arguments in the NamedValues map. NamedValues.clear(); for (auto \u0026amp;Arg : TheFunction-\u0026gt;args()) NamedValues[std::string(Arg.getName())] = \u0026amp;Arg; if (Value *RetVal = Body-\u0026gt;codegen()) { // Finish off the function. Builder-\u0026gt;CreateRet(RetVal); // Validate the generated code, checking for consistency. verifyFunction(*TheFunction); // Run the optimizer on the function. TheFPM-\u0026gt;run(*TheFunction); return TheFunction; } // Error reading body, remove function. TheFunction-\u0026gt;eraseFromParent(); return nullptr; } //===----------------------------------------------------------------------===// // Top-Level parsing and JIT Driver //===----------------------------------------------------------------------===// static void InitializeModuleAndPassManager() { // Open a new context and module. TheContext = std::make_unique\u0026lt;LLVMContext\u0026gt;(); TheModule = std::make_unique\u0026lt;Module\u0026gt;(\u0026quot;my cool jit\u0026quot;, *TheContext); TheModule-\u0026gt;setDataLayout(TheJIT-\u0026gt;getDataLayout()); // Create a new builder for the module. Builder = std::make_unique\u0026lt;IRBuilder\u0026lt;\u0026gt;\u0026gt;(*TheContext); // Create a new pass manager attached to it. TheFPM = std::make_unique\u0026lt;legacy::FunctionPassManager\u0026gt;(TheModule.get()); // Do simple \u0026quot;peephole\u0026quot; optimizations and bit-twiddling optzns. TheFPM-\u0026gt;add(createInstructionCombiningPass()); // Reassociate expressions. TheFPM-\u0026gt;add(createReassociatePass()); // Eliminate Common SubExpressions. TheFPM-\u0026gt;add(createGVNPass()); // Simplify the control flow graph (deleting unreachable blocks, etc). TheFPM-\u0026gt;add(createCFGSimplificationPass()); TheFPM-\u0026gt;doInitialization(); } static void HandleDefinition() { if (auto FnAST = ParseDefinition()) { if (auto *FnIR = FnAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read function definition:\u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); ExitOnErr(TheJIT-\u0026gt;addModule( ThreadSafeModule(std::move(TheModule), std::move(TheContext)))); InitializeModuleAndPassManager(); } } else { // Skip token for error recovery. getNextToken(); } } static void HandleExtern() { if (auto ProtoAST = ParseExtern()) { if (auto *FnIR = ProtoAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read extern: \u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); FunctionProtos[ProtoAST-\u0026gt;getName()] = std::move(ProtoAST); } } else { // Skip token for error recovery. getNextToken(); } } static void HandleTopLevelExpression() { // Evaluate a top-level expression into an anonymous function. if (auto FnAST = ParseTopLevelExpr()) { if (FnAST-\u0026gt;codegen()) { // Create a ResourceTracker to track JIT'd memory allocated to our // anonymous expression -- that way we can free it after executing. auto RT = TheJIT-\u0026gt;getMainJITDylib().createResourceTracker(); auto TSM = ThreadSafeModule(std::move(TheModule), std::move(TheContext)); ExitOnErr(TheJIT-\u0026gt;addModule(std::move(TSM), RT)); InitializeModuleAndPassManager(); // Search the JIT for the __anon_expr symbol. auto ExprSymbol = ExitOnErr(TheJIT-\u0026gt;lookup(\u0026quot;__anon_expr\u0026quot;)); // Get the symbol's address and cast it to the right type (takes no // arguments, returns a double) so we can call it as a native function. double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress(); fprintf(stderr, \u0026quot;Evaluated to %f\\n\u0026quot;, FP()); // Delete the anonymous expression module from the JIT. ExitOnErr(RT-\u0026gt;remove()); } } else { // Skip token for error recovery. getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (true) { fprintf(stderr, \u0026quot;ready\u0026gt; \u0026quot;); switch (CurTok) { case tok_eof: return; case ';': // ignore top-level semicolons. getNextToken(); break; case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // \u0026quot;Library\u0026quot; functions that can be \u0026quot;extern'd\u0026quot; from user code. //===----------------------------------------------------------------------===// #ifdef _WIN32 #define DLLEXPORT __declspec(dllexport) #else #define DLLEXPORT #endif /// putchard - putchar that takes a double and returns 0. extern \u0026quot;C\u0026quot; DLLEXPORT double putchard(double X) { fputc((char)X, stderr); return 0; } /// printd - printf that takes a double prints it as \u0026quot;%f\\n\u0026quot;, returning 0. extern \u0026quot;C\u0026quot; DLLEXPORT double printd(double X) { fprintf(stderr, \u0026quot;%f\\n\u0026quot;, X); return 0; } //===----------------------------------------------------------------------===// // Main driver code. //===----------------------------------------------------------------------===// int main() { InitializeNativeTarget(); InitializeNativeTargetAsmPrinter(); InitializeNativeTargetAsmParser(); // Install standard binary operators. // 1 is lowest precedence. BinopPrecedence['\u0026lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; // highest. // Prime the first token. fprintf(stderr, \u0026quot;ready\u0026gt; \u0026quot;); getNextToken(); TheJIT = ExitOnErr(KaleidoscopeJIT::Create()); InitializeModuleAndPassManager(); // Run the main \u0026quot;interpreter loop\u0026quot; now. MainLoop(); return 0; } ","date":"2022-01-15","permalink":"https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-4/","tags":["编译原理","编译前端","LLVM","翻译"],"title":"LLVM Kaleidoscope 第 4 章 增加 JIT 与优化"},{"content":"5.1 前言 欢迎来到 我的第一个基于 LLVM 的语言前端 教程第五章。前四章描述了一门简单语言的实现，生成 LLVM IR 并优化，随后即时编译到本地代码的过程。不幸的是，至少到目前为止，Kaleidoscope 还不堪大用：它没有控制流结构 (除了函数调用与返回). 这意味着你不能用它写出带条件分支的代码，这显著地影响了 Kaleidoscope 的威力。在本章，我们将扩展 Kaleidoscope，使其支持 if/then/else 表达式和一个简单的 for 循环。\n5.2 If/Then/Else 实现 if/then/else 比较简单。要做的事情主要是把这个\u0026quot;新概念\u0026quot; 教给 lexer, parser, AST 与 LLVM 中间代码生成器。本节同时也是一个极好的展示如何 \u0026ldquo;养大\u0026rdquo; 一门语言，用新点子扩展它的例子。\n在我们动手之前，先来看看讨论一下我们 想要 什么。我们想要的基本上就是这样：\ndef fib(x) if x \u0026lt; 3 then 1 else fib(x-1)+fib(x-2);  在 Kaleidoscope，每一个结构都是一个表达式：没有语句。于是，就像其他表达式一样，if/the/else 表达式需要返回一个值。由于我们所采用的语言特性大部分都是函数式的，所以我们会让 if/then/else 表达式先求值其条件，随后视条件再求值 then 或 else 中的一个子表达式，这与 C 中的 \u0026ldquo;?:\u0026rdquo; 三元操作符表达式非常相似。\nif/then/else 表达式的语义是先求值其条件，值 0.0 被认为是逻辑假，而其他任何值被认为是逻辑真。如果条件为真，那么第一个子表达式 (then 子表达式) 将会被求值; 如果条件为假，那么第二个子表达式 (else 子表达式将会被求值). 由于 Kaleidoscope 允许副作用，所以上面的行为需要被正式地确定。\n现在我们知道我们想要什么了，我们来一步一步实现它。\n5.2.1 词法扩展 对 lexer 的扩展很简单。首先我们加入几个新的词法单元 (token).\n// control tok_if = -6, tok_then = -7, tok_else = -8,  随后我们修改 lexer 使其能辨认这些关键字：\n... if (IdentifierStr == \u0026quot;def\u0026quot;) return tok_def; if (IdentifierStr == \u0026quot;extern\u0026quot;) return tok_extern; if (IdentifierStr == \u0026quot;if\u0026quot;) return tok_if; if (IdentifierStr == \u0026quot;then\u0026quot;) return tok_then; if (IdentifierStr == \u0026quot;else\u0026quot;) return tok_else; return tok_identifier;  5.2.2 AST 扩展 为了表示新表达式，我们增加一个新的 AST 节点类型：\n/// IfExprAST - Expression class for if/then/else. class IfExprAST : public ExprAST { std::unique_ptr\u0026lt;ExprAST\u0026gt; Cond, Then, Else; public: IfExprAST(std::unique_ptr\u0026lt;ExprAST\u0026gt; Cond, std::unique_ptr\u0026lt;ExprAST\u0026gt; Then, std::unique_ptr\u0026lt;ExprAST\u0026gt; Else) : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {} Value *codegen() override; };  这个 AST 节点仅仅只包含几个指向其子表达式的指针而已。\n5.2.3 语法扩展 现在我们能从 lexer 里得到新的相关词元并且已经有其对应的 AST 了，那么我们的解析逻辑也是相对简单的了。首先我们定义一个新的解析函数：\n/// ifexpr ::= 'if' expression 'then' expression 'else' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseIfExpr() { getNextToken(); // eat the if. // condition. auto Cond = ParseExpression(); if (!Cond) return nullptr; if (CurTok != tok_then) return LogError(\u0026quot;expected then\u0026quot;); getNextToken(); // eat the then auto Then = ParseExpression(); if (!Then) return nullptr; if (CurTok != tok_else) return LogError(\u0026quot;expected else\u0026quot;); getNextToken(); auto Else = ParseExpression(); if (!Else) return nullptr; return std::make_unique\u0026lt;IfExprAST\u0026gt;(std::move(Cond), std::move(Then), std::move(Else)); }  随后在 primary expression 里增加解析它的情况：\nstatic std::unique_ptr\u0026lt;ExprAST\u0026gt; ParsePrimary() { switch (CurTok) { default: return LogError(\u0026quot;unknown token when expecting an expression\u0026quot;); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); } }  5.2.4 想要生成的 LLVM IR 现在我们能从代码构建出 AST 了，最后一步就是生成 LLVM 中间代码了。这将会是最有趣的一步，我们将介绍一些新的概念，而之前的几步的代码多多少少都已经在前面介绍过了。\n我们先来看一个简单的例子。考虑以下代码：\nextern foo(); extern bar(); def baz(x) if x then foo() else bar();  如果你关闭优化，你得到的代码将会类似于：\ndeclare double @foo() declare double @bar() define double @baz(double %x) { entry: %ifcond = fcmp one double %x, 0.000000e+00 br i1 %ifcond, label %then, label %else then: ; preds = %entry %calltmp = call double @foo() br label %ifcont else: ; preds = %entry %calltmp1 = call double @bar() br label %ifcont ifcont: ; preds = %else, %then %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ] ret double %iftmp }  为了\u0026quot;看见\u0026quot; 控制流图，我们可以使用 LLVM opt 工具的一个小功能。如果你将 LLVM IR 放在一个文件 t.ll 里，然后执行 llvm-as \u0026lt; t.ll | opt -analyze -view-cfg, 那么你将会通过一个弹出的窗口看到下面这张图：\n得到这张图的另一个方法是在编译器里或者是调试器内对 Function *F 调用 F-\u0026gt;viewCFG() 或者 F-\u0026gt;viewCFGOnly(). LLVM 具有许多优秀的可视化不同的图的功能。\n谈回生成的代码，它比较简单： entry 块求值条件表达式 (在本例子里，指 x), 然后用指令 fcmp one 将其与 0.0 比较 (one 意味着 Ordered and Not Equal，有序且不等). 基于比较结果，这个代码跳转到 then 块或者是 else 块，块中包含了待求值的表达式。\n当 then/else 块执行完毕之后，它们都跳转回 ifcont 块来执行 if/then/else 表达式之后的指令。在这个例子中这个指令就是从函数中返回。随后问题出现了：代码怎么知道哪一个表达式的值将要被返回？\n这引出了一个重要的 SSA 运算：phi 运算. 如果你对 SSA 不太熟悉，这里有一篇很好的介绍：维基百科: SSA form. 简而言之，phi 运算能 \u0026ldquo;记住\u0026rdquo; 控制流从哪个块流过来。Phi 运算接受控制流可能经过的上一个块的变量，然后返回控制流真正经过的那个块里的变量。在本例子中，如果控制流从 then 块中流入，那么它的值就会是 calltmp 的值; 否则如果控制流从 else 块流入，那么它的值就会是 calltmp1 的值。\n\u0026ldquo;天哪！\u0026rdquo;, 你也许会想，\u0026ldquo;难道我那可怜的小小前端要开始生成 SSA Form 来使用 LLVM 了吗？!\u0026rdquo; 幸运的是，它并不需要，并且我们强烈建议你不要让前端生成 SSA form，除非你有非常非常充足的理由。实践上，对于一般的命令式编程语言而言，会产生 phi 运算的代码只有两类：\n 包含了用户定义的变量的运算，如 x = 1, x = x + 1; 值并不由 AST 直接给出 (而是依赖于运行时控制流的流向), 比如这个例子。  在本教程的第七章：可变量里，我们将会深入地讨论第一种情况; 在现在，你并不需要构造 SSA 来应付第一种情况。对于情况二，你可以使用我们用来应付情况一的技术，或者如果方便的话，你可以直接手动插入 phi 节点。简单起见，我们选择后者，即我们手动插入 phi 节点。\n好了，介绍跟总览已经结束了，开始写代码吧！\n5.2.5 中间代码生成 我们来实现 IfExprAST::codegen():\nValue *IfExprAST::codegen() { Value *CondV = Cond-\u0026gt;codegen(); if (!CondV) return nullptr; // Convert condition to a bool by comparing non-equal to 0.0. // 将条件表达式的值与 0.0 比较以获得一个 bool 值 (i1) CondV = Builder.CreateFCmpONE( CondV, ConstantFP::get(TheContext, APFloat(0.0)), \u0026quot;ifcond\u0026quot;);  第一块代码跟上面的代码类似，我们先生成条件表达式的代码，随后将其的值与 0.0 比较，获得一个类型为 1-bit 的整数 (bool) 的值。\nFunction *TheFunction = Builder.GetInsertBlock()-\u0026gt;getParent(); // Create blocks for the then and else cases. Insert the 'then' block at the // end of the function. // 为 then 和 else 创建基本块，将 then 块插入到函数的结尾。 BasicBlock *ThenBB = BasicBlock::Create(TheContext, \u0026quot;then\u0026quot;, TheFunction); BasicBlock *ElseBB = BasicBlock::Create(TheContext, \u0026quot;else\u0026quot;); BasicBlock *MergeBB = BasicBlock::Create(TheContext, \u0026quot;ifcont\u0026quot;); Builder.CreateCondBr(CondV, ThenBB, ElseBB);  上面的代码构造了与 if/then/else 相关的基本块 (basic block), 它们跟上面的例子直接对应。第一行通过获取当前插入块的 \u0026ldquo;父母\u0026rdquo; 获得了当前正在构造的函数对象。随后其创建了三个基本块，注意其只将 TheFunction 传入了第一个块 (then 块) 的构造函数之中，这会使得构造函数将新构造出的基本块插入到该函数的最后去。最后我们便可以生成条件分支的代码。值得注意的是，创建新的基本块并不会隐式地改变 IRBuilder 插入指令的地点，所以新增的跳转指令仍然附加会在 cond 基本块的最后。同时我们发现，跳转指令可以直接以 ElseBB 作为参数，即使它还未被加入到哪一个函数之中 \u0026ndash; 事实上，这是 LLVM 支持前向引用 (forward reference) 的基本方法。\n 译者注：本文将 branch instruction 翻译为跳转指令\n // Emit then value. // 生成 `then` 分支的代码 Builder.SetInsertPoint(ThenBB); Value *ThenV = Then-\u0026gt;codegen(); if (!ThenV) return nullptr; Builder.CreateBr(MergeBB); // Codegen of 'Then' can change the current block, update ThenBB for the PHI. // 对 then 块内表达式的代码生成可能会改变当前基本块，所以我们为 phi 更新 ThenBB ThenBB = Builder.GetInsertBlock();  当跳转指令被插入以后，我们将 IRBuilder 的插入点移动到新的基本块 then 的开头 \u0026ndash; 严格来讲，是其最后; 但因为 then 块现在是空的，所以它的最后就是它的开头 :).\n随后我们递归生成 then 表达式的中间代码，然后在 then 块的结尾加入一个无条件跳转指令到控制流合并的基本块。LLVM IR 一个有趣 (且非常重要) 的要求是：每一个基本块都被一句控制流指令(比如返回或者是跳转) 所终结 (terminated). 这意味着所有的控制流，包括 fall through，都必须在 LLVM IR 中被显式表达。如果你违反了这一规则，那么检验器 (verifier) 将会产生一个 error.\n最后一行代码比较微妙，很容易漏掉，但十分重要。这里的主要问题是，在后面我们创建 phi 指令时，我们需要给它一并提供基本块与值。但在递归调用 codegen 的时候，then 子表达式可能会创建新的基本块，导致 ThenV 与目前的 ThenBB 不在同一个基本块内。因此我们在这里需要使用 Builder.GetInsertBlock() 来更新我们的 ThenBB，以确保我们能正确地将基本块与值匹配。\n// Emit else block. // 生成 else 分支的代码 TheFunction-\u0026gt;getBasicBlockList().push_back(ElseBB); Builder.SetInsertPoint(ElseBB); Value *ElseV = Else-\u0026gt;codegen(); if (!ElseV) return nullptr; Builder.CreateBr(MergeBB); // codegen of 'Else' can change the current block, update ElseBB for the PHI. // 同样也要更新一下 ElseBB 的值 ElseBB = Builder.GetInsertBlock();  生成 else 块的代码跟生成 then 块的代码基本相同，但是在最开始，我们需要将 else 基本块加入到函数里面去。(因为我们在构造这个块的时候没有将其加入). 现在我们可以开始处理 merge 块了。\n// Emit merge block. // 生成 merge 块 TheFunction-\u0026gt;getBasicBlockList().push_back(MergeBB); Builder.SetInsertPoint(MergeBB); PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, \u0026quot;iftmp\u0026quot;); PN-\u0026gt;addIncoming(ThenV, ThenBB); PN-\u0026gt;addIncoming(ElseV, ElseBB); return PN; }  前两行类似与之前：首先将 merge 块加入到函数内 (在这之前它是浮动的 (floating), 和 else 块一样), 然后改变 IRBuilder 的插入点。随后我们马上插入一个 phi 指令并设置 phi 指令的参数。\n最终，codegen 函数返回构造出的 PHINode 作为对 if/then/else 表达式求值的结果。在我们这个例子里，它将会被解析顶层表达式的函数使用，后者最终会构造出返回指令。\n综上，Kaleidoscope 现在可以依条件执行代码了。有了这个能力，Kaleidoscope 已经是一门相对完整的语言，可以计算许许多多的数值函数。下一步我们将会加入另一个有用的表达式，我们在其他非函数式语言里已经非常熟悉它了。\n5.3 for 循环表达式 在学习了如何向语言中加入基本的控制流结构之后，我们就有了加入更高级功能的工具了。让我们来加入一些更激进的事物吧：一个 for 表达式：\nextern putchard(char); def printstar(n) for i = 1, i \u0026lt; n, 1.0 in putchard(42); # ascii 42 = '*' # print 100 '*' characters printstar(100);  这个表达式定义了一个新的变量 (i), 随后从一个起始值 (1) 开始迭代，当满足条件 (i \u0026lt; n) 时，把循环变量增加一个可选的增加值 (1.0). 如果增加值 (step value) 被忽略，那么它默认是 1.0. 当循环条件为真时，它执行其循环体内的表达式。由于我们没有什么特别的值值得返回，我们直接定义 for 表达式的返回值是 0.0. 当我们定义了可变量之后，它将会变得更加有用。\n5.3.1 词法扩展 Lexer 的修改与 if/then/else 类似：\n... in enum Token ... // control tok_if = -6, tok_then = -7, tok_else = -8, tok_for = -9, tok_in = -10 ... in gettok ... if (IdentifierStr == \u0026quot;def\u0026quot;) return tok_def; if (IdentifierStr == \u0026quot;extern\u0026quot;) return tok_extern; if (IdentifierStr == \u0026quot;if\u0026quot;) return tok_if; if (IdentifierStr == \u0026quot;then\u0026quot;) return tok_then; if (IdentifierStr == \u0026quot;else\u0026quot;) return tok_else; if (IdentifierStr == \u0026quot;for\u0026quot;) return tok_for; if (IdentifierStr == \u0026quot;in\u0026quot;) return tok_in; return tok_identifier;  5.3.2 AST 扩展 AST 扩展也是简单的，直接储存变量名与所属的各个子表达式即可。\n/// ForExprAST - Expression class for for/in. class ForExprAST : public ExprAST { std::string VarName; std::unique_ptr\u0026lt;ExprAST\u0026gt; Start, End, Step, Body; public: ForExprAST(const std::string \u0026amp;VarName, std::unique_ptr\u0026lt;ExprAST\u0026gt; Start, std::unique_ptr\u0026lt;ExprAST\u0026gt; End, std::unique_ptr\u0026lt;ExprAST\u0026gt; Step, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : VarName(VarName), Start(std::move(Start)), End(std::move(End)), Step(std::move(Step)), Body(std::move(Body)) {} Value *codegen() override; };  5.3.3 语法扩展 Parser 的代码也是相对统一的。唯一值得注意的点就是对可选的增加值的处理。在代码中，对有无增加值的检测是通过检查是否存在第二个逗号来实现的。如果没有增加值，它就向 AST 的增加值子表达式中传入 null.\n/// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseForExpr() { getNextToken(); // eat the for. if (CurTok != tok_identifier) return LogError(\u0026quot;expected identifier after for\u0026quot;); std::string IdName = IdentifierStr; getNextToken(); // eat identifier. if (CurTok != '=') return LogError(\u0026quot;expected '=' after for\u0026quot;); getNextToken(); // eat '='. auto Start = ParseExpression(); if (!Start) return nullptr; if (CurTok != ',') return LogError(\u0026quot;expected ',' after for start value\u0026quot;); getNextToken(); auto End = ParseExpression(); if (!End) return nullptr; // The step value is optional. std::unique_ptr\u0026lt;ExprAST\u0026gt; Step; if (CurTok == ',') { getNextToken(); Step = ParseExpression(); if (!Step) return nullptr; } if (CurTok != tok_in) return LogError(\u0026quot;expected 'in' after for\u0026quot;); getNextToken(); // eat 'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return std::make_unique\u0026lt;ForExprAST\u0026gt;(IdName, std::move(Start), std::move(End), std::move(Step), std::move(Body)); }  最后我们在主表达式解析中加入其解析：\nstatic std::unique_ptr\u0026lt;ExprAST\u0026gt; ParsePrimary() { switch (CurTok) { default: return LogError(\u0026quot;unknown token when expecting an expression\u0026quot;); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); } }  5.3.4 想要生成的 LLVM IR 现在我们来到值得注意的部分了：为 for 表达式生成 LLVM IR. 有了上面的例子，我们不难写出我们想要的 IR (下面的 IR 是未经优化的):\ndeclare double @putchard(double) define double @printstar(double %n) { entry: ; initial value = 1.0 (inlined into phi) br label %loop loop: ; preds = %loop, %entry %i = phi double [ 1.000000e+00, %entry ], [ %nextvar, %loop ] ; body %calltmp = call double @putchard(double 4.200000e+01) ; increment %nextvar = fadd double %i, 1.000000e+00 ; termination test %cmptmp = fcmp ult double %i, %n %booltmp = uitofp i1 %cmptmp to double %loopcond = fcmp one double %booltmp, 0.000000e+00 br i1 %loopcond, label %loop, label %afterloop afterloop: ; preds = %loop ; loop always returns 0.0 ret double 0.000000e+00 }  loop 基本块包含了所有我们之前见过的结构：一个 phi 节点，几个表达式以及一些基本块。\n最后让我们来看看它们是怎么样组合出来吧。\n5.3.5 中间代码生成 中间代码生成的第一步比较简单，我们直接从求值初始值表达式开始：\nValue *ForExprAST::codegen() { // Emit the start code first, without 'variable' in scope. // 在没有 for 定义的变量在作用域内的前提下求值初始值表达式 Value *StartVal = Start-\u0026gt;codegen(); if (!StartVal) return nullptr;  下一步是为循环体的开始创建一个新的基本块。在上小节的例子中，整个循环体在一个基本块里; 但实际上整个循环体可能包含多个基本块 (比如循环体包含了 if/then/else 或者 for/in 表达式的情况).\n// Make the new basic block for the loop header, inserting after current // block. // 将新基本块作为循环表达式的头部，插入到当前基本块之后 Function *TheFunction = Builder.GetInsertBlock()-\u0026gt;getParent(); BasicBlock *PreheaderBB = Builder.GetInsertBlock(); BasicBlock *LoopBB = BasicBlock::Create(TheContext, \u0026quot;loop\u0026quot;, TheFunction); // Insert an explicit fall through from the current block to the LoopBB. // 插入一个显式的 fall through 以便掉到下一个基本块去 Builder.CreateBr(LoopBB);  这些代码类似于我们为 if/then/else 所写的代码。因为我们需要创建 phi 节点，我们必须记得那个 fall through 进入循环体的基本块。 一旦有了那个块，我们就可以创建真正的循环头部，并且插入一个无条件跳转以进入循环体。\n 译者注：其实就是把每一次的循环变量用 phi 定义出来。循环变量的值可能来源于两处：初始值与上一次的值，后一种情况 phi 节点的参数将会包含一个在之后定义的变量。在这里我们保存开头的块是为了在 phi 里加入初始值所在的块。\n // Start insertion in LoopBB. // 开始往循环体内加入指令 Builder.SetInsertPoint(LoopBB); // Start the PHI node with an entry for Start. // 将开始的 StartVal 加入到 phi 节点里 PHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, VarName.c_str()); Variable-\u0026gt;addIncoming(StartVal, PreheaderBB);  现在我们开始真正地生成循环体内的代码。我们首先在循环体头部为循环变量插入 phi 节点。由于我们已经知道我们将会从初始值得到循环变量的一个值，我们先将它加入 phi 的参数。我们的 phi 节点最终会得到它的第二个参数，但我们现在还不能设置它 (因为这个变量现在还不存在！).\n// Within the loop, the variable is defined equal to the PHI node. If it // shadows an existing variable, we have to restore it, so save it now. // 在循环体内部，循环变量现在是被 phi 指令定义出来的那个 // 如果我们的循环变量遮盖了一个已经存在的变量，那么我们要先把旧的变量的值保存起来 Value *OldVal = NamedValues[VarName]; NamedValues[VarName] = Variable; // Emit the body of the loop. This, like any other expr, can change the // current BB. Note that we ignore the value computed by the body, but don't // allow an error. // 生成循环体的代码。同理这可能改变当前基本块。 // 即使我们会忽略循环体的求值结果，但我们不会允许循环体内出现错误 if (!Body-\u0026gt;codegen()) return nullptr;  现在代码变得有趣起来了。我们的 for 循环引入了新的变量，这意味着它有可能跟某个外部变量重名。我们可以选择在重名的时候直接报错 \u0026ndash; 这将简化我们的处理 \u0026ndash; 但我们还是选择使用遮蔽 (shadowing)。为了处理这种情况，在我们开始生成循环体的代码之前，我们首先要检查可能冲突的变量并事先加以保存。在循环体执行完毕之后，我们还要恢复重名变量原先的值。\n当循环变量被加载进符号表之后，我们便可以开始递归生成循环体的中间代码。这使得循环体内部可以使用循环变量：任何对该名字的引用都可以自然地在符号表内找到。\n// Emit the step value. // 生成增加值表达式的代码 Value *StepVal = nullptr; if (Step) { StepVal = Step-\u0026gt;codegen(); if (!StepVal) return nullptr; } else { // If not specified, use 1.0. // 如果增加值没有被指定，那么使用 1.0 StepVal = ConstantFP::get(TheContext, APFloat(1.0)); } Value *NextVar = Builder.CreateFAdd(Variable, StepVal, \u0026quot;nextvar\u0026quot;);  当循环体被生成了之后，我们就要计算循环变量的下一次的值。我们先求值增加值，然后再将其加到循环变量上以创建一个新的变量。接下来，NextVar 将会变成下一次循环中循环变量的值。\n// Compute the end condition. // 生成循环条件表达式 Value *EndCond = End-\u0026gt;codegen(); if (!EndCond) return nullptr; // Convert condition to a bool by comparing non-equal to 0.0. // 将循环条件表达式的值与 0.0 比较以得到一个 bool EndCond = Builder.CreateFCmpONE( EndCond, ConstantFP::get(TheContext, APFloat(0.0)), \u0026quot;loopcond\u0026quot;);  最后，我们求值循环条件来判断是否应该终止循环。这些代码与 if/then/else 中的判断是完全相同的。\n// Create the \u0026quot;after loop\u0026quot; block and insert it. // 创建循环后基本块并将其插入 BasicBlock *LoopEndBB = Builder.GetInsertBlock(); BasicBlock *AfterBB = BasicBlock::Create(TheContext, \u0026quot;afterloop\u0026quot;, TheFunction); // Insert the conditional branch into the end of LoopEndBB. // 在循环结束的最后插入跳转指令 Builder.CreateCondBr(EndCond, LoopBB, AfterBB); // Any new code will be inserted in AfterBB. // 让后面的代码都插入到循环之后的基本块之中 Builder.SetInsertPoint(AfterBB);  当循环体的中间代码被完全生成了之后，我们只需要结束其控制流就可以了。上面的代码记住了循环体最后一个块 (为了接下来的 phi 节点), 然后创建了循环的出口的基本块 (afterloop). 基于循环条件的值，其使用跳转指令来使控制流跳转到合适的地方。我们创建循环出口的基本块是为了做那个跳转，接下来插入的指令应该都在这个块内，所以我们需要把指令的插入点设置在此块中。\n// Add a new entry to the PHI node for the backedge. // 为 phi 节点增加一对新的参数 (后向边) Variable-\u0026gt;addIncoming(NextVar, LoopEndBB); // Restore the unshadowed variable. // 恢复被遮盖的变量 if (OldVal) NamedValues[VarName] = OldVal; else NamedValues.erase(VarName); // for expr always returns 0.0. // 对于 for 循环，其求值结果永远是 0.0 return Constant::getNullValue(Type::getDoubleTy(TheContext)); }  最后的代码进行了一些清理工作。我们首先以 NextVar 的值来更新循环变量 \u0026ndash; 将其插入到定义循环变量的 phi 节点中去。随后我们从符号表中删除了循环变量 (或者是恢复了被遮蔽的旧变量的值). 最后，我们返回 for 表达式的求值结果 \u0026ndash; 0.0.\n就此，我们结束本章教程。在本章，我们为 Kaleidoscope 加入了两种新的控制流结构，并且在实现过程中探索了 LLVM IR 一些应为前端实现者所知的重要方面。在下一章，我们将会大胆一些，将自定义运算符加入我们弱小可怜又无助的小 Kalei.\n5.4 全部代码 下面是本章例子包含的完整代码，拥有 if/then/else 与 for 表达式。使用下面的命令构建这个例子：\n# Compile clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core orcjit native` -O3 -o toy # Run ./toy  #include \u0026quot;../include/KaleidoscopeJIT.h\u0026quot; #include \u0026quot;llvm/ADT/APFloat.h\u0026quot; #include \u0026quot;llvm/ADT/STLExtras.h\u0026quot; #include \u0026quot;llvm/IR/BasicBlock.h\u0026quot; #include \u0026quot;llvm/IR/Constants.h\u0026quot; #include \u0026quot;llvm/IR/DerivedTypes.h\u0026quot; #include \u0026quot;llvm/IR/Function.h\u0026quot; #include \u0026quot;llvm/IR/IRBuilder.h\u0026quot; #include \u0026quot;llvm/IR/Instructions.h\u0026quot; #include \u0026quot;llvm/IR/LLVMContext.h\u0026quot; #include \u0026quot;llvm/IR/LegacyPassManager.h\u0026quot; #include \u0026quot;llvm/IR/Module.h\u0026quot; #include \u0026quot;llvm/IR/Type.h\u0026quot; #include \u0026quot;llvm/IR/Verifier.h\u0026quot; #include \u0026quot;llvm/Support/TargetSelect.h\u0026quot; #include \u0026quot;llvm/Target/TargetMachine.h\u0026quot; #include \u0026quot;llvm/Transforms/InstCombine/InstCombine.h\u0026quot; #include \u0026quot;llvm/Transforms/Scalar.h\u0026quot; #include \u0026quot;llvm/Transforms/Scalar/GVN.h\u0026quot; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cstdint\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace llvm; using namespace llvm::orc; //===----------------------------------------------------------------------===// // Lexer //===----------------------------------------------------------------------===// // The lexer returns tokens [0-255] if it is an unknown character, otherwise one // of these for known things. enum Token { tok_eof = -1, // commands tok_def = -2, tok_extern = -3, // primary tok_identifier = -4, tok_number = -5, // control tok_if = -6, tok_then = -7, tok_else = -8, tok_for = -9, tok_in = -10 }; static std::string IdentifierStr; // Filled in if tok_identifier static double NumVal; // Filled in if tok_number /// gettok - Return the next token from standard input. static int gettok() { static int LastChar = ' '; // Skip any whitespace. while (isspace(LastChar)) LastChar = getchar(); if (isalpha(LastChar)) { // identifier: [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == \u0026quot;def\u0026quot;) return tok_def; if (IdentifierStr == \u0026quot;extern\u0026quot;) return tok_extern; if (IdentifierStr == \u0026quot;if\u0026quot;) return tok_if; if (IdentifierStr == \u0026quot;then\u0026quot;) return tok_then; if (IdentifierStr == \u0026quot;else\u0026quot;) return tok_else; if (IdentifierStr == \u0026quot;for\u0026quot;) return tok_for; if (IdentifierStr == \u0026quot;in\u0026quot;) return tok_in; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), nullptr); return tok_number; } if (LastChar == '#') { // Comment until end of line. do LastChar = getchar(); while (LastChar != EOF \u0026amp;\u0026amp; LastChar != '\\n' \u0026amp;\u0026amp; LastChar != '\\r'); if (LastChar != EOF) return gettok(); } // Check for end of file. Don't eat the EOF. if (LastChar == EOF) return tok_eof; // Otherwise, just return the character as its ascii value. int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// // Abstract Syntax Tree (aka Parse Tree) //===----------------------------------------------------------------------===// namespace { /// ExprAST - Base class for all expression nodes. class ExprAST { public: virtual ~ExprAST() = default; virtual Value *codegen() = 0; }; /// NumberExprAST - Expression class for numeric literals like \u0026quot;1.0\u0026quot;. class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double Val) : Val(Val) {} Value *codegen() override; }; /// VariableExprAST - Expression class for referencing a variable, like \u0026quot;a\u0026quot;. class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string \u0026amp;Name) : Name(Name) {} Value *codegen() override; }; /// BinaryExprAST - Expression class for a binary operator. class BinaryExprAST : public ExprAST { char Op; std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS, RHS; public: BinaryExprAST(char Op, std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS, std::unique_ptr\u0026lt;ExprAST\u0026gt; RHS) : Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {} Value *codegen() override; }; /// CallExprAST - Expression class for function calls. class CallExprAST : public ExprAST { std::string Callee; std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args; public: CallExprAST(const std::string \u0026amp;Callee, std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args) : Callee(Callee), Args(std::move(Args)) {} Value *codegen() override; }; /// IfExprAST - Expression class for if/then/else. class IfExprAST : public ExprAST { std::unique_ptr\u0026lt;ExprAST\u0026gt; Cond, Then, Else; public: IfExprAST(std::unique_ptr\u0026lt;ExprAST\u0026gt; Cond, std::unique_ptr\u0026lt;ExprAST\u0026gt; Then, std::unique_ptr\u0026lt;ExprAST\u0026gt; Else) : Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {} Value *codegen() override; }; /// ForExprAST - Expression class for for/in. class ForExprAST : public ExprAST { std::string VarName; std::unique_ptr\u0026lt;ExprAST\u0026gt; Start, End, Step, Body; public: ForExprAST(const std::string \u0026amp;VarName, std::unique_ptr\u0026lt;ExprAST\u0026gt; Start, std::unique_ptr\u0026lt;ExprAST\u0026gt; End, std::unique_ptr\u0026lt;ExprAST\u0026gt; Step, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : VarName(VarName), Start(std::move(Start)), End(std::move(End)), Step(std::move(Step)), Body(std::move(Body)) {} Value *codegen() override; }; /// PrototypeAST - This class represents the \u0026quot;prototype\u0026quot; for a function, /// which captures its name, and its argument names (thus implicitly the number /// of arguments the function takes). class PrototypeAST { std::string Name; std::vector\u0026lt;std::string\u0026gt; Args; public: PrototypeAST(const std::string \u0026amp;Name, std::vector\u0026lt;std::string\u0026gt; Args) : Name(Name), Args(std::move(Args)) {} Function *codegen(); const std::string \u0026amp;getName() const { return Name; } }; /// FunctionAST - This class represents a function definition itself. class FunctionAST { std::unique_ptr\u0026lt;PrototypeAST\u0026gt; Proto; std::unique_ptr\u0026lt;ExprAST\u0026gt; Body; public: FunctionAST(std::unique_ptr\u0026lt;PrototypeAST\u0026gt; Proto, std::unique_ptr\u0026lt;ExprAST\u0026gt; Body) : Proto(std::move(Proto)), Body(std::move(Body)) {} Function *codegen(); }; } // end anonymous namespace //===----------------------------------------------------------------------===// // Parser //===----------------------------------------------------------------------===// /// CurTok/getNextToken - Provide a simple token buffer. CurTok is the current /// token the parser is looking at. getNextToken reads another token from the /// lexer and updates CurTok with its results. static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence - This holds the precedence for each binary operator that is /// defined. static std::map\u0026lt;char, int\u0026gt; BinopPrecedence; /// GetTokPrecedence - Get the precedence of the pending binary operator token. static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // Make sure it's a declared binop. int TokPrec = BinopPrecedence[CurTok]; if (TokPrec \u0026lt;= 0) return -1; return TokPrec; } /// LogError* - These are little helper functions for error handling. std::unique_ptr\u0026lt;ExprAST\u0026gt; LogError(const char *Str) { fprintf(stderr, \u0026quot;Error: %s\\n\u0026quot;, Str); return nullptr; } std::unique_ptr\u0026lt;PrototypeAST\u0026gt; LogErrorP(const char *Str) { LogError(Str); return nullptr; } static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseExpression(); /// numberexpr ::= number static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseNumberExpr() { auto Result = std::make_unique\u0026lt;NumberExprAST\u0026gt;(NumVal); getNextToken(); // consume the number return std::move(Result); } /// parenexpr ::= '(' expression ')' static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseParenExpr() { getNextToken(); // eat (. auto V = ParseExpression(); if (!V) return nullptr; if (CurTok != ')') return LogError(\u0026quot;expected ')'\u0026quot;); getNextToken(); // eat ). return V; } /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); // eat identifier. if (CurTok != '(') // Simple variable ref. return std::make_unique\u0026lt;VariableExprAST\u0026gt;(IdName); // Call. getNextToken(); // eat ( std::vector\u0026lt;std::unique_ptr\u0026lt;ExprAST\u0026gt;\u0026gt; Args; if (CurTok != ')') { while (true) { if (auto Arg = ParseExpression()) Args.push_back(std::move(Arg)); else return nullptr; if (CurTok == ')') break; if (CurTok != ',') return LogError(\u0026quot;Expected ')' or ',' in argument list\u0026quot;); getNextToken(); } } // Eat the ')'. getNextToken(); return std::make_unique\u0026lt;CallExprAST\u0026gt;(IdName, std::move(Args)); } /// ifexpr ::= 'if' expression 'then' expression 'else' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseIfExpr() { getNextToken(); // eat the if. // condition. auto Cond = ParseExpression(); if (!Cond) return nullptr; if (CurTok != tok_then) return LogError(\u0026quot;expected then\u0026quot;); getNextToken(); // eat the then auto Then = ParseExpression(); if (!Then) return nullptr; if (CurTok != tok_else) return LogError(\u0026quot;expected else\u0026quot;); getNextToken(); auto Else = ParseExpression(); if (!Else) return nullptr; return std::make_unique\u0026lt;IfExprAST\u0026gt;(std::move(Cond), std::move(Then), std::move(Else)); } /// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseForExpr() { getNextToken(); // eat the for. if (CurTok != tok_identifier) return LogError(\u0026quot;expected identifier after for\u0026quot;); std::string IdName = IdentifierStr; getNextToken(); // eat identifier. if (CurTok != '=') return LogError(\u0026quot;expected '=' after for\u0026quot;); getNextToken(); // eat '='. auto Start = ParseExpression(); if (!Start) return nullptr; if (CurTok != ',') return LogError(\u0026quot;expected ',' after for start value\u0026quot;); getNextToken(); auto End = ParseExpression(); if (!End) return nullptr; // The step value is optional. std::unique_ptr\u0026lt;ExprAST\u0026gt; Step; if (CurTok == ',') { getNextToken(); Step = ParseExpression(); if (!Step) return nullptr; } if (CurTok != tok_in) return LogError(\u0026quot;expected 'in' after for\u0026quot;); getNextToken(); // eat 'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return std::make_unique\u0026lt;ForExprAST\u0026gt;(IdName, std::move(Start), std::move(End), std::move(Step), std::move(Body)); } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr /// ::= ifexpr /// ::= forexpr static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParsePrimary() { switch (CurTok) { default: return LogError(\u0026quot;unknown token when expecting an expression\u0026quot;); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); } } /// binoprhs /// ::= ('+' primary)* static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseBinOpRHS(int ExprPrec, std::unique_ptr\u0026lt;ExprAST\u0026gt; LHS) { // If this is a binop, find its precedence. while (true) { int TokPrec = GetTokPrecedence(); // If this is a binop that binds at least as tightly as the current binop, // consume it, otherwise we are done. if (TokPrec \u0026lt; ExprPrec) return LHS; // Okay, we know this is a binop. int BinOp = CurTok; getNextToken(); // eat binop // Parse the primary expression after the binary operator. auto RHS = ParsePrimary(); if (!RHS) return nullptr; // If BinOp binds less tightly with RHS than the operator after RHS, let // the pending operator take RHS as its LHS. int NextPrec = GetTokPrecedence(); if (TokPrec \u0026lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS)); if (!RHS) return nullptr; } // Merge LHS/RHS. LHS = std::make_unique\u0026lt;BinaryExprAST\u0026gt;(BinOp, std::move(LHS), std::move(RHS)); } } /// expression /// ::= primary binoprhs /// static std::unique_ptr\u0026lt;ExprAST\u0026gt; ParseExpression() { auto LHS = ParsePrimary(); if (!LHS) return nullptr; return ParseBinOpRHS(0, std::move(LHS)); } /// prototype /// ::= id '(' id* ')' static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParsePrototype() { if (CurTok != tok_identifier) return LogErrorP(\u0026quot;Expected function name in prototype\u0026quot;); std::string FnName = IdentifierStr; getNextToken(); if (CurTok != '(') return LogErrorP(\u0026quot;Expected '(' in prototype\u0026quot;); std::vector\u0026lt;std::string\u0026gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return LogErrorP(\u0026quot;Expected ')' in prototype\u0026quot;); // success. getNextToken(); // eat ')'. return std::make_unique\u0026lt;PrototypeAST\u0026gt;(FnName, std::move(ArgNames)); } /// definition ::= 'def' prototype expression static std::unique_ptr\u0026lt;FunctionAST\u0026gt; ParseDefinition() { getNextToken(); // eat def. auto Proto = ParsePrototype(); if (!Proto) return nullptr; if (auto E = ParseExpression()) return std::make_unique\u0026lt;FunctionAST\u0026gt;(std::move(Proto), std::move(E)); return nullptr; } /// toplevelexpr ::= expression static std::unique_ptr\u0026lt;FunctionAST\u0026gt; ParseTopLevelExpr() { if (auto E = ParseExpression()) { // Make an anonymous proto. auto Proto = std::make_unique\u0026lt;PrototypeAST\u0026gt;(\u0026quot;__anon_expr\u0026quot;, std::vector\u0026lt;std::string\u0026gt;()); return std::make_unique\u0026lt;FunctionAST\u0026gt;(std::move(Proto), std::move(E)); } return nullptr; } /// external ::= 'extern' prototype static std::unique_ptr\u0026lt;PrototypeAST\u0026gt; ParseExtern() { getNextToken(); // eat extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// // Code Generation //===----------------------------------------------------------------------===// static std::unique_ptr\u0026lt;LLVMContext\u0026gt; TheContext; static std::unique_ptr\u0026lt;Module\u0026gt; TheModule; static std::unique_ptr\u0026lt;IRBuilder\u0026lt;\u0026gt;\u0026gt; Builder; static std::map\u0026lt;std::string, Value *\u0026gt; NamedValues; static std::unique_ptr\u0026lt;legacy::FunctionPassManager\u0026gt; TheFPM; static std::unique_ptr\u0026lt;KaleidoscopeJIT\u0026gt; TheJIT; static std::map\u0026lt;std::string, std::unique_ptr\u0026lt;PrototypeAST\u0026gt;\u0026gt; FunctionProtos; static ExitOnError ExitOnErr; Value *LogErrorV(const char *Str) { LogError(Str); return nullptr; } Function *getFunction(std::string Name) { // First, see if the function has already been added to the current module. if (auto *F = TheModule-\u0026gt;getFunction(Name)) return F; // If not, check whether we can codegen the declaration from some existing // prototype. auto FI = FunctionProtos.find(Name); if (FI != FunctionProtos.end()) return FI-\u0026gt;second-\u0026gt;codegen(); // If no existing prototype exists, return null. return nullptr; } Value *NumberExprAST::codegen() { return ConstantFP::get(*TheContext, APFloat(Val)); } Value *VariableExprAST::codegen() { // Look this variable up in the function. Value *V = NamedValues[Name]; if (!V) return LogErrorV(\u0026quot;Unknown variable name\u0026quot;); return V; } Value *BinaryExprAST::codegen() { Value *L = LHS-\u0026gt;codegen(); Value *R = RHS-\u0026gt;codegen(); if (!L || !R) return nullptr; switch (Op) { case '+': return Builder-\u0026gt;CreateFAdd(L, R, \u0026quot;addtmp\u0026quot;); case '-': return Builder-\u0026gt;CreateFSub(L, R, \u0026quot;subtmp\u0026quot;); case '*': return Builder-\u0026gt;CreateFMul(L, R, \u0026quot;multmp\u0026quot;); case '\u0026lt;': L = Builder-\u0026gt;CreateFCmpULT(L, R, \u0026quot;cmptmp\u0026quot;); // Convert bool 0/1 to double 0.0 or 1.0 return Builder-\u0026gt;CreateUIToFP(L, Type::getDoubleTy(*TheContext), \u0026quot;booltmp\u0026quot;); default: return LogErrorV(\u0026quot;invalid binary operator\u0026quot;); } } Value *CallExprAST::codegen() { // Look up the name in the global module table. Function *CalleeF = getFunction(Callee); if (!CalleeF) return LogErrorV(\u0026quot;Unknown function referenced\u0026quot;); // If argument mismatch error. if (CalleeF-\u0026gt;arg_size() != Args.size()) return LogErrorV(\u0026quot;Incorrect # arguments passed\u0026quot;); std::vector\u0026lt;Value *\u0026gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-\u0026gt;codegen()); if (!ArgsV.back()) return nullptr; } return Builder-\u0026gt;CreateCall(CalleeF, ArgsV, \u0026quot;calltmp\u0026quot;); } Value *IfExprAST::codegen() { Value *CondV = Cond-\u0026gt;codegen(); if (!CondV) return nullptr; // Convert condition to a bool by comparing non-equal to 0.0. CondV = Builder-\u0026gt;CreateFCmpONE( CondV, ConstantFP::get(*TheContext, APFloat(0.0)), \u0026quot;ifcond\u0026quot;); Function *TheFunction = Builder-\u0026gt;GetInsertBlock()-\u0026gt;getParent(); // Create blocks for the then and else cases. Insert the 'then' block at the // end of the function. BasicBlock *ThenBB = BasicBlock::Create(*TheContext, \u0026quot;then\u0026quot;, TheFunction); BasicBlock *ElseBB = BasicBlock::Create(*TheContext, \u0026quot;else\u0026quot;); BasicBlock *MergeBB = BasicBlock::Create(*TheContext, \u0026quot;ifcont\u0026quot;); Builder-\u0026gt;CreateCondBr(CondV, ThenBB, ElseBB); // Emit then value. Builder-\u0026gt;SetInsertPoint(ThenBB); Value *ThenV = Then-\u0026gt;codegen(); if (!ThenV) return nullptr; Builder-\u0026gt;CreateBr(MergeBB); // Codegen of 'Then' can change the current block, update ThenBB for the PHI. ThenBB = Builder-\u0026gt;GetInsertBlock(); // Emit else block. TheFunction-\u0026gt;getBasicBlockList().push_back(ElseBB); Builder-\u0026gt;SetInsertPoint(ElseBB); Value *ElseV = Else-\u0026gt;codegen(); if (!ElseV) return nullptr; Builder-\u0026gt;CreateBr(MergeBB); // Codegen of 'Else' can change the current block, update ElseBB for the PHI. ElseBB = Builder-\u0026gt;GetInsertBlock(); // Emit merge block. TheFunction-\u0026gt;getBasicBlockList().push_back(MergeBB); Builder-\u0026gt;SetInsertPoint(MergeBB); PHINode *PN = Builder-\u0026gt;CreatePHI(Type::getDoubleTy(*TheContext), 2, \u0026quot;iftmp\u0026quot;); PN-\u0026gt;addIncoming(ThenV, ThenBB); PN-\u0026gt;addIncoming(ElseV, ElseBB); return PN; } // Output for-loop as: // ... // start = startexpr // goto loop // loop: // variable = phi [start, loopheader], [nextvariable, loopend] // ... // bodyexpr // ... // loopend: // step = stepexpr // nextvariable = variable + step // endcond = endexpr // br endcond, loop, endloop // outloop: Value *ForExprAST::codegen() { // Emit the start code first, without 'variable' in scope. Value *StartVal = Start-\u0026gt;codegen(); if (!StartVal) return nullptr; // Make the new basic block for the loop header, inserting after current // block. Function *TheFunction = Builder-\u0026gt;GetInsertBlock()-\u0026gt;getParent(); BasicBlock *PreheaderBB = Builder-\u0026gt;GetInsertBlock(); BasicBlock *LoopBB = BasicBlock::Create(*TheContext, \u0026quot;loop\u0026quot;, TheFunction); // Insert an explicit fall through from the current block to the LoopBB. Builder-\u0026gt;CreateBr(LoopBB); // Start insertion in LoopBB. Builder-\u0026gt;SetInsertPoint(LoopBB); // Start the PHI node with an entry for Start. PHINode *Variable = Builder-\u0026gt;CreatePHI(Type::getDoubleTy(*TheContext), 2, VarName); Variable-\u0026gt;addIncoming(StartVal, PreheaderBB); // Within the loop, the variable is defined equal to the PHI node. If it // shadows an existing variable, we have to restore it, so save it now. Value *OldVal = NamedValues[VarName]; NamedValues[VarName] = Variable; // Emit the body of the loop. This, like any other expr, can change the // current BB. Note that we ignore the value computed by the body, but don't // allow an error. if (!Body-\u0026gt;codegen()) return nullptr; // Emit the step value. Value *StepVal = nullptr; if (Step) { StepVal = Step-\u0026gt;codegen(); if (!StepVal) return nullptr; } else { // If not specified, use 1.0. StepVal = ConstantFP::get(*TheContext, APFloat(1.0)); } Value *NextVar = Builder-\u0026gt;CreateFAdd(Variable, StepVal, \u0026quot;nextvar\u0026quot;); // Compute the end condition. Value *EndCond = End-\u0026gt;codegen(); if (!EndCond) return nullptr; // Convert condition to a bool by comparing non-equal to 0.0. EndCond = Builder-\u0026gt;CreateFCmpONE( EndCond, ConstantFP::get(*TheContext, APFloat(0.0)), \u0026quot;loopcond\u0026quot;); // Create the \u0026quot;after loop\u0026quot; block and insert it. BasicBlock *LoopEndBB = Builder-\u0026gt;GetInsertBlock(); BasicBlock *AfterBB = BasicBlock::Create(*TheContext, \u0026quot;afterloop\u0026quot;, TheFunction); // Insert the conditional branch into the end of LoopEndBB. Builder-\u0026gt;CreateCondBr(EndCond, LoopBB, AfterBB); // Any new code will be inserted in AfterBB. Builder-\u0026gt;SetInsertPoint(AfterBB); // Add a new entry to the PHI node for the backedge. Variable-\u0026gt;addIncoming(NextVar, LoopEndBB); // Restore the unshadowed variable. if (OldVal) NamedValues[VarName] = OldVal; else NamedValues.erase(VarName); // for expr always returns 0.0. return Constant::getNullValue(Type::getDoubleTy(*TheContext)); } Function *PrototypeAST::codegen() { // Make the function type: double(double,double) etc. std::vector\u0026lt;Type *\u0026gt; Doubles(Args.size(), Type::getDoubleTy(*TheContext)); FunctionType *FT = FunctionType::get(Type::getDoubleTy(*TheContext), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get()); // Set names for all arguments. unsigned Idx = 0; for (auto \u0026amp;Arg : F-\u0026gt;args()) Arg.setName(Args[Idx++]); return F; } Function *FunctionAST::codegen() { // Transfer ownership of the prototype to the FunctionProtos map, but keep a // reference to it for use below. auto \u0026amp;P = *Proto; FunctionProtos[Proto-\u0026gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr; // Create a new basic block to start insertion into. BasicBlock *BB = BasicBlock::Create(*TheContext, \u0026quot;entry\u0026quot;, TheFunction); Builder-\u0026gt;SetInsertPoint(BB); // Record the function arguments in the NamedValues map. NamedValues.clear(); for (auto \u0026amp;Arg : TheFunction-\u0026gt;args()) NamedValues[std::string(Arg.getName())] = \u0026amp;Arg; if (Value *RetVal = Body-\u0026gt;codegen()) { // Finish off the function. Builder-\u0026gt;CreateRet(RetVal); // Validate the generated code, checking for consistency. verifyFunction(*TheFunction); // Run the optimizer on the function. TheFPM-\u0026gt;run(*TheFunction); return TheFunction; } // Error reading body, remove function. TheFunction-\u0026gt;eraseFromParent(); return nullptr; } //===----------------------------------------------------------------------===// // Top-Level parsing and JIT Driver //===----------------------------------------------------------------------===// static void InitializeModuleAndPassManager() { // Open a new module. TheContext = std::make_unique\u0026lt;LLVMContext\u0026gt;(); TheModule = std::make_unique\u0026lt;Module\u0026gt;(\u0026quot;my cool jit\u0026quot;, *TheContext); TheModule-\u0026gt;setDataLayout(TheJIT-\u0026gt;getDataLayout()); // Create a new builder for the module. Builder = std::make_unique\u0026lt;IRBuilder\u0026lt;\u0026gt;\u0026gt;(*TheContext); // Create a new pass manager attached to it. TheFPM = std::make_unique\u0026lt;legacy::FunctionPassManager\u0026gt;(TheModule.get()); // Do simple \u0026quot;peephole\u0026quot; optimizations and bit-twiddling optzns. TheFPM-\u0026gt;add(createInstructionCombiningPass()); // Reassociate expressions. TheFPM-\u0026gt;add(createReassociatePass()); // Eliminate Common SubExpressions. TheFPM-\u0026gt;add(createGVNPass()); // Simplify the control flow graph (deleting unreachable blocks, etc). TheFPM-\u0026gt;add(createCFGSimplificationPass()); TheFPM-\u0026gt;doInitialization(); } static void HandleDefinition() { if (auto FnAST = ParseDefinition()) { if (auto *FnIR = FnAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read function definition:\u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); ExitOnErr(TheJIT-\u0026gt;addModule( ThreadSafeModule(std::move(TheModule), std::move(TheContext)))); InitializeModuleAndPassManager(); } } else { // Skip token for error recovery. getNextToken(); } } static void HandleExtern() { if (auto ProtoAST = ParseExtern()) { if (auto *FnIR = ProtoAST-\u0026gt;codegen()) { fprintf(stderr, \u0026quot;Read extern: \u0026quot;); FnIR-\u0026gt;print(errs()); fprintf(stderr, \u0026quot;\\n\u0026quot;); FunctionProtos[ProtoAST-\u0026gt;getName()] = std::move(ProtoAST); } } else { // Skip token for error recovery. getNextToken(); } } static void HandleTopLevelExpression() { // Evaluate a top-level expression into an anonymous function. if (auto FnAST = ParseTopLevelExpr()) { if (FnAST-\u0026gt;codegen()) { // Create a ResourceTracker to track JIT'd memory allocated to our // anonymous expression -- that way we can free it after executing. auto RT = TheJIT-\u0026gt;getMainJITDylib().createResourceTracker(); auto TSM = ThreadSafeModule(std::move(TheModule), std::move(TheContext)); ExitOnErr(TheJIT-\u0026gt;addModule(std::move(TSM), RT)); InitializeModuleAndPassManager(); // Search the JIT for the __anon_expr symbol. auto ExprSymbol = ExitOnErr(TheJIT-\u0026gt;lookup(\u0026quot;__anon_expr\u0026quot;)); // Get the symbol's address and cast it to the right type (takes no // arguments, returns a double) so we can call it as a native function. double (*FP)() = (double (*)())(intptr_t)ExprSymbol.getAddress(); fprintf(stderr, \u0026quot;Evaluated to %f\\n\u0026quot;, FP()); // Delete the anonymous expression module from the JIT. ExitOnErr(RT-\u0026gt;remove()); } } else { // Skip token for error recovery. getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (true) { fprintf(stderr, \u0026quot;ready\u0026gt; \u0026quot;); switch (CurTok) { case tok_eof: return; case ';': // ignore top-level semicolons. getNextToken(); break; case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // \u0026quot;Library\u0026quot; functions that can be \u0026quot;extern'd\u0026quot; from user code. //===----------------------------------------------------------------------===// #ifdef _WIN32 #define DLLEXPORT __declspec(dllexport) #else #define DLLEXPORT #endif /// putchard - putchar that takes a double and returns 0. extern \u0026quot;C\u0026quot; DLLEXPORT double putchard(double X) { fputc((char)X, stderr); return 0; } /// printd - printf that takes a double prints it as \u0026quot;%f\\n\u0026quot;, returning 0. extern \u0026quot;C\u0026quot; DLLEXPORT double printd(double X) { fprintf(stderr, \u0026quot;%f\\n\u0026quot;, X); return 0; } //===----------------------------------------------------------------------===// // Main driver code. //===----------------------------------------------------------------------===// int main() { InitializeNativeTarget(); InitializeNativeTargetAsmPrinter(); InitializeNativeTargetAsmParser(); // Install standard binary operators. // 1 is lowest precedence. BinopPrecedence['\u0026lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; // highest. // Prime the first token. fprintf(stderr, \u0026quot;ready\u0026gt; \u0026quot;); getNextToken(); TheJIT = ExitOnErr(KaleidoscopeJIT::Create()); InitializeModuleAndPassManager(); // Run the main \u0026quot;interpreter loop\u0026quot; now. MainLoop(); return 0; } ","date":"2022-01-15","permalink":"https://blog.origami404.top/llvm-kaleidoscope/2022-01-kaleidoscope-ch-5/","tags":["编译原理","编译前端","LLVM","翻译"],"title":"LLVM Kaleidoscope 第 5 章 扩展语言：控制流"},{"content":"前言 上大学了, 终于有大段的时间来整理数学和物理学内容了.\n本文有其思想上的参考: 3b1b: 发明新数学是怎样一种体验？\n\u0026ldquo;最原始的\u0026quot;双线性二元运算 让我们来考虑矢量的运算吧!\n假如我们需要在线性空间 $\\mathbb{V}$ 上定义二元运算, 显然我们会希望这个运算至少是线性的, 否则为啥我们要在线性空间上搞呢. 同时如果一个二元运算是双线性的(就是说对于两个操作数而言它都是线性的), 那么我们只需要对 $\\mathbb{V}$ 的基底定义此运算即可.\n换句话说, 对于双线性运算 $\\mathbf{a} \\otimes \\mathbf{b}$, 我们可以将其按基底展开:\n$$ \\begin{aligned} \\mathbf{a} \\otimes \\mathbf{b} \u0026amp;= (\\sum_{i=1}^n a_i \\mathbf{e_i}) \\otimes (\\sum_{i=1}^n b_i \\mathbf{e_i}) \\\\ \u0026amp;= \\sum_{i=1}^n \\sum_{j=1}^n a_i b_j (\\mathbf{e_i} \\otimes \\mathbf{e_j}) \\end{aligned} $$\n那么, 我们只需要定义所有的 $\\mathbf{e_i} \\otimes \\mathbf{e_j}$ (一共 $n^2$ 个) 即可.\n 等等, 这都啥跟啥啊????\n 抽象的开始: $\\mathbb{R}^2$ 下面我们来举一个具体点的例子. 考虑 $\\mathbb{R}^2$ 上的正交归一基 $\\mathbf{i}, \\mathbf{j}$, 上面的式子化成:\n$$ \\begin{aligned} \\mathbf{a} \\otimes \\mathbf{b} \u0026amp;= (a_1 \\mathbf{i} + a_2 \\mathbf{j}) \\otimes (b_1 \\mathbf{i} + b_2 \\mathbf{j}) \\\\ \u0026amp;= a_1 b_1 (\\mathbf{i} \\otimes \\mathbf{i}) + a_1 b_2 (\\mathbf{i} \\otimes \\mathbf{j}) \\\\ \u0026amp;+ a_2 b_1 (\\mathbf{j} \\otimes \\mathbf{i}) + a_2 b_2 (\\mathbf{j} \\otimes \\mathbf{j}) \\end{aligned} $$\n注意我们并没有要求 $\\otimes$ 是交换的, 故一般来讲 $\\mathbf{i} \\otimes \\mathbf{j} \\neq \\mathbf{j} \\otimes \\mathbf{i}$.\n现在我们可以来定义我们的 \u0026ldquo;运算\u0026rdquo; 了.\n内积 我们先来一个最简单的, 我们如下定义基底之间的 $\\otimes$:\n$$ \\begin{aligned} \u0026amp; \\mathbf{i} \\otimes \\mathbf{i} = 1 \u0026amp;\\mathbf{i} \\otimes \\mathbf{j} = 0\\\\ \u0026amp; \\mathbf{j} \\otimes \\mathbf{i} = 0 \u0026amp;\\mathbf{j} \\otimes \\mathbf{j} = 1 \\end{aligned} $$\n代入上面的式子, 我们就得到了内积(inner product), 又叫数量积, 点积:\n$$ \\begin{aligned} \\mathbf{a} \\otimes \\mathbf{b} = a_1 b_1 + a_2 b_2 \\end{aligned} $$\n这个运算有其专有的符号, 我们记作 $\\mathbb{a} \\cdot \\mathbb{b}$.\n同时, 由我们的定义可以看出, 点积具有交换律\n高中叉乘 (二维有向面积) 相信大家在高中的解析几何的结论里都记过矢量叉乘求三角形面积的结论吧. 现在我们来定义一个叉乘.\n 不严谨警告: 叉乘严格来说只在三维空间有定义(原因下文会讲), 所以这里定义出的两个二维矢量的\u0026quot;叉乘\u0026quot;应该是两个三维矢量$(a_1, a_2, 0)$, $(a_1, a_2, 0)$之间叉乘的结果的模.\n 如下定义基底之间的 $\\otimes$:\n$$ \\begin{aligned} \u0026amp; \\mathbf{i} \\otimes \\mathbf{i} = 0 \u0026amp;\\mathbf{i} \\otimes \\mathbf{j} = 1\\\\ \u0026amp; \\mathbf{j} \\otimes \\mathbf{i} = -1 \u0026amp;\\mathbf{j} \\otimes \\mathbf{j} = 0 \\end{aligned} $$\n代入上面的式子, 我们有:\n$$ \\begin{aligned} \\mathbf{a} \\otimes \\mathbf{b} = a_1 b_2 - a_2 b_1 \\end{aligned} $$\n这个就是我们的二维假叉乘. 它同时也跟行列式有关, 事实上:\n$$ \\mathbf{a} \\otimes \\mathbf{b} = \\begin{vmatrix} a_1 \u0026amp; b_1 \\\\ a_2 \u0026amp; b_2 \\end{vmatrix} = a_1 b_2 - a_2 b_1 $$\n原因等讲完外代数就有了.\n真的叉乘  不知道叉乘的快去学\n  我们先暂时来到 $\\mathbb{R}^3$ 来看看真的叉乘. (现在我们的基底是 $\\mathbf{i},\\ \\mathbf{j},\\ \\mathbf{k}$ 了)\n 首先我们要玩大一点, 为啥我们的$\\otimes$出来的结果一定得是是一个数呢? 假如我们塞其他的对象进去会怎么样?\n如下定义基底之间的 $\\otimes$:\n$$ \\begin{aligned} \u0026amp; \\mathbf{i} \\otimes \\mathbf{i} = \\mathbf{0} \\quad \u0026amp; \\mathbf{i} \\otimes \\mathbf{j} = \\mathbf{k} \\quad \u0026amp; \\mathbf{i} \\otimes \\mathbf{k} = \\mathbf{j} \\\\ \u0026amp; \\mathbf{j} \\otimes \\mathbf{i} = -\\mathbf{k} \\quad \u0026amp; \\mathbf{j} \\otimes \\mathbf{j} = \\mathbf{0} \\quad \u0026amp; \\mathbf{j} \\otimes \\mathbf{k} = \\mathbf{i} \\\\ \u0026amp; \\mathbf{k} \\otimes \\mathbf{i} = -\\mathbf{j} \\quad \u0026amp; \\mathbf{k} \\otimes \\mathbf{j} = -\\mathbf{i} \\quad \u0026amp; \\mathbf{k} \\otimes \\mathbf{k} = \\mathbf{0} \\\\ \\end{aligned} $$\n也就是说, 我们进行一个基底的轮换, 那么我们就会有三维的叉积:\n$$ \\begin{aligned} \\mathbf{a} \\otimes \\mathbf{b} = \u0026amp; -a_1 b_1\\mathbf{0} + a_1 b_2\\mathbf{k} - a_1 b_3\\mathbf{j} \\\\ \u0026amp; -a_2 b_1\\mathbf{k} - a_2 b_2\\mathbf{0} + a_2 b_3\\mathbf{i} \\\\ \u0026amp; +a_3 b_1\\mathbf{j} - a_3 b_2\\mathbf{i} - a_3 b_3\\mathbf{0} \\\\ = \u0026amp;(a_2 b_3-a_3 b_2)\\mathbf{i} + (a_3 b_1-a_1 b_3)\\mathbf{j} + (a_1 b_2-a_2 b_1)\\mathbf{k} \\\\ \\end{aligned} $$\n叉积有其专有的符号: $\\mathbf{a} \\times \\mathbf{b}$, 并且有一个非常重要的性质: 反交换律:\n$$ \\mathbf{a} \\times \\mathbf{b} = - \\mathbf{b} \\times \\mathbf{a} $$\n(交换后符号取反)\n 好的, 现在我们回到 $\\mathbf{R}^2$\n 张量积 我们可以偷懒一点: 为什么一定要算呢?\n我们干脆就承认下面这些:\n$$ \\begin{aligned} \u0026amp; \\mathbf{i} \\otimes \\mathbf{i} \u0026amp;\\mathbf{i} \\otimes \\mathbf{j}\\\\ \u0026amp; \\mathbf{j} \\otimes \\mathbf{i} \u0026amp;\\mathbf{j} \\otimes \\mathbf{j} \\end{aligned} $$\n是独立的对象好了. 就好像 $\\Delta x$ 是一块的一样, 上面的四个东西也分别是四个一块的对象.\n现在我们会发现, 所有 $\\mathbf{a} \\otimes \\mathbf{b}$ 都是上面的四个东西的线性组合, 也就是说我们去到了一个新的空间, 这个空间是一个四维的线性空间.\n外积/楔积 (wedge product) 我们如下定义:\n$$ \\begin{aligned} \u0026amp; \\mathbf{i} \\otimes \\mathbf{i} = 0 \u0026amp; \\mathbf{i} \\otimes \\mathbf{j} = \\mathbf{i} \\otimes \\mathbf{j} \\\\ \u0026amp; \\mathbf{j} \\otimes \\mathbf{i} = -\\mathbf{i} \\otimes \\mathbf{j} \u0026amp; \\mathbf{j} \\otimes \\mathbf{j} = 0 \\end{aligned} $$\n换句话讲, 我们构建一个新的由不同基底组成的对象, 并且让它 对基底的顺序敏感, 在基底顺序为自然排列的时候就是正的, 每换一下相邻两个基底的顺序就是负的.\n这种运算有其独有的名字, 外积/楔积 (wedge product), 记作 $\\mathbf{i} \\wedge \\mathbf{j}$. 像这种具有反交换律且有双线性的性质被称为交替双线性.\n楔积可以用来定义行列式.\n对称积(我自己起的名字, 一种具有对称双线性的运算) $$ \\begin{aligned} \u0026amp; \\mathbf{i} \\otimes \\mathbf{i} = 0 \u0026amp; \\mathbf{i} \\otimes \\mathbf{j} = \\mathbf{i} \\otimes \\mathbf{j} \\\\ \u0026amp; \\mathbf{j} \\otimes \\mathbf{i} = \\mathbf{i} \\otimes \\mathbf{j} \u0026amp; \\mathbf{j} \\otimes \\mathbf{j} = 0 \\end{aligned} $$\n同上构建新的由不同基底组成的对象, 并且让其对基底的顺序 不 敏感, 也就是说让其具有交换性.\n这种运算暂时还没有名字, 但是其具有的交换律并且有双线性的性质被称为对称双线性.\n这种运算可以拿来定义积和式. 维基百科: 积和式\n","date":"2021-09-30","permalink":"https://blog.origami404.top/post/2021-09-constructive-def-of-vector-operation/","tags":["数学","线代","新观点"],"title":"矢量运算与高阶线性结构的构造性定义"},{"content":"前置 这篇文章有些前置知识我默认读者是知道的, 比如矢量和线性空间(wiki, 知乎)的概念. 具体来讲, 我希望读者能完全理解这句话: \u0026ldquo;基底通过线性组合张成线性空间\u0026rdquo;. 但更加重要的是, 我希望读者能够放开胆子, 接受并批判地思考与新的语言与概念. 文中有些地方我特意没有使用书本的符号, 为的就是让读者直接判断他自己到底是在跟着文章思路走还是靠课本里记下的结论硬看. 通过这篇文章, 我希望能有更多人开始 \u0026ldquo;思考\u0026rdquo; 和 \u0026ldquo;创造\u0026rdquo; 数学, 穿过数学高冷的表面, 看到数学定义背后的 \u0026ldquo;动机\u0026rdquo; 和 \u0026ldquo;深意\u0026rdquo;, 最终享受数学, 而不是只是跟着课本学点计算.\n要知道, 数学家也是人. 一旦你觉得有什么东西是反人类的, 它背后一定是有自己的逻辑. 这里的逻辑, 是数学定义背后数学家们思考的内在的直觉的人的逻辑, 而不完全是死的客观精准的数理逻辑.\n建议餐前食用: 3b1b: 发明新数学是怎样一种体验？\n餐后或餐中可以结合: 3b1b: 线性代数的本质\n比起纯粹的几何直观, 我更看重一种 \u0026ldquo;符号上的直观\u0026rdquo;, 也就是说, 你得把这一套数学符号, 当作与生俱来的, 自然的东西. 所谓直观学习, 不是把所有东西都归纳成你的 \u0026ldquo;直观\u0026rdquo;, 而是让你能把更多的东西变成你的直观.\n鸡汤灌得够多了, 让我们开始吧.\n楔积 对一个 $n$ 维的空间, 什么是它里面一个\u0026quot;几何体\u0026quot;的\u0026quot;体积\u0026quot;呢?\n 所谓\u0026quot;面积\u0026quot;就是 $2$ 维的体积, 所以下面可能我不会很严格地区分这两个词.\n 想想我们小学时学\u0026quot;面积\u0026quot;的时候, 老师们都是使用\u0026quot;画小方块\u0026quot;的方式来给我们讲解啥是面积的, 比如说下图:\n 此处应该有图\n 也就是说, 要定义任意几何体的体积, 我们首先要定义一个 单位立方体. 单位立方体有两个非常重要的性质:\n 它是直的. 它的每一条边是单位的.  在一个 $n$ 维空间里, 假如我们有基底 $e_1, e_2, \u0026hellip;, e_n$, 那么我们可以开始定义我们的\u0026quot;单位立方体\u0026quot;了.\n我们用 $e_1 \\wedge e_2$ 来表示两个基底 $e_1, e_2$ 组成的小 $2$ 维 \u0026ldquo;单位立方体\u0026rdquo;. 同理 $e_1 \\wedge e_2 \\wedge e_3$ 就代表一个 $3$ 维的单位立方体, $e_1 \\wedge e_2 \\wedge \u0026hellip; \\wedge e_n$ 就是一个 $n$ 维的单位立方体.\n那么我们马上就可以如下定义这个 $\\wedge$ 运算的结果:\n [结合律] 它应该具有结合律: $e_1 \\wedge e_2$ 与 $e_3$ 组成的小立方体应该跟 $e_1$ 和 $e_2 \\wedge e_3$ 组成的小立方体是一样的. 即: $(e_1 \\wedge e_2) \\wedge e_3 = e_1 \\wedge (e_2 \\wedge e_3)$ [自反性] 两条相同的边组成的\u0026quot;立方体\u0026quot;应该是塌下来的, 退化的一个 \u0026ldquo;立方体\u0026rdquo;, 也就是说 $e_i \\wedge e_i = 0$. 并且显然地, 我们有: $0 \\wedge e_i = 0$ (这里的 $0$ 是零矢量)  特别的, 出于神秘的原因, 我们最好不止是定义 \u0026ldquo;单位立方体\u0026rdquo; 而是定义 \u0026ldquo;带方向的单位立方体\u0026rdquo;. 于是我们还对$\\wedge$定义如下规则:\n[反交换律] 交换组成 \u0026ldquo;立方体\u0026rdquo; 的两条边, 这个立方体的取向相反. 即: $e_i \\wedge e_j = - e_j \\wedge e_i$ (你可以认为这个负号就是普通的取反向向量).  当我们有了 \u0026ldquo;单位立方体\u0026rdquo; , 我们下一步要做的就是把这些立方体拼起来. 我们如下定义:\n 如果一条边有 $k$ 倍的基底那么长, 那么它组合出来的立方体应该是基底立方体的 $k$ 倍. 如果一条边是由两个不同的基底拼出来的, 那么它组合出来的立方体应该是两个基底立方体加起来.  换句话讲, 我们让楔积是一个 双线性运算:\n$$ \\begin{aligned} (\\alpha a + \\beta b) \\wedge c = \\alpha (a \\wedge c) + \\beta (b \\wedge c) \\\\ c \\wedge (\\alpha a + \\beta b) = \\alpha (c \\wedge a) + \\beta (c \\wedge b) \\end{aligned} $$\n这样我们就把楔积推广到全体线性空间$V$里了. 我们把通过 $k$ 重楔积组合出来的 $k$ 维立方体的集合连同其上的加法和数乘构成的线性空间记为 $\\wedge^k(V)$.\n行列式的定义 基本定义 在现阶段, 我们最感兴趣的线性空间是 $n$ 维欧式空间 $\\mathbb{R}^n$, 于是下文我们都基于 $\\mathbb{R}^n$ 来讲.\n我们来考虑 $\\wedge^n(\\mathbb{R}^n)$, 即 $n$ 维空间里的 $n$ 维有向超平行体(parallelotope).\n首先我们把一个非常自然的标准超平行体叫做自然超平行体: $e_1 \\wedge e_2 \\wedge \u0026hellip; \\wedge e_n$.\n然后把仅由基底构成的超平行体叫做单位超平行体. 通过交换自然超平行体的参数顺序, 我们可以构造出所有的单位超平行体(显然有正有负).\n首先我们来尝试把任意的超平行体 \u0026ldquo;展开\u0026rdquo; 成单位超平行体, 然后再转化成自然超平行体, 那么我们就能知道这个超平行体由多少个 \u0026ldquo;小立方体\u0026rdquo; 组成, 就能知道它的 \u0026ldquo;体积\u0026rdquo; 了.\n 因为 \u0026ldquo;单位超平行体\u0026rdquo; 和 \u0026ldquo;自然超平行体\u0026rdquo; 看起来又长又蠢又中二, 下面统一用 \u0026ldquo;单位体\u0026rdquo; \u0026ldquo;自然体\u0026rdquo; 代替它们.\n 展开成单位超平行体 下面用带单个下标的 $a_i$ 来表示组成我们在处理的超平行体的第 $i$ 个矢量. 用带两个下标的 $a_{ij}$ 来表示矢量 $a_i$ 的第 $j$ 个分量.\n我们有:\n$$ \\begin{aligned} a_1 \\wedge a_2 \\wedge a_3 \u0026hellip; \\wedge a_n \u0026amp;= (a_{11} e_1 + a_{12} e_2 + a_{13} e_3 + \u0026hellip; + a_{1n} e_n) \\\\ \u0026amp;\\wedge (a_{21} e_1 + a_{22} e_2 + a_{23} e_3 + \u0026hellip; + a_{2n} e_n) \\\\ \u0026amp;\\wedge (a_{31} e_1 + a_{32} e_2 + a_{33} e_3 + \u0026hellip; + a_{3n} e_n) \\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;\\wedge (a_{n1} e_1 + a_{n2} e_2 + a_{n3} e_3 + \u0026hellip; + a_{nn} e_n) \\\\ \\end{aligned} $$\n根据乘法分配律, 我们理论上可以得到 $n^n$ 个项, 也就是说, 我们可以在第一行里的 $n$ 个分量里挑一个项, 第二行的 $n$ 个分量里挑一个项, 第三行\u0026hellip;, 一直挑 $n$ 次.\n但是, 如果我们在挑元素的时候, 在不同的两行中挑中了同一列的分量(见下红色字的选法), 也就是说, 我们这一次挑出来乘起来的项里, 出现了一个 $e_i \\wedge e_i$; 这样的话, 这一项就会变成 $0$, 相当于没有了, 所以我们在下面直接忽略这些项.\n$$ \\begin{aligned} \u0026amp;\\quad\\ (\\textcolor{red}{a_{11} e_1} + a_{12} e_2 + a_{13} e_3 + \u0026hellip; + a_{1n} e_n) \\\\ \u0026amp;\\wedge (a_{21} e_1 + \\textcolor{red}{a_{22} e_2} + a_{23} e_3 + \u0026hellip; + a_{2n} e_n) \\\\ \u0026amp;\\wedge (a_{31} e_1 + \\textcolor{red}{a_{32} e_2} + a_{33} e_3 + \u0026hellip; + a_{3n} e_n) \\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;\\wedge (a_{n1} e_1 + a_{n2} e_2 + \\textcolor{red}{a_{n3} e_3} + \u0026hellip; + a_{nn} e_n) \\\\ \\end{aligned} $$\n我们在挑元素的时候干脆就直接挑不在同一列的元素就好了. 也就是说, 类似于往国际象棋盘上摆车一样地选的话, 我们一共就能选出 $n!$ 这么多个项. 也就是说, 我们类似下面这样选:\n$$ \\begin{aligned} \u0026amp;\\quad\\ (\\textcolor{aqua}{a_{11} e_1} + a_{12} e_2 + a_{13} e_3 + \u0026hellip; + a_{1n} e_n) \\\\ \u0026amp;\\wedge (a_{21} e_1 + \\textcolor{aqua}{a_{22} e_2} + a_{23} e_3 + \u0026hellip; + a_{2n} e_n) \\\\ \u0026amp;\\wedge (a_{31} e_1 + a_{32} e_2 + \\textcolor{aqua}{a_{33} e_3} + \u0026hellip; + a_{3n} e_n) \\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;\\wedge (a_{n1} e_1 + a_{n2} e_2 + a_{n3} e_3 + \u0026hellip; + \\textcolor{aqua}{a_{nn} e_n}) \\\\ \\end{aligned} $$\n或者这样地:\n$$ \\begin{aligned} \u0026amp;\\quad\\ (\\textcolor{aqua}{a_{11} e_1} + a_{12} e_2 + a_{13} e_3 + \u0026hellip; + a_{1n} e_n) \\\\ \u0026amp;\\wedge (a_{21} e_1 + a_{22} e_2 + \\textcolor{aqua}{a_{23} e_3} + \u0026hellip; + a_{2n} e_n) \\\\ \u0026amp;\\wedge (a_{31} e_1 + \\textcolor{aqua}{a_{32} e_2} + a_{33} e_3 + \u0026hellip; + a_{3n} e_n) \\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;\\wedge (a_{n1} e_1 + a_{n2} e_2 + a_{n3} e_3 + \u0026hellip; + \\textcolor{aqua}{a_{nn} e_n}) \\\\ \\end{aligned} $$\n把它们按顺序来, 我们就能拿到下面的这些:\n$$ \\begin{aligned} \u0026amp;\\quad\\ a_{11} a_{22} a_{33} \u0026hellip; a_{nn} (e_1 \\wedge e_2 \\wedge e_3 \\wedge \u0026hellip; \\wedge e_n) \\\\ \u0026amp;+ a_{12} a_{21} a_{33} \u0026hellip; a_{nn} (e_2 \\wedge e_1 \\wedge e_3 \\wedge \u0026hellip; \\wedge e_n) \\\\ \u0026amp;+ a_{11} a_{23} a_{32} \u0026hellip; a_{nn} (e_1 \\wedge e_3 \\wedge e_2 \\wedge \u0026hellip; \\wedge e_n) \\\\ \u0026amp;\u0026hellip; \\\\ \u0026amp;+ a_{1n} a_{2 (n-1)} a_{3 (n-2)} \u0026hellip; a_{n1} (e_n \\wedge e_{n-1} \\wedge e_{n-2} \\wedge \u0026hellip; \\wedge e_1) \\end{aligned} $$\n那么我们现在就把任意的超平行体拆成了 $n!$ 个单位体了. 现在让我们来看看怎么把这些单位体转化成自然体吧.\n转化为自然超平行体 我们来举个例子. 假如我们有一个单位体, 它跟自然体只差了一个相邻的 交换:\n$$ e_1 \\wedge \\textcolor{aqua}{e_3 \\wedge e_2} \\wedge e_4 \\wedge \u0026hellip; \\wedge e_n \\\\ e_1 \\wedge e_2 \\wedge e_3 \\wedge e_4 \\wedge \u0026hellip; \\wedge e_n $$\n那么我们可以用[反交换律]把上面的单位体换成自然体:\n$$ e_1 \\wedge \\textcolor{aqua}{e_3 \\wedge e_2} \\wedge e_4 \\wedge \u0026hellip; \\wedge e_n = - (e_1 \\wedge e_2 \\wedge e_3 \\wedge e_4 \\wedge \u0026hellip; \\wedge e_n) $$\n也就是说, 借助[反交换律], 我们可以每次交换一个相邻的向量的顺序(只需要记得乘个$-1$)就好了. 那么如果我们要想知道一个单位体要想换多少次才能到自然体, 我们就遇到了下面这个著名的问题:\n对一个 1 到 n 的排列, 最少交换多少次相邻元素, 能把它交换到自然排列?  这个著名问题的著名答案就是: 逆序数. 一个序列的逆序数就表明了 \u0026ldquo;至少交换多少次这个排列能变成自然排列?\u0026rdquo;.\n为啥逆序数就是这个最小交换数的证明可以参考这里. 一个直观的参考是: 每一个元素自己的逆序数表示 \u0026ldquo;为了让排列变成自然排列, 前面得有多少个元素得在交换时跨过我\u0026rdquo;, 理论上, 如果一个要跨过你的元素离你再远, 它也是要跨过你的. 如果它离你远了, 说明它占了更前的元素的位置, 它在跨过一些看起来 \u0026ldquo;不应该\u0026rdquo; 跨过的元素的时候, 其实是在消费它占掉的更前的元素的逆序数, 因为这个位置被它占掉的更前的元素会被 \u0026ldquo;挤\u0026rdquo; 到后面去.\n如果我交换更多的次数会怎么样? 注意到每一次交换 要么使得逆序数减少要么使得逆序数增加(也就是说它要么帮忙要么帮倒忙), 如果你帮了一次倒忙, 那么你必须得加一次正忙才能抵消它的作用, 前前后后乘了两个$-1$, 相当于没乘. 具体的证明我没找到, 但是也许你可以自己写一个然后告诉我qwq.\n所以形式化一下, 以 $\\pi(p_1 p_2 p_3 \u0026hellip; p_n)$ 表示序列的逆序数, 那么我们有:\n$$ e_{p_1} \\wedge e_{p_2} \\wedge e_{p_3} \\wedge \u0026hellip; \\wedge e_{p_n} = (-1)^{\\pi(p_1 p_2 p_3 \u0026hellip; p_n)} (e_1 \\wedge e_2 \\wedge e_3 \\wedge \u0026hellip; \\wedge e_n) $$\n也就是说, 一个单位体要化成自然体, 最后交换完的正负号, 就看它的下标的逆序数.\n把它们加到一起\u0026hellip; $$ \\begin{aligned} a_1 \\wedge a_2 \\wedge a_3 \u0026hellip; \\wedge a_n \u0026amp;= (a_{11} e_1 + a_{12} e_2 + a_{13} e_3 + \u0026hellip; + a_{1n} e_n) \\\\ \u0026amp;\\wedge (a_{21} e_1 + a_{22} e_2 + a_{23} e_3 + \u0026hellip; + a_{2n} e_n) \\\\ \u0026amp;\\wedge (a_{31} e_1 + a_{32} e_2 + a_{33} e_3 + \u0026hellip; + a_{3n} e_n) \\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;\\wedge (a_{n1} e_1 + a_{n2} e_2 + a_{n3} e_3 + \u0026hellip; + a_{nn} e_n) \\\\ \u0026amp;= \\sum_{p_1 p_2 p_3 \u0026hellip; p_n} a_{1p1} a_{2p2} a_{3p3} \u0026hellip; a_{np_n} (e_{p_1} \\wedge e_{p_2} \\wedge e_{p_3} \\wedge \u0026hellip; \\wedge e_{p_n}) \\\\ \u0026amp;= \\sum_{p_1 p_2 p_3 \u0026hellip; p_n} a_{1p1} a_{2p2} a_{3p3} \u0026hellip; a_{np_n} (-1)^{\\pi(p_1 p_2 p_3 \u0026hellip; p_n)} (e_1 \\wedge e_2 \\wedge e_3 \\wedge \u0026hellip; \\wedge e_n) \\\\ \u0026amp;= \\sum_{p_1 p_2 p_3 \u0026hellip; p_n} (-1)^{\\pi(p_1 p_2 p_3 \u0026hellip; p_n)} a_{1p1} a_{2p2} a_{3p3} \u0026hellip; a_{np_n} (e_1 \\wedge e_2 \\wedge e_3 \\wedge \u0026hellip; \\wedge e_n) \\\\ \\end{aligned} $$\n第一个等号是对 $a_i$ 按分量展开; 第二个等号就是上面说的 \u0026ldquo;选分量\u0026rdquo; 的过程(我们暂时从上往下按行选, 在行里选列, 于是 $p_i$ 就代表了我们在第 $i$ 行选了哪一列); 第三个等号是我们上面说的\u0026quot;把单位体换自然体\u0026quot;; 第四个等号是把$(-1)$挪到前面使得式子好看. 于是最终, 我们从有向体积出发, 得到了行列式的书本定义.\n 等等等等, 你这不是比行列式还多了一块 $(e_1 \\wedge e_2 \\wedge e_3 \\wedge \u0026hellip; \\wedge e_n)$ 吗???\n 确实. 因为我们在定义楔积的时候, 说楔积积起来代表的是 \u0026ldquo;有向超平行体\u0026rdquo;, 但行列式的意思是 \u0026ldquo;有向超平行体的有向体积\u0026rdquo;. 我们得到的结果是我这个超平行体是自然体的有向体积的多少倍, 也就是说, 其实应该是:\n$$ a_1 \\wedge a_2 \\wedge a_3 \u0026hellip; \\wedge a_n = D_n (e_1 \\wedge e_2 \\wedge e_3 \\wedge \u0026hellip; \\wedge e_n) $$\n这个才是行列式. 但不管怎么样, 反正差不多啦! (被数学佬锤死)\n行列式的基本性质 行列式的基本性质的很多都可以从楔积的交替双线性给证明出来.\n我们现在先来习惯一下一些符号:\n$$ \\begin{aligned} A \u0026amp;= \\bigwedge_{i=1}^{n} a_i \\\\ \u0026amp;= \\bigwedge_{i=1}^{n} \\sum_{j=1}^{n} a_{ij} e_j \\\\ \u0026amp;= \\sum_{\\forall p} (-1)^{\\pi(p)} \\prod_{p_i \\in p} a_{i p_i} (\\bigwedge_{i=1}^n e_i) \\end{aligned} $$\n可以看到, 我用$A$表示这个超平行体, 把多重楔积写成了前置的大号形式, 以及使用一个字母$p$(或者$q$)来表示一个排列$p_1, p_2, \u0026hellip;, p_n$, 并且在遍历这个排列的时候用$p_i \\in p$ 来表示.\n 注意这种表示方法就好像 \u0026ldquo;自然体\u0026rdquo; 和 \u0026ldquo;单位体\u0026rdquo; 一样, 一般只有我用\u0026hellip;\n 一般来讲在证明性质的时候第二种超平行体的表示比较好用.\n首先是一个选行的的任意性. 注意到我们在上面选分量的时候, 是按第一行先选, 第二行再选, 第三行再选, \u0026hellip; 选到第 $n$ 行这种次序的, 为什么我们一定要这样选呢?\n答案是因为楔积是反交换的, 如果你先选了第二行再选第一行, 乘出来的 $e_2$ 就会跑到 $e_1$ 前面去, 那样就不准了.\n那我要是硬要按我自己想选的次序$q$来选怎么办? (比如说一四二三这样选行, $q=[1,4,2,3]$)\n那么我们就按你想要的次序, 把原来是自然排列的行, 排成你想要的顺序就可以啦!\n(非常显然, 把自然排列排成排列$q$要做的操作, 跟把排列$q$排成自然排列要做的操作, 其实是一样哒. 所以我们在上一节讲的关于逆序数的性质在这里也同样适用)\n因此我们有:\n$$ \\begin{aligned} A \u0026amp;= \\bigwedge_{i=1}^{n} a_i \\\\ \u0026amp;= (-1)^{\\pi(q)} \\bigwedge_{q_i \\in q} a_{q_i} \\\\ \u0026amp;= (-1)^{\\pi(q)} \\bigwedge_{q_i \\in q} \\sum_{j=1}^n a_{q_i j} e_j \\\\ \u0026amp;= (-1)^{\\pi(q)} \\sum_{\\forall p} (-1)^{\\pi(p)} \\prod_{\\substack{p_i \\in p\\ q_i \\in q}} a_{q_i p_i} (\\bigwedge_{i=1}^n e_i) \\\\ \u0026amp;= \\sum_{\\forall p} (-1)^{\\pi(q) + \\pi(p)} \\prod_{\\substack{p_i \\in p\\ q_i \\in q}} a_{q_i p_i} (\\bigwedge_{i=1}^n e_i) \\\\ \\end{aligned} $$\n上式中, 第一个等号是定义展开, 第二个等号是把行换成你想要的顺序, 第三个等号是分量展开, 第四个等号是选完分量之后, 第五个等号是把 $(-1)^{\\pi(q)}$ 乘进求和号里面并跟里面原来有的$(-1)^{\\pi(p)}$ 合并.\n所以我们有课本里头广义的行列式定义: 对任意你选定的$q$, 我们有:\n$$ D_n = \\sum_{\\forall p} (-1)^{\\pi(q) + \\pi(p)} \\prod_{\\substack{p_i \\in p\\ q_i \\in q}} a_{q_i p_i} $$\n行列式的初等变换有:\n 转置 交换 拆分 数乘  下面我们来一个个看看\n转置 转置其实不改变行列式里放着什么数, 那么你选完分量之后总的那一堆结果其实还是原来的那一堆, 所以转置不改变行列式的值.\n交换 交换行其实就是在交换行向量, 由反交换律并参考上面的单位体到自然体的转化, 很容易得到交换一堆楔积里的任意两个元素, 楔积符号相反这个结论. 从而交换改变行列式符号这个结论是自然的.\n拆分 和 数乘 拆分和数乘行其实就利用了楔积的线性性.\n转置 咕咕咕\n行列式的拉普拉斯展开 咕咕咕\n行列式的 Cramer 法则 咕咕咕\n行列式的直观意义 (还需要吗??) 咕咕咕\n参考与缘起 本文章的灵感来着于一个知乎问答, 具体问答我已经找不到了. 在那个回答里, 答主介绍了如何根据外代数的形式死记硬背多元微分形式的技巧. 惊为天人之后发现外代数其实是很多高中或者大学低年级里常见概念背后的\u0026quot;大象\u0026quot;, 比如叉乘, 行列式, 多元微分之类的, 遂起了用外代数来解释这些概念的心思. 苦于高中没有时间, 一直咕咕咕咕咕.\n大学水课多了, 于是就开始写了.\n另一个灵感来自于一本神奇的书: 线性代数的几何意义. 这本书全书全是各种图图图, 讲解了很多线代相关对象的几何意义, 但可能是篇幅所限, 它 并没有解释为什么这些几何意义能跟对象的代数形式联系到一块, 它只是告诉你, 这些性质可以从几何直观来理解, 这我觉得是不够的.\n咕咕咕\n","date":"2021-09-27","permalink":"https://blog.origami404.top/post/2021-09-determinant-begin-from-wedge-product/","tags":["数学","线代","新观点"],"title":"从外代数出发的行列式理论"},{"content":"前言 最近被某学长介绍了毕昇杯编译器比赛, 有点感兴趣, 遂开始用 C 自己实现, 然后就:\n 还是 Java 香!\n 本文记录了我用 Bison 和 Flex 来构建 SysY2021 语言前端的尝试.\nShow me the code. 前置声明: 大体的代码架构和使用方法在最后, 可以交叉着看.\nlex Lex 可以将输入按照正则表达式匹配然后执行对应的代码. 这个代码一般是直接返回对应 token 的类型; 如果一个 token 还有附加信息, 那么你也可以在代码里把它保存在哪个全局变量里面.\n它会生成一个文件:\n lex.yy.c: 包含了 yylex() 的定义  /* src/frontend/lexer.lex */ /* ========================================================== * 一个 lex 文件大概由三部分组成 * 第一部分是下面这个被 %{ ... %} 框起来的部分 * 这里可以写一些 C 代码, 它们会被原封不动的拷贝进生成的 C 文件里 * 一般是写头文件和一些下面要用到的函数 * ========================================================== */ %{ #include \u0026quot;util.h\u0026quot; #include \u0026quot;ast.h\u0026quot; /* 这个是 Yacc 自动生成的头文件, 包含了 Lex 应该返回的枚举的定义和 yylval */ #include \u0026quot;parser.tab.h\u0026quot; %} /* ========================================================== * 第二部分就是用来放传递给 lex 的选项的部分 * 选项以%开头, 紧跟着选项名, 后接参数 * ========================================================== */ /* 这个选项表示不需要使用 yywarp */ %option noyywrap /* 这个选项表示 C_COMMENT 是一个状态 */ %x C_COMMENT /* ========================================================== * 第三部分就是每一个 token 的定义 * 包含在 %% ... %% 内 * 每一行都按如下格式: \u0026lt;正则表达式\u0026gt; \u0026lt;动作\u0026gt; * 一般来讲每当读完一个 token, \u0026lt;动作\u0026gt; 部分就应该 return 一个 int 值, 它将作为 yylex() 的返回值 * 对于携带特殊信息的 token, 我们一般把值存进全局变量 yylval 里供程序的其他部分使用 * ========================================================== */ %% /* 忽略空白 */ \u0026quot; \u0026quot; { continue; } \\t { continue; } \\n { continue; } /* 处理单行注释 */ \u0026quot;\\\\\u0026quot;.*\\n { continue; } /* 处理 C 风格的注释 */ /* 这是 lex 暴露出来的给我们手动控制 DFA 节点的写法 */ /* 当碰到 \u0026quot;/*\u0026quot; 时就进入 C_COMMENT 状态 */ \u0026quot;/*\u0026quot; { BEGIN(C_COMMENT); } /* 当在状态 C_COMMENT 并且碰到 \u0026quot;*/\u0026quot; \u0026quot; 时就回到正常状态 INITIAL (lex 自己提供的) */ \u0026lt;C_COMMENT\u0026gt;\u0026quot;*/\u0026quot; { BEGIN(INITIAL); } /* 当在状态 C_COMMENT 时, 输入一切字符都当不存在 */ \u0026lt;C_COMMENT\u0026gt;. { continue; } /* 这里的状态处理没有考虑嵌套注释; 如果要支持的话可以在全局变量里保存一个变量 level 表示注释的层级, * 每次碰到新的 \u0026quot;/*\u0026quot; 就 level++, \u0026quot;*/\u0026quot; \u0026quot; 就 level--; 当 level == 0 时才退出 C_COMMENT 状态 */ /* 关键字 */ const { return T_CONST; } int { return T_INT; } void { return T_VOID; } if { return T_IF; } else { return T_ELSE; } while { return T_WHILE; } break { return T_BREAK; } continue { return T_CONTINUE; } return { return T_RETURN; } /* 符号, 对于特殊的字符可以用双引号括起来, 这样它们不会被当成正则表达式里的元字符, 也不需要转义 */ \u0026quot;,\u0026quot; { return T_COMMA; } \u0026quot;;\u0026quot; { return T_SEMICOCLON; } \u0026quot;(\u0026quot; { return T_PAREN_LEFT; } \u0026quot;)\u0026quot; { return T_PAREN_RIGHT; } \u0026quot;[\u0026quot; { return T_SQU_LEFT; } \u0026quot;]\u0026quot; { return T_SQU_RIGHT; } \u0026quot;{\u0026quot; { return T_CURLY_LEFT; } \u0026quot;}\u0026quot; { return T_CURLY_RIGHT; } \u0026quot;=\u0026quot; { return T_ASSIGN; } \u0026quot;+\u0026quot; { return T_ADD; } \u0026quot;-\u0026quot; { return T_SUB; } \u0026quot;*\u0026quot; { return T_MUL; } \u0026quot;/\u0026quot; { return T_DIV; } \u0026quot;%\u0026quot; { return T_MOD; } \u0026quot;==\u0026quot; { return T_EQ; } \u0026quot;!=\u0026quot; { return T_NOT_EQ; } /* 如果有多个匹配, lex 会匹配比较靠前的规则 */ \u0026quot;\u0026lt;=\u0026quot; { return T_LESS_EQ; } \u0026quot;\u0026gt;=\u0026quot; { return T_GREATER_EQ; } \u0026quot;\u0026lt;\u0026quot; { return T_LESS; } \u0026quot;\u0026gt;\u0026quot; { return T_GREATER; } \u0026quot;!\u0026quot; { return T_LOG_NOT; } \u0026quot;\u0026amp;\u0026amp;\u0026quot; { return T_LOG_AND; } \u0026quot;||\u0026quot; { return T_LOG_OR; } putf { return T_PUTF; } /* 标识符 */ [a-zA-Z_][0-9a-zA-Z_]* { yylval.sval = String(yytext); return T_IDENT; } /* 数字, 十进制, 八进制和十六进制字面量 */ [1-9][0-9]* { yylval.ival = (int)strtol(yytext, 0, 0); return T_NUM; } 0[0-7]* { yylval.ival = (int)strtol(yytext, 0, 0); return T_NUM; } 0(x|X)[0-9a-fA-F]* { yylval.ival = (int)strtol(yytext, 0, 0); return T_NUM; } /* 字符串字面量 */ \u0026quot;\\\u0026quot;\u0026quot;.*\u0026quot;\\\u0026quot;\u0026quot; { yylval.sval = String(yytext); return T_STR; } /* 对于不符合以上任何匹配的, 做一个错误处理 */ . { panic(\u0026quot;Unknown token: %s\u0026quot;, yytext); } %%  另外, 如果你需要在别的对正则表达式有内建支持的语言(比如Python)里快速做一个 lexer 的话, 你可以这样干:\nimport re from itertools import starmap from typing import * def sub_regax(token_type: str, reg: str) -\u0026gt; str: # 命名组合, 参见: https://docs.python.org/zh-cn/3/library/re.html#regular-expression-syntax return f'(?P\u0026lt;{token_type}\u0026gt;{reg})' # token 类型要求首字母大写, token 附加数据的要求首字母小写 lexer_rules = [ ('LeftBracket', r'\\(' ), ('RightBracket', r'\\)' ), ('Number', r'(?P\u0026lt;num\u0026gt;[0-9]+)' ), ('String', r'\u0026quot;(?P\u0026lt;str\u0026gt;.*?)\u0026quot;' ), ('Identifier', r'(?P\u0026lt;id\u0026gt;[a-zA-Z][a-zA-Z0-9]*)') ] # 直接把所有 token 对应的正则表达式都并起来, 然后编译一个大的 # 并且希望你那个语言的正则表达式的编译可以生成最优的 DFA lexer_reg = re.compile('|'.join(starmap(sub_regax, lexer_rules))) # 找到 d 里面 第一个 d[key] 不为 None 且首字母大写的, 并且返回 key def get_key(d: dict[str, Union[str, Any]]) -\u0026gt; str: for k, v in d.items(): if v and k[0].isupper(): return k raise RuntimeError(f'All value in dict is none: {d}') def regenize(inputs: Iterable[str]) -\u0026gt; Iterable[tuple[str, Any]]: for input in inputs: for tok_match in lexer_reg.finditer(input): # tok_match.groupdict() 返回一个 dict, 里面大概是这样的: # {'LeftBracket': None, 'RightBracket': None, 'Number': None, 'String': None, 'Identifier': 'sad0', 'num': None, 'id': 'sad0', 'str': None} type = get_key(tok_match.groupdict()) if type in ['LeftBracket', 'RightBracket']: yield (type, None) elif type == 'Number': yield (type, tok_match.group('num')) elif type == 'String': yield (type, tok_match.group('str')) elif type == 'Identifier': yield (type, tok_match.group('id')) else: raise RuntimeError(f'Unknown token type: {type}') if __name__ == '__main__': prog = '(define (p2 x) (mul x x)) \\n (p2 234)' for tok, data in regenize(prog.split('\\n')): print(tok, data) # Output: ''' LeftBracket None Identifier define LeftBracket None Identifier p2 Identifier x RightBracket None LeftBracket None Identifier mul Identifier x Identifier x RightBracket None RightBracket None LeftBracket None Identifier p2 Number 234 RightBracket None '''  yacc YACC 实现了一个 LALR(1) 的 SDT 的 parser. 每一个 Non-terminal, 在 reduce 的时候, 都会执行 reduce 成那个符号的规则对应的语义动作. 每一个 Non-terminal 都有且仅有一个属性, 这个属性可以在语义动作里通过 $ 来获取.\n在内存充裕的现代, 我们一般可以直接生成整颗 AST 保存在内存中, 所以一般来讲 YACC 的语义动作里都是构建 AST 的代码.\n它会生成两个文件:\n parser.tab.h: 定义了所有 terminal 的枚举, 声明了 yyparser() 和 yylval, 一般我们会让 lex 和要调用 yyparser 的文件包含这个文件 parser.tab.c: 定义了 yyparser() 和 yylval  /* src/frontend/parser.y */ /* ========================================================== * 一个 yacc 文件跟 lex 文件一样由三个部分组成 * %{ ... %} ... %% ... %% * 三个部分作用也大同小异 * 区别就在于 yacc 有很多选项可以调, 所以中间部分比较长 * ========================================================== */ %{ #include \u0026quot;util.h\u0026quot; #include \u0026quot;ast.h\u0026quot; #include \u0026quot;parser.tab.h\u0026quot; /* 声明 yylex() 函数 */ extern int yylex(); /* 当出现错误时 yacc 生成的函数会调用这个东西 */ #define yyerror(s) panic(\u0026quot;Yacc error: %s\u0026quot;, s); /* 如果 YYDEBUG 为 1, 那么 yacc 生成的 parser 在运行时会输出很多信息 */ #ifdef DEBUG # undef YYDEBUG # define YYDEBUG 1 #else # undef YYDEBUG # define YYDEBUG 0 #endif /* 用来保存最后结果供外界使用的变量 */ extern Ast_List result; %} /* ========================================================== * 第二部分, 在这里要写: * 1) yylval 的类型 * 2) 各个 token(terminal) 对应于 yylval 的哪个 field * 3) 各个 symbol(non-terminal) 对应于 yylval 的哪个 field * 4) 起始规则 * ========================================================== */ /* 设置 yylval 为枚举类型, 有下面的这些 field */ %union { int ival; string sval; Ast_Node node; Ast_List node_list; } /* 设置 token 的相关属性和别名 * %token \u0026lt;\u0026lt;yylval 的 field 名\u0026gt;\u0026gt; [\u0026lt;token 的枚举名\u0026gt; [\u0026quot;\u0026lt;token 名字的替代\u0026gt;\u0026quot;]]+ */ /* 这里设置了 \u0026quot;如果 lexer 读到一个标识符, 那么 yylex() 应该返回一个 T_IDENT, 并且在 yylval 里的 sval 域将会有一个值; * 在下文的规则里见到 \u0026quot;identifier\u0026quot; 就当成终结符号 标识符\u0026quot; */ /* 要注意这里的 \u0026lt;token 名字的替代\u0026gt;必须用双引号而不是单引号, 单引号的字符(比如'c')会被当成数字 * 意思就变成了 \u0026quot;当 yylex() 返回 'c' 时就意味着获得了这个 token\u0026quot; 而不是设置别名 * 因此, Yacc 为 token 生成的枚举类型里首个枚举值是以 256 开始的 */ %token \u0026lt;sval\u0026gt; T_IDENT \u0026quot;identifier\u0026quot; T_STR \u0026quot;string literal\u0026quot; T_PUTF \u0026quot;putf\u0026quot; %token \u0026lt;ival\u0026gt; T_NUM \u0026quot;number literal\u0026quot; /* 这里设置了 \u0026quot;如果 lexer 读到一个const, 那么 yylex() 应该返回一个 T_CONST, 并且此时 yylval 里不确定有啥; * 在下文的规则里见到 \u0026quot;const\u0026quot; 就当成终结符号 const\u0026quot; */ %token T_CONST \u0026quot;const\u0026quot; T_INT \u0026quot;int\u0026quot; T_VOID \u0026quot;void\u0026quot; %token T_IF \u0026quot;if\u0026quot; T_ELSE \u0026quot;else\u0026quot; T_WHILE \u0026quot;while\u0026quot; %token T_BREAK \u0026quot;break\u0026quot; T_RETURN \u0026quot;return\u0026quot; T_CONTINUE \u0026quot;continue\u0026quot; %token T_COMMA \u0026quot;,\u0026quot; T_SEMICOCLON \u0026quot;;\u0026quot; %token T_PAREN_LEFT \u0026quot;(\u0026quot; T_PAREN_RIGHT \u0026quot;)\u0026quot; %token T_SQU_LEFT \u0026quot;[\u0026quot; T_SQU_RIGHT \u0026quot;]\u0026quot; %token T_CURLY_LEFT \u0026quot;{\u0026quot; T_CURLY_RIGHT \u0026quot;}\u0026quot; %token T_ASSIGN \u0026quot;=\u0026quot; %token T_ADD \u0026quot;+\u0026quot; T_SUB \u0026quot;-\u0026quot; T_MUL \u0026quot;*\u0026quot; T_DIV \u0026quot;/\u0026quot; T_MOD \u0026quot;%\u0026quot; %token T_EQ \u0026quot;==\u0026quot; T_NOT_EQ \u0026quot;!=\u0026quot; T_LESS \u0026quot;\u0026lt;\u0026quot; %token T_LESS_EQ \u0026quot;\u0026lt;=\u0026quot; T_GREATER \u0026quot;\u0026gt;\u0026quot; T_GREATER_EQ \u0026quot;\u0026gt;=\u0026quot; %token T_LOG_NOT \u0026quot;!\u0026quot; T_LOG_AND \u0026quot;\u0026amp;\u0026amp;\u0026quot; T_LOG_OR \u0026quot;||\u0026quot; /* 设置 non-terminal 的相关属性 */ /* 这里设置 Non-terminal CompUnit 的规则求值之后在 yylval 的 node_list 域里有一个合法的值 */ %type \u0026lt;node_list\u0026gt; CompUnit %type \u0026lt;node\u0026gt; FuncDef FuncParam %type \u0026lt;node_list\u0026gt; FuncParamList %type \u0026lt;node\u0026gt; Decl %type \u0026lt;node\u0026gt; DefOne %type \u0026lt;node_list\u0026gt; DefAny %type \u0026lt;node\u0026gt; InitVal %type \u0026lt;node_list\u0026gt; ArrInit %type \u0026lt;node\u0026gt; Stmt Block IfStmt WhileStmt PutfForm %type \u0026lt;node_list\u0026gt; BlockItemList %type \u0026lt;node\u0026gt; PrimaryExp UnaryExp MulExp AddExp %type \u0026lt;node\u0026gt; RelExp EqExp LAndExp LOrExp Cond Exp %type \u0026lt;node\u0026gt; LVal %type \u0026lt;node_list\u0026gt; ArrIdx FuncArgs /* 设置起始规则为 CompUnit 对应的规则 */ %start CompUnit %% /* ========================================================== * 第三部分, 在这里要写各个 Non-terminal 对应的产生式 * 只支持基本的 BNF, 不支持 EBNF * ========================================================== */ /* 规则是, 如果碰到了 Decl CompUnit, 就规约成一个 CompUnit, 同时执行后面的语义动作 * 语义动作里, 用 $$ 指代产生式头代表的变量, $n 表示产生式体里第 n 个元素代表的变量 * 这里的语义动作会\u0026quot;大概\u0026quot;被翻译成: yylval.node_list = result = cons_Ast(yylval.node, yylval.node_list); * 单独拎一个 result 出来是因为当 yyparse() 函数结束之后 yylval 会被回收, * 也就是说不能通过 yylval 获取最后的结果了, 所以最后的结果要另外存一份 */ CompUnit: Decl CompUnit { $$ = result = cons_Ast($1, $2); } | FuncDef CompUnit { $$ = result = cons_Ast($1, $2); } | /* empty */ { $$ = result = 0; } ; //---------------- Declaration \u0026amp; Definition ---------------------------- /* 在产生式体里只有一个 Block 的情况下, 可以用$\u0026lt;Non-terminal名字\u0026gt;来指代那个元素的变量 * 这里的语义动作会\u0026quot;大概\u0026quot;被翻译成: yylval.node = ast_FuncDef(FRT_INT, yylval.sval, yylval.node, yylval.node); * 产生式体里的每一个 Symbol 都有它自己的 yylval, 用$塞进去的那个都是保存着那个 Symbol 当时被求出的那个的 yylval 的值 */ FuncDef: \u0026quot;int\u0026quot; T_IDENT \u0026quot;(\u0026quot; FuncParamList \u0026quot;)\u0026quot; Block { $$ = ast_FuncDef(FRT_INT, $2, $4, $Block); } | \u0026quot;void\u0026quot; T_IDENT \u0026quot;(\u0026quot; FuncParamList \u0026quot;)\u0026quot; Block { $$ = ast_FuncDef(FRT_VOID, $2, $4, $Block); } ; FuncParamList: FuncParam { $$ = cons_Ast($1, 0); } | FuncParam \u0026quot;,\u0026quot; FuncParamList { $$ = cons_Ast($1, $3); } | /* empty */ { $$ = 0; } ; FuncParam: \u0026quot;int\u0026quot; LVal { $$ = $LVal; } ; Decl: \u0026quot;const\u0026quot; \u0026quot;int\u0026quot; DefAny \u0026quot;;\u0026quot; { $$ = ast_Decl(true, $DefAny); } | \u0026quot;int\u0026quot; DefAny \u0026quot;;\u0026quot; { $$ = ast_Decl(false, $DefAny); } ; DefOne: LVal { $$ = ast_VarDef($1, 0); } | LVal \u0026quot;=\u0026quot; InitVal { $$ = ast_VarDef($1, $3); } ; DefAny: DefOne { $$ = cons_Ast($1, 0); } | DefOne \u0026quot;,\u0026quot; DefAny { $$ = cons_Ast($1, $3); } ; InitVal: Exp { $$ = ast_InitExp($Exp); } | \u0026quot;{\u0026quot; ArrInit \u0026quot;}\u0026quot; { $$ = ast_InitArr($2); } ; ArrInit: InitVal { $$ = cons_Ast($1, 0); } | InitVal \u0026quot;,\u0026quot; ArrInit { $$ = cons_Ast($1, $3); } ; //---------------------------- Stmt --------------------------- /* 语义动作留空的话, 它默认是: { $$ = $1; } */ Stmt: Block | IfStmt | WhileStmt | PutfForm | Exp \u0026quot;;\u0026quot; { $$ = ast_StmtExp($Exp); } | LVal \u0026quot;=\u0026quot; Exp \u0026quot;;\u0026quot; { $$ = ast_StmtAssign($1, $3); } | \u0026quot;;\u0026quot; { $$ = ast_StmtEmpty(); } | \u0026quot;break\u0026quot; \u0026quot;;\u0026quot; { $$ = ast_StmtBreak(); } | \u0026quot;continue\u0026quot; \u0026quot;;\u0026quot; { $$ = ast_StmtContinue(); } | \u0026quot;return\u0026quot; \u0026quot;;\u0026quot; { $$ = ast_StmtReturn(0); } | \u0026quot;return\u0026quot; Exp \u0026quot;;\u0026quot; { $$ = ast_StmtReturn($Exp); } ; Block: \u0026quot;{\u0026quot; BlockItemList \u0026quot;}\u0026quot; { $$ = ast_Block($2); } ; BlockItemList: Decl BlockItemList { $$ = cons_Ast($1, $2); } | Stmt BlockItemList { $$ = cons_Ast($1, $2); } | /* Empty */ { $$ = 0; } ; IfStmt: \u0026quot;if\u0026quot; \u0026quot;(\u0026quot; Cond \u0026quot;)\u0026quot; Stmt { $$ = ast_StmtIf($Cond, $5, 0); } | \u0026quot;if\u0026quot; \u0026quot;(\u0026quot; Cond \u0026quot;)\u0026quot; Stmt \u0026quot;else\u0026quot; Stmt { $$ = ast_StmtIf($Cond, $5, $7); } ; WhileStmt: \u0026quot;while\u0026quot; \u0026quot;(\u0026quot; Cond \u0026quot;)\u0026quot; Stmt { $$ = ast_StmtWhile($Cond, $Stmt); } ; PutfForm: \u0026quot;putf\u0026quot; \u0026quot;(\u0026quot; T_STR \u0026quot;,\u0026quot; FuncArgs \u0026quot;)\u0026quot; \u0026quot;;\u0026quot; { $$ = ast_ExpPutf($3, $5); } ; //----------------- Expression ---------------------------- Exp : AddExp; Cond: LOrExp; /* 可以看到, 如果在上面第二部分对每一个终结符设置了好看的别名的话, 就能极大地提高规则的可读性 * 比如这条规则我们就不用写 LOrExp T_OR LAndExp 而可以向下面这样写 */ LOrExp: LAndExp | LOrExp \u0026quot;||\u0026quot; LAndExp { $$ = ast_ExpOp(OP_LOG_OR, $1, $3); } ; LAndExp: EqExp | LAndExp \u0026quot;\u0026amp;\u0026amp;\u0026quot; EqExp { $$ = ast_ExpOp(OP_LOG_AND, $1, $3); } ; EqExp: RelExp | EqExp \u0026quot;==\u0026quot; RelExp { $$ = ast_ExpOp(OP_EQ, $1, $3); } | EqExp \u0026quot;!=\u0026quot; RelExp { $$ = ast_ExpOp(OP_NOT_EQ, $1, $3); } ; RelExp: AddExp | RelExp \u0026quot;\u0026lt;\u0026quot; AddExp { $$ = ast_ExpOp(OP_LESS, $1, $3); } | RelExp \u0026quot;\u0026lt;=\u0026quot; AddExp { $$ = ast_ExpOp(OP_LESS_EQ, $1, $3); } | RelExp \u0026quot;\u0026gt;\u0026quot; AddExp { $$ = ast_ExpOp(OP_GREATER, $1, $3); } | RelExp \u0026quot;\u0026gt;=\u0026quot; AddExp { $$ = ast_ExpOp(OP_GREATER_EQ, $1, $3); } ; AddExp: MulExp | AddExp \u0026quot;+\u0026quot; MulExp { $$ = ast_ExpOp(OP_ADD, $1, $3); } | AddExp \u0026quot;-\u0026quot; MulExp { $$ = ast_ExpOp(OP_SUB, $1, $3); } ; MulExp: UnaryExp | MulExp \u0026quot;*\u0026quot; UnaryExp { $$ = ast_ExpOp(OP_MUL, $1, $3); } | MulExp \u0026quot;/\u0026quot; UnaryExp { $$ = ast_ExpOp(OP_DIV, $1, $3); } | MulExp \u0026quot;%\u0026quot; UnaryExp { $$ = ast_ExpOp(OP_MOD, $1, $3); } ; UnaryExp: PrimaryExp | T_IDENT \u0026quot;(\u0026quot; FuncArgs \u0026quot;)\u0026quot; { $$ = ast_ExpCall($1, $3); } | \u0026quot;+\u0026quot; UnaryExp { $$ = ast_ExpOp(OP_SUB, $2, 0); } | \u0026quot;-\u0026quot; UnaryExp { $$ = ast_ExpOp(OP_ADD, $2, 0); } | \u0026quot;!\u0026quot; UnaryExp { $$ = ast_ExpOp(OP_LOG_NOT, $2, 0); } ; PrimaryExp: \u0026quot;(\u0026quot; Exp \u0026quot;)\u0026quot; { $$ = $2; } | LVal { $$ = ast_ExpLval($1); } | T_NUM { $$ = ast_ExpNum($1); } ; LVal: T_IDENT ArrIdx { $$ = ast_Lval($1, $2); } ; ArrIdx: ArrIdx \u0026quot;[\u0026quot; Exp \u0026quot;]\u0026quot; { $$ = cons_Ast($3, $1); } | /* empty */ { $$ = 0; } ; FuncArgs: Exp { $$ = cons_Ast($1, 0); } | Exp \u0026quot;,\u0026quot; FuncArgs { $$ = cons_Ast($1, $3); } | /* empty */ { $$ = 0; } ;  使用方法 我选择的目录结构大概是这样的:\n. ├── build.sh └── src ├── ast.h # AST 对应的构造函数 ├── frontend │ ├── lexer.lex # 我们写的 Lex 文件 │ ├── lex.yy.c # Lex 生成的文件 │ ├── parser.tab.c # Yacc 生成的文件 │ ├── parser.tab.h # Yacc 生成的文件 │ └── parser.y # 我们写的 Yacc 文件 ├── main.c └── util.h # 杂项工具  主函数:\n// main.c #include \u0026quot;util.h\u0026quot; #include \u0026quot;ast.h\u0026quot; #include \u0026quot;frontend/parser.tab.h\u0026quot; // 定义最后的结果 Ast_List result; int main(int argc, char **argv) { // 调用此函数从 STDIN 解析输入并根据输入匹配的规则执行对应的语义动作 yyparse(); // 查看输出 ast_dump_list(stdout, result); }  构建脚本:\n# build.sh #!bash cd SysY2021/src # 生成前端 cd frontend # 生成 lex.yy.c flex lexer.lex # 生成 parser.tab.c 和 parser.tab.h bison -d parser.y cd .. if [ $1 == \u0026quot;production\u0026quot; ] then addition_flag=\u0026quot;-O2\u0026quot; else addition_flag=\u0026quot;-Wall -g -DDEBUG\u0026quot; fi # 全部编译起来并且链接 # ref: https://unix.stackexchange.com/a/19656 for c_file in $(find . | grep \u0026quot;.*\\.c$\u0026quot;) do gcc -std=c11 ${addition_flag} -c -I$PWD -o ${c_file%.c}.o $c_file done gcc -std=c11 ${addition_flag} $(find . | grep \u0026quot;.*\\.o$\u0026quot;) -o ../ssyc  执行:\n./build.sh \u0026amp;\u0026amp; ./ssyc  并且输入一段 SysY 语言程序, 就可以看到它对应的输出了.\n参考 Flex/Bison 基本使用: calvin/flex和bison使用\n比较详细, 介绍了一些C语言接口: TLDP/Lex-YACC-HOWTO\n官方 Bison 文档: Bison Manual\n杂项: YYSTYPE 来源: Bison Manual/Value-Type\n建议使用:\n%define api.value.type {double} or %define api.value.type {struct semantic_type}  来代替\n#define YYSTYPE double  以获得更好的Bison体验.\n","date":"2021-09-05","permalink":"https://blog.origami404.top/compiler-and-type-theory/2021-09-compiler-frontend-with-flex-bison/","tags":["编译原理","编译前端","C","linux 工具"],"title":"基于Bison和Flex的编译器前端实现"},{"content":"此文章施工中\u0026hellip;\n现在让我们来使用上面我们写好的 Git Object 来实现常用的 Git 命令吧.\nSpec 我们要实现的命令有这些:\n创建仓库: $ git init [path] # [path]: 在 [path] 下创建一个包含必要目录结构的 .git 目录, 默认为 . (当前目录)  泛用 Object 文件 IO 提供 data 写入 Object 文件的命令:\n$ git hash-object [-t \u0026lt;type\u0026gt;] [-w] (\u0026lt;file\u0026gt; | --stdin) # [-t \u0026lt;type\u0026gt;] : Object 类型, 默认为 Blob # [-w] : 是否真正写入 .git/objects 数据库, 默认为否 # \u0026lt;file\u0026gt;: Data 的来源文件. 文件内容会被当成 data # --stdin: 从标准输入获取, 一行一个 Object # 输出是 Data 打包成 Raw 后的 SHA-1, 如: ebf4a6068f1c4176bf8db06771445b4d994f2199  从 Object 文件里读取 data 并将其有效信息显示出来的命令\n$ git cat-file (-t | -s | -p | \u0026lt;type\u0026gt;) \u0026lt;object\u0026gt; # -t: 输出 Object 文件的类型 # -s: 输出 Object 文件的大小 (按字节计) # -p: 按照文件中指示的类型美观地输出 data # \u0026lt;type\u0026gt;: 按照类型输出 data 的原始内容 # \u0026lt;object\u0026gt;: 可以唯一确定某个 Object 的指示符, 具体见下文 ","date":"2021-02-21","permalink":"https://blog.origami404.top/git-impl/2021-02-git-impl-command/","tags":["mgit","Git","轮子"],"title":"Git Command: Git 的数据使用方式"},{"content":"此文章施工中\u0026hellip;\n二进制格式 前后顺序均按从低位到高位.\n\u0026lt;index\u0026gt; ::= \u0026lt;header/12-byte\u0026gt; \u0026lt;entries/8k-byte\u0026gt; \u0026lt;extensions\u0026gt; \u0026lt;checksum\u0026gt; \u0026lt;header\u0026gt; ::= \u0026lt;signature/4-byte\u0026gt; \u0026lt;version/4-byte\u0026gt; \u0026lt;entry_cnt/32-bit\u0026gt; \u0026lt;signature\u0026gt; ::= b'DIRC' \u0026lt;version\u0026gt; ::= (0002, 0003, 0004) in ASCII format \u0026lt;entry_cnt\u0026gt; ::= the amount of entries below in u32 format \u0026lt;entries\u0026gt; ::= [\u0026lt;entry\u0026gt; \u0026lt;padding\u0026gt;] \u0026lt;entry\u0026gt; ::= \u0026lt;c_time/32-bit\u0026gt; \u0026lt;c_time_ns/32-bit\u0026gt; \u0026lt;m_time/32-bit\u0026gt; \u0026lt;m_time_ns/32-bit\u0026gt; \u0026lt;dev/32-bit\u0026gt; \u0026lt;ino/32-bit\u0026gt; \u0026lt;mode/32-bit\u0026gt; \u0026lt;uid/32-bit\u0026gt; \u0026lt;gid/32-bit\u0026gt; \u0026lt;file_size/32-bit\u0026gt; \u0026lt;sha-1/20-byte\u0026gt; \u0026lt;flags/16-bit\u0026gt; \u0026lt;path_name\u0026gt; \u0026lt;c_time\u0026gt; ::= 以秒为单位的最后一次文件元信息改变时间 in u32 format \u0026lt;c_time_ns\u0026gt; ::= c_time 的纳秒部分 in u32 format \u0026lt;m_time\u0026gt; ::= 以秒为单位的最后一次文件改变时间 in u32 format \u0026lt;m_time_ns\u0026gt; ::= m_time 的纳秒部分 in u32 format \u0026lt;dev\u0026gt; ::= 文件的设备号 \u0026lt;ino\u0026gt; ::= 文件的 ino (Infomation NOde) 号, in u32 format 与 \u0026lt;dev\u0026gt; 一起在能同一台机器上唯一地确定某个文件 \u0026lt;mode\u0026gt; ::= \u0026lt;unused_0/16-bit\u0026gt; \u0026lt;obj_type/4-bit\u0026gt; \u0026lt;unused_0/3-bit\u0026gt; \u0026lt;unix-permission/9-bit\u0026gt; \u0026lt;obj_type\u0026gt; ::= (1000, 1010, 1110) 三选一 分别代表文件类型为 (普通文件, 符号链接, 子模块链接(Gitlink)) \u0026lt;unix-permission\u0026gt; ::= 常见的 Unix 权限位, 就是 644 / 777 那种 \u0026lt;uid\u0026gt; ::= 文件所有者的用户 ID in u32 format \u0026lt;gid\u0026gt; ::= 文件所有者的用户组 ID in u32 format \u0026lt;file_size\u0026gt; ::= 文件的大小, 按字节记 in u32 format \u0026lt;sha-1\u0026gt; ::= 对象的 SHA-1 in u160 format (20-byte 长的二进制数) \u0026lt;flags\u0026gt; ::= \u0026lt;assume-valid/1-bit\u0026gt; \u0026lt;extended/1-bit\u0026gt; \u0026lt;stage/2-bit\u0026gt; \u0026lt;path_len/12-bit\u0026gt; \u0026lt;assume-vaild\u0026gt; ::= Flag, 为 1 时 Git 会假定此文件未变动, 从而允许你让 Git 忽略该文件的改变 \u0026lt;extended\u0026gt; ::= Flag, 在 version 2 中一定为 0 \u0026lt;stage\u0026gt; ::= 描述其属于同路径名对象的哪个 Slot \u0026lt;path_len\u0026gt; ::= 路径名长度, 如果大于等于 0xFFF(4095) 的话就是 0xFFF \u0026lt;path_name\u0026gt; ::= 路径名, 统一用 \u0026quot;/\u0026quot; 作为路径分隔符  直接按以上二进制格式储存于 .git/index 文件中, 不需要压缩\n一个例子 现在我们的工作目录里有两个文件: a.txt 与 b/c.txt.\n$ tree . ├─b │ └─c.txt └─a.txt  $ cat .git/index | xxd 00000000: 4449 5243 0000 0002 0000 0002 6026 33b5 DIRC........`\u0026amp;3. 00000010: 053f fd99 6026 33b5 053f fd99 0000 0802 .?..`\u0026amp;3..?...... 00000020: 0050 008b 0000 81a4 0000 03e8 0000 03e8 .P.............. 00000030: 0000 0005 81c5 45ef ebe5 f57d 4cab 2ba9 ......E....}L.+. 00000040: ec29 4c4b 0cad f672 0005 612e 7478 7400 .)LK...r..a.txt. 00000050: 0000 0000 6026 6662 15c4 8f97 6026 6662 ....`\u0026amp;fb....`\u0026amp;fb 00000060: 15c4 8f97 0000 0802 0056 0b99 0000 81a4 .........V...... 00000070: 0000 03e8 0000 03e8 0000 0005 9c9d dc2c ..............., 00000080: c36e c58f 5fc7 6c7c 5157 cfc0 46dd 79ea .n.._.l|QW..F.y. 00000090: 0007 622f 632e 7478 7400 0000 5452 4545 ..b/c.txt...TREE 000000a0: 0000 0033 0032 2031 0a05 e780 1182 a544 ...3.2 1.......D 000000b0: c4ab bf92 588d 3d2a b043 91ef 1562 0031 ....X.=*.C...b.1 000000c0: 2030 0afe 7ce1 8c5d 3590 42f6 eb43 e81c 0..|..]5.B..C.. 000000d0: f711 9240 dd36 8137 fd86 0a4c e3d2 cdd2 ...@.6.7...L.... 000000e0: c822 c701 1d2f dc6e 5c97 68 .\u0026quot;.../.n\\.h  我们把它按上文的字段分开一个一个看:\n# 文件头 4449 5243 0000 0002 0000 0002 # 第一个条目 6026 33b5 053f fd99 6026 33b5 053f fd99 0000 0802 0050 008b 0000 81a4 0000 03e8 0000 03e8 0000 0005 81c5 45ef ebe5 f57d 4cab 2ba9 ec29 4c4b 0cad f672 0005 612e 7478 7400 0000 0000 # 第二个条目 6026 6662 15c4 8f97 6026 6662 15c4 8f97 0000 0802 0056 0b99 0000 81a4 0000 03e8 0000 03e8 0000 0005 9c9d dc2c c36e c58f 5fc7 6c7c 5157 cfc0 46dd 79ea 0007 622f 632e 7478 7400 0000 # 扩展 \u0026amp; Hash checksum 5452 4545 0000 0033 0032 2031 0a05 e780 1182 a544 c4ab bf92 588d 3d2a b043 91ef 1562 0031 2030 0afe 7ce1 8c5d 3590 42f6 eb43 e81c f711 9240 dd36 8137 fd86 0a4c e3d2 cdd2 c822 c701 1d2f dc6e 5c97 68 # ---------- 下面是详细解释 ----------------- # 文件头 4449 5243 # 4-byte signature: DIRC 0000 0002 # 4-byte ASCII version: 2 0000 0002 # 32-bit entry count: 2 # 条目 1: a.txt 6026 33b5 # 32-bit: c_time 053f fd99 # 32-bit: c_time_ns 6026 33b5 # 32-bit: m_time 053f fd99 # 32-bit: m_time_ns 0000 0802 # 32-bit: dev 0050 008b # 32-bit: ino 0000 81a4 # 32-bit: mode: 4-bit obj_type / 3-bit unused / 9-bit unix permission # 81a4: 1000 000 110100100 : 1000 for file, 000 for unused, 110/100/100 for mode 644 0000 03e8 # 32-bit: uid 0000 03e8 # 32-bit: gid 0000 0005 # 32-bit: size of the file from stat(2), means len('1234\\n') == 5 81c5 45ef ebe5 f57d 4cab # 20-byte: the SHA-1 of the object in a SHA-1 repo 2ba9 ec29 4c4b 0cad f672 # 0005 # flags: 1-bit / 1-bit / 2-bit / 12-bit size of its path name below: 5 612e 7478 74 # its path name: 'a.txt' 00 0000 0000 # padding: 让每一个条目的大小是 8-byte 的倍数, 并且保证至少有一个 NUL (size: 72 bytes) # 条目 2: b/c.txt # 相信读者可以自行解读下面的字段了 6026 6662 15c4 8f97 6026 6662 15c4 8f97 0000 0802 0056 0b99 0000 81a4 0000 03e8 0000 03e8 0000 0005 9c9d dc2c c36e c58f 5fc7 6c7c 5157 cfc0 46dd 79ea 0007 622f 632e 7478 74 # b/c.txt 00 0000 # 扩展 \u0026amp; Hash checksum: 略  Stage 字段的含义 在 Git 合并分支的时候有用.\n例子取自参考里的 SO 问题.\n假如我们现在有两个分支 A, B, 工作目录下原本有三个文件 x, y, z. 现在你:\n在 A 分支:\n 修改了 x 的内容并且将它的名字改成了 t 修改了 y 的内容 z 的内容保持不变  在 B 分支:\n 修改了 x 的内容 删除了 y z 的内容保持不变  这时候你在 A 分支, 想要把它合并到 B 分支:\n(on git:A)$ git merge B  这时候 Git 就会要求你手动合并冲突, 此时的 index 文件内容如下:\n(on git:A)$ git ls-file --stage 100644 4362ab... 1 t # 指向保存了原来的 x 文件内容的 blob 100644 49db92... 2 t # 指向保存了 当前分支A 中 t(原来的x) 文件内容的 blob 100644 04b399... 3 t # 指向保存了 要被合并分支B 中 x 文件内容的 blob 100644 366b52... 1 y # 指向保存了原来的 y 文件内容的 blob 100644 6fecb1... 2 y # 指向保存了 当前分支A 中 y 文件 # 因为在 B 分支中 y 被删除了, 所以没有 stage 为 3 的 B分支 y 文件 blob 100644 7129c6... 0 z # 没有冲突的正常文件 stage 号为 0  当你解决完冲突合并之后, 比如说你:\n 选择了 t 文件 删除了 y 文件  那么合并成功后 index 会变成这样:\n(on git:B)$ git ls-file --stage 100644 49db92... 0 t 100644 7129c6... 0 z   参考:\n二进制格式: Git Manuel. 请特别注意它的排版方式, 可以的话建议先看完前文再去看这个\nStat 字段的意义: Python os.stat\nAssume-vaild flag 的意义: SO-1: 描述了 Assume-vaild flag 对应的 Git 高层术语, SO-2: 描述了该高层术语的一种应用场景, Git Manuel: 描述了如何设置这一 Flag\nStage/2-bit 的含义参考: 描述了其对应的高层术语 Slot, SO: 解释了其用途\n实现参考: Dulwich index.py, Gin\n","date":"2021-02-20","permalink":"https://blog.origami404.top/git-impl/2021-02-git-impl-index/","tags":["mgit","Git","轮子"],"title":"Git Index: Git 的暂存区"},{"content":"导读 本文先介绍了一些方便查看 Git Object 文件 二进制内容的命令行工具, 其次分别介绍了 4 种 Object: Blob, Commit, Tree, Tag.\n每一种 Object 按\u0026quot;概念模型\u0026quot;与\u0026quot;二进制格式\u0026quot;分隔, 前者主要介绍其储存了那些抽象信息, 后者则专注于其二进制储存格式.\n一些命令行工具 根据SO上的一个回答, 在 Bash 中定义以下函数:\nzlipd() (printf \u0026quot;\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\u0026quot; |cat - $@ |gzip -dc 2\u0026gt; /dev/null)\r  原理大概就是:\n gzip 格式其实就是 头部信息 + zlib算法压缩的文件内容 我们往 zlib算法压缩的文件内容 前补上 gzip 的头部信息, 再把它给 gzip 解压, 就能拿到数据   可以方便地查看以zlib压缩的文件.\n例子:\n$ zlipd() (printf \u0026quot;\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\u0026quot; |cat - $@ |gzip -dc 2\u0026gt; /dev/null) # 定义函数\r$ zlipd objects/81/c545efebe5f57d4cab2ba9ec294c4b0cadf672\rblob 51234\r 如果你清楚 Object 文件的格式的话, 你也可以使用git cat-file \u0026lt;Object类型\u0026gt; \u0026lt;SHA-1\u0026gt;命令来直接查看 Object 文件的 data 区而忽略信息头:\n$ zlipd .git/objects/fe/7ce18c5d359042f6eb43e81cf7119240dd3681| xxd\r00000000: 7472 6565 2033 3300 3130 3036 3434 2063 tree 33.100644 c\r00000010: 2e74 7874 009c 9ddc 2cc3 6ec5 8f5f c76c .txt....,.n.._.l\r00000020: 7c51 57cf c046 dd79 ea |QW..F.y.\r$ git cat-file tree fe7c | xxd\r00000000: 3130 3036 3434 2063 2e74 7874 009c 9ddc 100644 c.txt....\r00000010: 2cc3 6ec5 8f5f c76c 7c51 57cf c046 dd79 ,.n.._.l|QW..F.y\r00000020: ea .\r 当然你也可以这样用, 让 Git 帮你查看文件类型(git cat-file -t \u0026lt;SHA-1\u0026gt;返回 Object 类型):\n$ cat-obj() (git cat-file $(git cat-file -t $@) $@)\r$ cat-obj fe7c | xxd\r00000000: 3130 3036 3434 2063 2e74 7874 009c 9ddc 100644 c.txt....\r00000010: 2cc3 6ec5 8f5f c76c 7c51 57cf c046 dd79 ,.n.._.l|QW..F.y\r00000020: ea .\r 为了按字节查看内容, 我们可以使用xxd:\n$ zlipd objects/81/c545efebe5f57d4cab2ba9ec294c4b0cadf672 | xxd\r00000000: 626c 6f62 2035 0031 3233 340a blob 5.1234.\r 一般的, 右边预览的.可能表示:\n 点本身 空格或换行等不可打印/不好打印的字符  另外可以试试下面的命令:\n$ zlipd .git/objects/fe/7ce18c5d359042f6eb43e81cf7119240dd3681 | xxd -g 1 | cut -d ' ' -f2-18 | sed 's/ /\\\\x/g' 74\\x72\\x65\\x65\\x20\\x33\\x33\\x00\\x31\\x30\\x30\\x36\\x34\\x34\\x20\\x63\\x\r2e\\x74\\x78\\x74\\x00\\x9c\\x9d\\xdc\\x2c\\xc3\\x6e\\xc5\\x8f\\x5f\\xc7\\x6c\\x\r7c\\x51\\x57\\xcf\\xc0\\x46\\xdd\\x79\\xea\\x\\x\\x\\x\\x\\x\\x\\x\r  xxd -g 1表示1个八位bit一节地输出(也就是两位hex) cut -d ' ' -f2-18将每行输入按空格分隔后取2到18列 sed 's/ /\\\\x/g'将输入中每个空格换成\\x  这样获得的输出可以轻易地在别的文本编辑器中将其转换成 Python 的 bytes.\n$ find .git/objects -type f .git/objects/80/4d54e8fc16d18edccd6a8469e6584800e2c936\r.git/objects/0e/f6a7016afc43d518cef9786c8c6075564f32fb\r.git/objects/81/c545efebe5f57d4cab2ba9ec294c4b0cadf672\r.git/objects/9c/9ddc2cc36ec58f5fc76c7c5157cfc046dd79ea\r.git/objects/fe/7ce18c5d359042f6eb43e81cf7119240dd3681\r.git/objects/05/e7801182a544c4abbf92588d3d2ab04391ef15\r.git/objects/7e/f4c762de36ab4569c8f8bd0be86c871e68cbc9\r 获得目录下所有文件的名字.\nObject 文件 概念模型 一个Object 文件是指存放在.git/objects目录下的文件, 它们都是一种压缩文件, 以自己未压缩前的 SHA-1 作为路径存放在该目录下. Object 文件中记录了:\n Object 类型: blob/tree/commit/tag Object 数据的大小 Object 数据  前两项是泛用的文件头, 而对不同类型的 Object 它们又有不同种类的数据以不同二进制格式存放于 Object 数据这一区中.\n示意图:\n本文(及代码中)约定:\n raw: 指未压缩的整个文件内容 sha: 指未压缩的整个文件内容的 SHA-1, 即 sha1(raw) data: 指 Object 数据  下文中分对象类型介绍时一般仅仅介绍 Object 数据的概念/存放格式, 而省略前面的几个通用的数据头.\n二进制格式 从文件开头开始:\n 一个标识类型的 ASCII 字符串: 为 blob, tree, commit, tag 其中之一 一个分隔用的 ASCII 空格 Object 数据压缩前的大小, 以 byte 为单位, 写成数字后以 ASCII 字符串格式存起来 一个分隔用的 NUL 字符 Object 数据  然后再一起用zlib压缩之后存到对应的文件中. 代码如下:\n# Blob 类型文件的储存方法, 作为例子\rclass Blob(GitObject):\robj_type: Final[GitObjectType] = b'blob'\rdef deserialize(self, data: bytes) -\u0026gt; None:\rself.data = data\rdef serialize(self) -\u0026gt; bytes:\rreturn self.data\rdef pack_obj(obj: GitObject) -\u0026gt; tuple[str, bytes]:\rdata = obj.serialize()\rraw = obj.obj_type + b' ' + str(len(data)).encode('ascii') + b'\\x00' + data\rsha = hashlib.sha1(raw).hexdigest()\rreturn sha, raw\rdef write_obj(repo: GitRepo, obj: GitObject) -\u0026gt; None:\rsha, raw = pack_obj(obj)\rwith repo.open_object(sha, create=True) as f:\rf.write(zlib.compress(raw))\rdef unpack_obj(raw: bytes) -\u0026gt; GitObject:\robj_type, _, raw = raw.partition(b' ')\rlenght, _, data = raw.partition(b'\\x00')\rassert lenght == str(len(data)).encode('ascii')\rif obj_type == 'blob':\rreturn Blob(data)\relif obj_type == 'tree':\rreturn Tree(data)\relif obj_type == 'commit':\rreturn Commit(data)\relse:\rraise RuntimeError(f'Unsupport Object Type: {obj_type.decode(\u0026quot;ascii\u0026quot;)}')\rdef read_obj(repo: GitRepo, sha: str) -\u0026gt; GitObject:\rwith repo.open_object(sha, create=False) as f:\rreturn unpack_obj(zlib.decompress(f.read()))\r Blob 对象 概念模型 Blob: Binary Large OBject, 二进制大型对象的缩写.\n其实就是一个简单的放文件内容的容器.\n二进制格式 简简单单, data区里放的就是数据.\nclass Blob(GitObject):\robj_type: Final[GitObjectType] = b'blob'\rdef deserialize(self, data: bytes) -\u0026gt; None:\rself.data = data\rdef serialize(self) -\u0026gt; bytes:\rreturn self.data\r Commit 对象 概念模型: Kvlm/Key-Value List with Message Commit Object 的 data 部分就是简简单单的一个 kvlm.\n 建立 kvlm 概念的原因是因为 Commit 与 Tag 共享这个结构\n kvlm 其实就是一个有序键值对列表 + 一条信息. 比如:\n$ git cat-file -p 804d\rtree 7ef4c762de36ab4569c8f8bd0be86c871e68cbc9\rauthor Origami404 \u0026lt;Origami404@foxmail.com\u0026gt; 1613116353 +0800\rcommitter Origami404 \u0026lt;Origami404@foxmail.com\u0026gt; 1613116353 +0800\rCommit Message\r 键值对列表:\n tree : 7ef4c762de36ab4569c8f8bd0be86c871e68cbc9 author : Origami404 Origami404@foxmail.com 1613116353 +0800 committer : Origami404 Origami404@foxmail.com 1613116353 +0800  信息:\nCommit Message\r 一般来讲, 一个 Commit 对象大概会有下面这些信息:\n tree: 它对应的文件树 parent: 它的父 Commit 对象, 第一个 Commit 没有这个 field author: 作者 committer: 提交者  二进制格式 data区里放的是一个kvlm.\n下面定义kvlm:\nkvlm ::= \u0026lt;kv_list\u0026gt;\\n\u0026lt;message\u0026gt;\rvalue ::= \u0026lt;line\u0026gt;[(\\n\u0026lt;line\u0026gt;)*]\rline ::= \u0026lt;可打印非回车 ASCII 字符\u0026gt;\rkv_list ::= \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;\rkey ::= [0-9a-zA-Z]\rvalue ::= block\rmessage ::= block\r 简要描述:\n 文件被一个空行分为两部分: \u0026lt;kv-list\u0026gt; 与 \u0026lt;message\u0026gt;. \u0026lt;kv-list\u0026gt; 部分基本上一行一个 key-value 对, 以空格分隔 key 和 value. value 里可能有空格, 它也有可能是多行的. 这种情况下下一行开头会是一个空格表示自己是上一行的一部分. 这个空格不算在 value 里. \u0026lt;message\u0026gt; 的情况基本上和 value 类似.  例子/单元测试: (注意 python 多行字符串对回车的处理: Message后有一个回车)\nkvlm_data = b'''tree 7ef4c762de36ab4569c8f8bd0be86c871e68cbc9\rauthor Origami404 \u0026lt;Origami404@foxmail.com\u0026gt; 1613116353 +0800\rcommitter Origami404 \u0026lt;Origami404@foxmail.com\u0026gt; 1613116353 +0800\rmultiline aaaa\rbbbb\rcccc\rCommit Message\r'''\rkvlm_dct = {\rb'tree': b'7ef4c762de36ab4569c8f8bd0be86c871e68cbc9',\rb'author': b'Origami404 \u0026lt;Origami404@foxmail.com\u0026gt; 1613116353 +0800',\rb'committer': b'Origami404 \u0026lt;Origami404@foxmail.com\u0026gt; 1613116353 +0800',\rb'multiline': b'aaaa\\nbbbb\\ncccc'\r}\rkvlm_msg = b'Commit Message\\n'\rclass TestKvlm(TestCase):\rdef test_kvlm_parse(self) -\u0026gt; None:\rdct, msg = parse_kvlm(kvlm_data)\rself.assertDictEqual(dct, kvlm_dct)\rself.assertEqual(msg, kvlm_msg)\rdef test_kvlm_unparse(self) -\u0026gt; None:\rdata = unparse_kvlm(kvlm_dct, kvlm_msg)\rself.assertEqual(data, kvlm_data)\r 具体代码:\n# 从 Python 3.7 开始, 内置的 dict 类型已经保证有序了\rdef parse_kvlm(data: bytes) -\u0026gt; tuple[dict[bytes, bytes], bytes]:\rdct = {} # 要返回的 key-value 列表的对应字典\rlines = data.split(b'\\n') # 将输入按行分隔\rkey, value_lines = b'', [] # 当前的 key 与 value(按行分隔)\rmessage_begin = -1 # message 的起始行\r# Parse key-value list\rfor idx, line in enumerate(lines):\r# 如果一行以空格前导, 那么它是上一行 value 的一部分\rif line.startswith(b' '):\rvalue_lines.append(line[1:])\rcontinue\r# 如果其不以空格前导, 那么它可能是一个新的 key-value 对\r# 先将上一个 key-value 对加入 dct\rif key != b'':\rdct[key] = b'\\n'.join(value_lines)\r# 如果这行是个空行, 那么它是 key-value 列表与 message 的分隔行.\r# 记录 message 的起始行并 break\rif line == b'':\rmessage_begin = idx + 1\rbreak\r# 如果不是空行, 那么它是一个新的 key-value 对\r# 按第一个空格将其分为 key 和 value 的第一行\rkey, _, value = line.partition(b' ')\rvalue_lines = [value]\r# Parse message\rassert message_begin != -1\rmessage = b'\\n'.join(lines[message_begin:])\rreturn dct, message\rdef unparse_kvlm(dct: dict[bytes, bytes], message: bytes) -\u0026gt; bytes:\rlines = []\rfor key, value in dct.items():\r# value 里的回车在下一行要加前导空格以转义\rescaped_value = value.replace(b'\\n', b'\\n ')\rlines.append(key + b' ' + escaped_value)\rlines.append(b'')\rlines.append(message)\rreturn b'\\n'.join(lines)\r Wait, does that make Git a blockchain? 轻松一下.\n摘自Write yourself a git:\n Wait, does that make Git a blockchain?\nBecause of cryptocurrencies, blockchains are all the hype these days. And yes, in a way, Git is a blockchain: it’s a sequence of blocks (commits) tied together by cryptographic means in a way that guarantee that each single element is associated to the whole history of the structure. Don’t take the comparison too seriously, though: we don’t need a GitCoin. Really, we don’t.\n 翻译:\n 等等, Commit Object 是不是把 Git 变成了一个区块链?\n因为加密货币的缘故, 区块链如今已被大肆吹捧了. 确实, 在某种层面上, Git 确实是一个区块链: 它是一系列的区块(Commit Object)通过某种密码学方法绑定起来, 并且这种方法保证每一个区块都与其全部历史联系起来. 但不要太认真了: 我们真的不需要某种\u0026quot;吉特币(GitCoin)\u0026quot;, 真的.\n Tree 对象 概念模型 Tree Object 储存了文件在文件系统里的结构. 每个 Commit Object 都有一个表示 work_path 的 tree-sha1 键值对.\n具体映射:\n 目录 -\u0026gt; Tree Object 文件 -\u0026gt; Blob Object  如图:\nTODO\n一个 Tree Object 包含的信息可以抽象化描述为 (权限模式, 名字, SHA-1) 三元组的列表\n举个例子:\n$ tree .\r.\r├── a.txt\r└── b\r└── c.txt\r1 directory, 2 files\r 然后把整个工作目录 Commit 上去, 那么我们就会有:\n 两个 Blob 对象分别存放 a.txt 与 b.txt 的内容 两个 Tree 对象分别存放 . 与 ./b 目录的内容 一个 Commit 对象保存着现在 . 那个 Tree 对象的 SHA-1  $ git cat-file -p fe7c\r100644 blob 9c9ddc2cc36ec58f5fc76c7c5157cfc046dd79ea c.txt\r$ git cat-file -p 05e7\r100644 blob 81c545efebe5f57d4cab2ba9ec294c4b0cadf672 a.txt\r040000 tree fe7ce18c5d359042f6eb43e81cf7119240dd3681 b\r 对于保存着 . 的那个 Tree 对象来讲:\n   权限模式 名字 SHA-1     100644 a.txt 81c545efebe5f57d4cab2ba9ec294c4b0cadf672   040000 b fe7ce18c5d359042f6eb43e81cf7119240dd3681    对于保存着 ./b 那个 Tree对象来讲:\n   权限模式 名字 SHA-1     100644 c.txt 9c9ddc2cc36ec58f5fc76c7c5157cfc046dd79ea    二进制格式 Tree 的data由一堆有序的无分隔符的条目组成.\n其中每一个条目包含:\n mode: 描述文件权限的 5位或6位 ASCII 数字 分隔用空格 name: 文件的名字, 字节序列跟文件系统里的相同 分隔用 NUL sha1_raw: 以二进制格式存储的 SHA-1 值   下面的文件有的专门指文件, 有的包括了文件/文件夹/设备 or whatever, 读者应该可以根据常识区分.\n mode 其实是 UNIX 文件系统里 modes 的一个小子集. 具体来讲我只找到这几种:\n 100644: 普通文件 100664: 普通文件, 但同组用户可写 100755: 可执行文件 120000: 符号链接 (Symbolic Link) 040000: 目录 (储存为40000, 不存第一位的0) 160000: 子模块   134 来自 Git Internals\n56 来自SO: [https://stackoverflow.com/questions/54596206/what-are-the-possible-modes-for-entries-in-a-git-tree-object]\n2 来自SO: [https://stackoverflow.com/a/8347325]\n  对于泛用的 UNIX mode 这里有一点解释. 简单来说前两位表示文件类型, 第三位是 \u0026ldquo;set-uid/set-gid/sticky bits\u0026rdquo;, 表示可执行文件运行时的权限(参考); 后三位就是普通的 Unix 权限 mode.\n name 就是文件的名字. 文件在文件系统里的名字存的什么字节序列就是什么.\nsha1_raw 是将 SHA-1 的数值 依大端序存为 20 bit 的 unsigned int 后的字节序列.\n具体到实现上就是这样:\nclass TreeItem:\r'''储存 Tree Object 里的一个条目'''\rdef __init__(self, mode: bytes, name: bytes, sha1_raw: bytes) -\u0026gt; None:\rself.mode = mode\rself.name = name\rself.sha1_raw = sha1_raw\rdef serialize(self) -\u0026gt; bytes:\rreturn self.mode + b' ' + self.name + b'\\x00' + self.sha1_raw\r@property\rdef sha1(self) -\u0026gt; str:\r# 大端序\rsha1_int = int.from_bytes(self.sha1_raw, 'big')\r# 去除前导的 0x\rreturn hex(sha1_int)[2:]\rclass Tree(GitObject):\robj_type: Final[GitObjectType] = b'tree'\rdef deserialize(self, data: bytes) -\u0026gt; None:\rself.items: List[TreeItem] = []\ritem_beg = 0\r# 每个 TreeItem 之间没有分隔符\rwhile True:\r# 找到每一个 TreeItem 用于分隔 文件名 的 空格\rname_beg = data.find(b' ', item_beg)\rmode = data[item_beg : name_beg] # mode 可能是 5 位或 6 位\r# 找到每一个 TreeItem 用于分隔 SHA-1 的 NUL 字符\rsha_beg = data.find(b'\\x00', item_beg)\rname = data[name_beg+1 : sha_beg] # 文件名可以任意长 (name_beg+1 以跳过分隔符)\r# 加上 SHA-1 的 二进制格式的长度+1 作为 item 的尾后指针\ritem_end = sha_beg + 21\rsha1_raw = data[sha_beg+1 : item_end] # SHA-1 的二进制格式必为 20 位 (sha_beg+1 以跳过分隔符)\r# 若找不到 name 了就退出\rif name_beg == -1:\rbreak\r# 解析成 TreeItem 并设置新的 item 的开始\rself.items.append(TreeItem(mode, name, sha1_raw))\ritem_beg = item_end\rdef serialize(self) -\u0026gt; bytes:\rreturn b''.join(map(lambda item: item.serialize(), self.items))\r Tag Object Git 中的 Tag 有两种:\n 轻量级 Tag (Lightweight Tags): 就是普通的对某对象的引用. 标注的 Tag (Annotated Tags): 对一个储存了一些元信息的对象(Tag Object)的引用.   关于引用请参看下文\n 本节所描述的 Tag Object 指的自然就是那个储存着元信息的对象.\n概念模型 高度类似 Commit Object. 有时候你会想知道到底是谁在什么时候打的某个 Tag. 这时候你就要创建一个 Tag Object 把这些信息写进去, 然后创建一个 Annotated Tag 让它指向这个 Tag Object.\n二进制格式 就是一个 Kvlm.\nclass Tag(GitObject):\robj_type: Final[GitObjectType] = b'tag'\rdef deserialize(self, data: bytes) -\u0026gt; None:\rself.dct, self.msg = parse_kvlm(data)\rdef serialize(self) -\u0026gt; bytes:\rreturn unparse_kvlm(self.dct, self.msg)\r 一个概览的例子 我们创建一个作为例子的小仓库来查看 Git 的具体格式.\n$ git --version\rgit version 2.30.1\r $ git init\r$ echo '1234' \u0026gt; a.txt\r$ git add a.txt\r$ git commit -m \u0026quot;Commit Message\u0026quot;\r $ tree -a .\r.\r├── a.txt\r└── .git\r├── branches\r├── COMMIT_EDITMSG\r├── config\r├── description\r├── HEAD\r├── hooks\r│ ├── applypatch-msg.sample\r│ ├── commit-msg.sample\r│ ├── fsmonitor-watchman.sample\r│ ├── post-update.sample\r│ ├── pre-applypatch.sample\r│ ├── pre-commit.sample\r│ ├── pre-merge-commit.sample\r│ ├── prepare-commit-msg.sample\r│ ├── pre-push.sample\r│ ├── pre-rebase.sample\r│ ├── pre-receive.sample\r│ ├── push-to-checkout.sample\r│ └── update.sample\r├── index\r├── info\r│ └── exclude\r├── logs\r│ ├── HEAD\r│ └── refs\r│ └── heads\r│ └── master\r├── objects\r│ ├── 7e\r│ │ └── f4c762de36ab4569c8f8bd0be86c871e68cbc9\r│ ├── 80\r│ │ └── 4d54e8fc16d18edccd6a8469e6584800e2c936\r│ ├── 81\r│ │ └── c545efebe5f57d4cab2ba9ec294c4b0cadf672\r│ ├── info\r│ └── pack\r└── refs\r├── heads\r│ └── master\r└── tags\r16 directories, 26 files\r$ git cat-file -t 81c5\rblob\r$ git cat-file -t 7ef4\rtree\r$ git cat-file -t 804d\rcommit\r Blob Object $ zlipd .git/objects/81/c545efebe5f57d4cab2ba9ec294c4b0cadf672 blob 51234\r$ zlipd .git/objects/81/c545efebe5f57d4cab2ba9ec294c4b0cadf672 | xxd\r00000000: 626c 6f62 2035 0031 3233 340a blob 5.1234.\r Commit Object $ zlipd .git/objects/80/4d54e8fc16d18edccd6a8469e6584800e2c936 commit 185tree 7ef4c762de36ab4569c8f8bd0be86c871e68cbc9\rauthor Origami404 \u0026lt;Origami404@foxmail.com\u0026gt; 1613116353 +0800\rcommitter Origami404 \u0026lt;Origami404@foxmail.com\u0026gt; 1613116353 +0800\rCommit Message\r$ zlipd .git/objects/80/4d54e8fc16d18edccd6a8469e6584800e2c936 | xxd\r00000000: 636f 6d6d 6974 2031 3835 0074 7265 6520 commit 185.tree 00000010: 3765 6634 6337 3632 6465 3336 6162 3435 7ef4c762de36ab45\r00000020: 3639 6338 6638 6264 3062 6538 3663 3837 69c8f8bd0be86c87\r00000030: 3165 3638 6362 6339 0a61 7574 686f 7220 1e68cbc9.author 00000040: 4f72 6967 616d 6934 3034 203c 4f72 6967 Origami404 \u0026lt;Orig\r00000050: 616d 6934 3034 4066 6f78 6d61 696c 2e63 ami404@foxmail.c\r00000060: 6f6d 3e20 3136 3133 3131 3633 3533 202b om\u0026gt; 1613116353 +\r00000070: 3038 3030 0a63 6f6d 6d69 7474 6572 204f 0800.committer O\r00000080: 7269 6761 6d69 3430 3420 3c4f 7269 6761 rigami404 \u0026lt;Origa\r00000090: 6d69 3430 3440 666f 786d 6169 6c2e 636f mi404@foxmail.co\r000000a0: 6d3e 2031 3631 3331 3136 3335 3320 2b30 m\u0026gt; 1613116353 +0\r000000b0: 3830 300a 0a43 6f6d 6d69 7420 4d65 7373 800..Commit Mess\r000000c0: 6167 650a age.\r Tree Object $ zlipd .git/objects/7e/f4c762de36ab4569c8f8bd0be86c871e68cbc9 | xxd 00000000: 7472 6565 2033 3300 3130 3036 3434 2061 tree 33.100644 a\r00000010: 2e74 7874 0081 c545 efeb e5f5 7d4c ab2b .txt...E....}L.+\r00000020: a9ec 294c 4b0c adf6 72 ..)LK...r\r","date":"2021-02-19","permalink":"https://blog.origami404.top/git-impl/2021-02-git-impl-object-file/","tags":["mgit","Git","轮子"],"title":"Git 实现: Object 文件"},{"content":"前言 写这篇文章一开始主要是受到了 Write Yourself a Git, 深入理解Git实现原理 这两篇文章的激励. 俗话说学会使用轮子的最佳方法就是造一个轮子(其实是我刚刚说的), 而在使用 Python 实现的过程中又多少碰到了点前面两篇文章没有覆盖到的细节点, 特记录于此, 以飨读者.\n本文章介绍顺序是先介绍其存储用的数据结构, 分别按其概念模型(包含了什么信息, 为什么要这样设计)及其二进制格式(储存在文件系统中的格式)来介绍; 随后再描述如何实现 Git 的常用功能.\n本文章不是 Git 的教程, 如果读者对 Git 的操作并非十分了解的话可以参考 ProGit, 一本非常好的 Git 教材.\n本文对于细节扣得有点多, 可能并不适合只想理解 Git 底层模型的读者.\n或者也可以像我一样现学现写.\n本文的配套代码及 Markdown 源码一同发布于 GitHub: mgit, 可以配套查看. (顺着 Commit 看我怎么挣扎着理解的说不定别有一番乐趣).\n由于作者水平有限, 时间亦有限, 错漏难免, 还请大佬指正.\n目录  目录 \u0026amp; 前言 \u0026amp; Git repo Object 文件 Stage / 暂存区 指令: 底层与高层 结语  个人总结 Git 的设计理念其实深受 Unix 哲学的影响:\n 将文件系统本身作为一个 键值对数据库 数据本身作为文本流而存储/处理 (虽然并非完全如此) 并不使用专门的数据结构以压缩存储空间, 而是使用文本+泛用的压缩算法 后端结构非常简单, (但对用户前端的抽象没做好emmm), 核心算法简单到基本不可能有错 暴露出可以访问底层结构的命令行接口 数据储存使用分隔符作为 Field 间的分隔而不是定长 (虽然也并非完全如此)  .git 目录结构 Git 将目录分为三个区:\n 工作目录 (working directory): 即目录中除了 .git 目录之外的所有文件, 也就是我们平时写代码的地方 暂存区 (index or staging area): 就是平时 add 完文件之后改动暂存的地方, 在 .git/index 下. 这里的改动会在下一次 commit 的时候被加入到 repo 里 Git 仓库 (Git Repository): 存放 git 的所有信息的地方, 也就是 .git 目录  Git Repository $ tree .git\r.git\r├── branches # ├── COMMIT_EDITMSG # 最近 Commit 时打的 Commit Message. 提供这个文件主要是为了与各种 editor 交互\r├── config # 配置文件\r├── description # 仓库描述文件\r├── HEAD # 当前\r├── hooks # ├── index # 暂存区文件\r├── info # │ └── exclude\r├── logs # 日志\r│ ├── HEAD\r│ └── refs\r│ └── heads\r│ └── master\r├── objects # 对象数据库\r│ ├── 7e\r│ │ └── f4c762de36ab4569c8f8bd0be86c871e68cbc9\r│ ├── info\r│ └── pack # 压缩\r└── refs # 引用\r├── heads\r│ └── master\r└── tags\r 其中config文件是一个语法类似INI文件的配置文件, 例子:\n[core]\r# 仓库格式版本(似乎一直是0就没变过)\rrepositoryformatversion = 0\r# 是否记录文件权限\rfilemode = false\r# 是否允许没有 workpath bare = false\rlogallrefupdates = true\r# 文件系统是否支持 符号链接\rsymlinks = false\r# 是否忽略大小写\rignorecase = true\r 杂项: Python 相对路径 import  不知道查了多少次了 :(\n 一句话: 用相对路径 import 的文件就不要运行. 要运行的文件就不要用相对路径.\n可以将用相对路径的文件xxx.py放进包里, 然后在包外run_xxx.py内使用包名引用. 此时必须使用python -m run_xxx.py.\n下一篇: Object 文件\n","date":"2021-02-19","permalink":"https://blog.origami404.top/git-impl/2021-02-git-impl-content/","tags":["mgit","Git","轮子"],"title":"Git 实现: 目录 \u0026 前言 \u0026 Git repo"},{"content":"背景 想调整一下分区大小, 结果一不小心删掉了 ESP\u0026hellip;\n前置知识 ESP, 全称EFI System Partition, 是一个在物理硬盘主分区表上的特殊分区, 它:\n 是 FAT 格式的; (可以是 FAT16/FAT32 ) 与操作系统无关, 而是 UEFI 固件用来寻找引导器的存储空间 一般分区表会使用 GPT 而非 MBR, 因为现有的 UEFI 固件都不怎么支持 MBR 上的启动  创建分区 用你喜欢的分区软件, 创建一个大概 512MiB 大的 FAT32 分区(理论上在哪都行). 然后跑一遍mkfs:\nmkfs.fat -F32 /dev/\u0026lt;ESP\u0026gt;  构建内核 挂载原来的系统:\nsudo mount /dev/\u0026lt;SYSTEM\u0026gt; /mnt sudo mount /dev/\u0026lt;ESP\u0026gt; /mnt/boot sudo manjaro-chroot /mnt  注意必须要用manjaro-chroot(如果是 Archlinux 的话就arch-chroot)而不是普通的chroot. chroot似乎不会继承 EFI Variables 导致下面 grub-install 失败.\nmanjaro-chroot会自己把非文件分区绑定上, 所以不需要再打那三行sudo mount --bind /dev /mnt/dev之类的了.\n然后更新一下内核; 内核会把自己放进/boot里:\nsudo pacman -S linux  可以去检查一下/boot下是否已经有vmlinuz-*文件了.\n修复引导 grub-install --recheck /dev/sdX --efi-directory=/boot grub-mkconfig -o /boot/grub/grub.cfg  如果在这一步出现了报错: efi variables are not supported on this system, 那么:\n 检查您的 Live CD 启动方式是否为 UEFI. 比如说在 Live CD 的 shell 里运行efibootmgr, 如果输出是一堆那就是 UEFI; 如果报错那就不是. 检查您是否使用了 chroot 而非 manjaro-chroot.  最后 祈祷并重启. 完好的系统又回来啦.\n","date":"2020-10-31","permalink":"https://blog.origami404.top/post/2020-10-boot-recovery-in-uefi/","tags":["折腾"],"title":"UEFI下的引导恢复"},{"content":"前言 \u0026amp; Anbox 简介 最近换回了 Manjaro 和 Xfce, 打算认认真真地开始将 Linux 作为日常生活系统而不仅仅是开发系统来用了. 然而在日常生活中, 总归是逃不掉某国产IM的 :(. 为了实现以 Manjaro 作为生活主力系统的目标, (同时也为了以后说不定能愉快地打游戏), 决定安装一个能跑安卓应用的东西. 于是我的 Anbox 之旅就在完全搞不懂 Android x86 是什么玩意的情况下展开了.\nAnbox 官网上的介绍:\n Anbox: Android in a Box Run Android applications on any GNU/Linux operating system. Anbox puts the Android operating system into a container, abstracts hardware access and integrates core system services into a GNU/Linux system. Every Android application will be integrated with your operating system like any other native application.\n 简单来讲就类似 docker , 利用 LXD 技术在 Linux 系统里新建一个全新的容器, 然后直接去跑一个 Android x86. 好处嘛就是跑得比虚拟机快, 集成度比虚拟机好. 坏处嘛就是兼容性还是有待提高\u0026hellip;\n安装 安装之前\u0026hellip; 确保您的内核支持 /dev/ashmem 和 /dev/binder, 如果没有, 请参照: \n安装 Anbox Anbox 分为两块, 一块是本体, 一块是安卓镜像.\narchlinuxcn 使用 archlinuxcn 的并且没有特殊需求的老哥可以直接用 archlinuxcn 里的.\n$ pacman -Ss anbox archlinuxcn/anbox-git 1:1282.170f1e0-2 Running Android in a container archlinuxcn/anbox-image 1:2018.07.19-1 Android image for running in Anbox $ pacman -S anbox-git anbox-image  注意, 此镜像就是一纯的 AOSP , 没有谷歌框架, 没有 ARM 译码器.\naur $ pikaur -Ss anbox aur/anbox-git 1:r1240.c1e7550-1 (134, 0.86) # 本体 Running Android in a container aur/anbox-image 1:2018.07.19-1 (67, 0.36) # 纯净镜像 Android image for running in Anbox aur/anbox-image-gapps 2018.07.19-15 (18, 0.40) # 带 Google 框架的镜像 Android image for running in Anbox, with OpenGApps and Houdini aur/anbox-image-houdini-rooted 2018.07.19-5 (6, 0.67) # 带译码器, SuperSU 的镜像 Android image for running in Anbox with Houdini and SuperSU aur/anbox-image-gapps-rooted 2018.07.19-7 (4, 0.04) # 带 Google 框架, SuperSU 的镜像 Android image for running in Anbox with Houdini, OpenGApps and SuperSU aur/anbox-image-houdini 2018.07.19-5 (3, 0.03) # 带译码器的镜像 Android image for running in Anbox with Houdini   Houdini (某知名动画软件) libhoudini, 是 Android x86 默认采用的, 将 arm 架构译码到 x86 的转换层.\n简单来说, 有了它, Android x86 就可以安装/运行很多基于 ARM 的 Apk/App 了. (理所当然地, 会变慢, 并且不是全部都能跑. 但是对于现代电脑来说这点性能损失完全抵消不掉其对手机处理器的性能优势)\n 把 本体 装上之后再挑一个 镜像 装上就可以了.\n安装之后 挂载 binder:\nmkdir /dev/binderfs sudo mount -t binder binder /dev/binderfs  启动服务:\nsudo systemctl start anbox-container-manager.service sudo systemctl enable anbox-container-manager.service # 让这个服务每次开机之后保持运行  启动 Anbox 的应用抽屉:\nanbox launch --package=org.anbox.appmgr --component=org.anbox.appmgr.AppViewActivity  如果有像下面这样的报错:\nThe name org.anbox was not provided by any .service fil  请检查您是否完成上面两步. 同时您还可以查看日志:\nsudo systemctl status anbox-container-manager.service  替换内核 根据 Arch Wiki 的 Anbox 页面, 5.7.0 及以上的内核需要重新编译开启某些选项来支持 binder 等功能.\n5.7.0 以下的内核直接安装名字里带有 dkms 的包即可.\n通过 aur  在编译完之后才发现 aur 里直接就有\u0026hellip;\n pikaur -S linux-xanmod-anbox  随后重启.\n自己编译 当初看鸟哥的私房菜的时候, 编译内核还是高级操作, 搞得我一开始还害怕极了\u0026hellip; 后来发现前辈们早已为我们准备了各种各样的工具, 编译内核? 几行搞定!\n 主要参考: [extendswind] Manjaro内核编译\n 下载源码 如果您在时隔多年(?)以后看我的文章的话, 记得把链接最后那个 linux58 改成您想要的版本号.\ngit clone https://gitlab.manjaro.org/packages/core/linux58.git  (可选) 修改makepkg的编译选项 主要就是开一个-march=native. 编辑 /etc/makepkg.conf, 将 CFLAGS 和 CXXFLAGS 改为:\nCFLAGS=\u0026quot;-march=native -O2 -pipe -fstack-protector-strong -fno-plt\u0026quot; CXXFLAGS=\u0026quot;-march=native -O2 -pipe -fstack-protector-strong -fno-plt\u0026quot;  这个选项是让 gcc 自己选择当前平台的优化. 参见 Arch Wiki 上的介绍\n编译 查看 clone 下来的 PKGBUILD 文件可以看到, Manjaro 团队已经很贴心地帮我们把 Anbox 的内核编译参数写好加进去了. 所以我们只需要编译就好了\nconfig.anbox 的内容:\nCONFIG_ASHMEM=y # CONFIG_ION is not set CONFIG_ANDROID=y CONFIG_ANDROID_BINDER_IPC=y CONFIG_ANDROID_BINDERFS=y CONFIG_ANDROID_BINDER_DEVICES=\u0026quot;binder,hwbinder,vndbinder\u0026quot; # CONFIG_ANDROID_BINDER_IPC_SELFTEST is not set  编译!\n./autogen.sh makepkg  在本人的 i5-7500 上编译大概要一小时, 编译完之后安装产出的 linux58-headers-5.8.13-3-x86_64.pkg.tar.xz 包即可:\nsudo pacman -U linux58-headers-5.8.13-3-x86_64.pkg.tar.xz  然后重启.\n最后 deepin.com.qq.office 跟 deepin.com.wechat2 真香! 结果又花了几个小时的时间折腾了没意义的东西呢!\n","date":"2020-10-02","permalink":"https://blog.origami404.top/post/2020-10-anbox-and-compile-kernel/","tags":["折腾"],"title":"Anbox 踩坑 \u0026 Manjaro 下的内核编译"},{"content":"前言 用Python写了个Scheme解释器, 代码. 记录一下Python的类型标注要怎么用, 有什么坑.\n 话说回来这好像是我第一篇技术性文章\u0026hellip;?\n不务正业实锤\n  本文假定您已有支持编译期泛型的静态类型语言的编程背景, 比如C++, Haskell之类的.\n 基础 Q \u0026amp; A 类型标注是什么 是Python在3.5版本以后推出的一种船新语法, 可以让你在代码(而不是注释)里比较自然地标记上你期望这个变量/函数参数/函数返回值是什么类型.\n它会让我的程序变慢吗 不会. 因为Python在运行时压根不会管这些标注. 换句话讲, 这个语法就是一个官方钦定的标识变量/函数类型的注释\n 不会有人写Python了还在意性能吧?\n 类型标注有什么用啊 有许多linter已经支持了基于类型标注的静态代码查错, 最出名的一个是mypy. 也有许多IDE(比如PyCharm, VSCode)都可以获取类型标注里的信息来给你提示.\n所以它能让你:\n 尊享静态类型语言的IDE补全体验 免去一部分啰里啰唆的注释: 好的类型声明即是好的文档   如果普通的Python写起来像是在把史莱姆捏成合适的形状的话, 类型标注就是能帮你把史莱姆撑起来的骨头\n 基本语法 大体上就是\u0026lt;id\u0026gt;: \u0026lt;type\u0026gt; (= \u0026lt;var\u0026gt;)这个样子\n# 可以在普通的变量上加 a: int b: str = '我是str' # 可以在函数参数上加, 返回类型用箭头表示 # *arg 跟 **kw 不能加 def f(a: int, b: str='a str', *arg, **kw) -\u0026gt; None: return # lambda 的参数跟返回的东西都不可以加 x = lambda x: x   为什么lambda表达式不能加类型标注的原因可以看这个: Stackoverflow: Is it possible to type hint a lambda function?\n简单来讲就是如果要加上类型标注的话lambda的语法可能要修改成这个样子以区分类型标注的冒号跟参数列表/lambda体之间的冒号:\nlambda (x: str) -\u0026gt; int: ...\n然而这是个破坏性的改动, 而且看起来一点都不\u0026rsquo;pythonic\u0026rsquo;, 所以就没动.\n 那么什么东西可以写在类型标注那里(\u0026lt;type\u0026gt;)呢?\n type对象 typing里出来的各种东西, 下面简称标注对象 None  typing里面的东西主要有:\n TypeVar: 用TypeVar定义出来的泛型类型参数 SpecialForm: Any, NoReturn, Union GenericAlias: 常用数据结构的泛型化别名, 比如: List, Tuple, Dict ProtocolMeta: Support*, 主要看你类有没有对应的__xxx__  基本上后者就是前者的弱化版, 只保留了前者标记类型和作为构造函数的功能, 而不能当作isinstance的参数使用.\ntyping模块的文档在这里.\n常见用法  以下代码均假设你在开头已经from typing import *\n Python 内置的各种的type 基本上就是int, float, str, byte之类的老面孔, 没什么好说的.\n内置容器类型的GenericAlias 包括: List[T], Tuple[T1, T2, ...], Dict[KT, VT], Iterable[ReturnT]\n方括号里的东西叫subscript, 加上了subscript的generic就变成了Subscripted generics\n 其实基本上就是C++里那些什么vector\u0026lt;T\u0026gt;, map\u0026lt;KT, VT\u0026gt;里的T\n int_list: List[int] = [2, 1, 3, 4] # 现在int_list的类型就是只能放int的list tw_list: List[List[int]] = [int_list] # 套娃类型, subscript里可以放任何能在\u0026lt;type\u0026gt;里放的东西 # 下面三个的类型是等价的, 都是一个可以放任何东西的list any_list: List[Any] = ['asd', [12, 34, {'2': '3'}]] any_list_2: list = any_list any_list_3: List = any_list  和类型与积类型 构建和类型可以用Union[T1, T2, ...], 表示这个变量可以是T1或者T2\u0026hellip;\n构建积类型可以用Tuple[T1, T2, ...], 表示这个变量是一个元组, 里面的元素类型分别为T1, T2\u0026hellip;\nPython 函数的多返回值其实就是返回一个元组, 所以它的返回类型标注要使用Tuple\n特别地, Optional[T]等价于Union[T, None]\nint_or_str: Union[int, str] = '123' int_or_str = 123 # mypy不会报错 int_and_str: Tuple[int, str] = (123, '123') def reciprocal(n: float) -\u0026gt; Optional[float]: if n == 0: return None else: return 1 / n def make_a_pair(n: num) -\u0026gt; Tuple[int, str]: return n, str(n) # 等价于 return (n, str(n))  函数类型标记 mypy会检查你函数是不是在所有if分支里都会返回你标注的返回类型. 如果你觉得它很烦, 你可以直接在函数的末尾抛个异常, 这样它就不会管你了.\n换句话说, 类型标注不能标注这个函数会抛出什么异常. (精Java狂怒)\ndef I_am_tired() -\u0026gt; List[int]: raise RuntimeError(\u0026quot;I don't want to return anything.\u0026quot;)  没有返回值的函数可以标注返回值为None. 永远不会返回的函数可以标注返回值为NoReturn. 不标注返回类型的函数mypy默认它返回Any.\ndef assuming_len(l: list, length: int) -\u0026gt; None: if len(l) != length: raise RuntimeError('invaild length') def kill_myself() -\u0026gt; NoReturn: exit() # 等价于: def return_something_as_I_like() -\u0026gt; Any: def return_something_as_I_like(): n = random.randint(1, 3) if n == 1: return 1 elif n == 2: return '2' else: return (1, '2')  类型推断与转换 使用cast(目标类型, 要转换的变量)可以把变量从一个类型转换到另一个类型. cast不进行运行时类型检查.\n 换句话讲, cast相当于掐着linter的脖子指鹿为马\n当然也会有linter错把马认为是鹿的时候 (mypy是马鹿!)\n a: int = 1 b: str = cast(str, a) # 目标类型参数可以塞\u0026lt;type\u0026gt;能塞的东西而不仅仅是type对象 al: List[int] = [1, 2, 3] bl: List[str] = cast(List[str], al)  对于某个特定的变量, mypy的推导能力还是挺强的:\ndef to_int(a: Union[int, str]) -\u0026gt; int: if isinstance(a, int): return a # 这里a的类型就是int了 else: return int(a) # 这里a的类型就是str了  但是对于表达式就不能通过isinstance判断类型了:\ndef first_to_int(a: Union[List[int], List[str]]) -\u0026gt; int: if isinstance(a[0], int): b = a[0] # 这里b还是Union[int, str] return b else: return int(a[0])  另外对于列表之类的容器类型, 如果在声明后面紧接着跟一个赋值用的for循环的话, mypy就能推断出那个容器的类型. (其实一般写上也没什么问题)\nPython 3.8之后, typing多了一个蛮好用的Special Form: Literal, 它可以限定一个变量取特定的某些值, 比如:\nTypeTag = Literal['A', 'B', 'C'] a: TypeTag = 'D' # 报错  并且根据你在Literal里设定的字面量类型, a可以塞到更广泛的, 比如接受一个str作为参数的函数中去. 如果字面量类型里有多个类型的值, a会被扩展为Union[...]\n对于在代码中写死的变量而言, 它的类型会被推导为字面量类型:\nl = [1, 2, 3] # l 的类型被推导为List[Literal[1, 2, 3]]  但是如果你手动指定, 它就会是你手动指定的类型. 在本篇文章中为行文方便~~(我懒)~~, 在不引起迷惑的情况下上面l这种变量的类型一般写为List[int]\n泛型 基本 首先, 跟C++完全不一样的第一点是, Python的泛型参数不是跟函数/类型硬性绑定的, 也不是某种语法之类的, 而是一种对象, 在被绑定了之后就能作为标注对象放在标注那里.\n比如在C++里我们会这么写:\ntemplate\u0026lt;typename T\u0026gt; T abs(T x) { return x \u0026lt; 0 ? -x : x }  这个类型变量T显然是只能在abs里用的.\n但是在Python里我们要这样写:\n# 构造类型变量 T = TypeVar('T') a: T # 现在T没被绑定, 所以这行在mypy下会报错: Type variable \u0026quot;t.T\u0026quot; is unbound # 将T用在某个函数的参数上以将T绑定到这个函数里面 def abs(n: T) -\u0026gt; T: v: T = n # 在函数体里就可以用T来标注变量类型了 return -n if n \u0026lt; 0 else n b: T # 脱离了函数体之后T就被解绑了, 现在T又是没有被绑定的了, 这行也会报错  TypeVar的第一个参数必须要跟要绑定类型变量的名字相同, 要不然mypy会跟你抱怨.\n第二点不同的是, C++模板的类型检查只有在模板实例化的时候才会检查; 而Python的泛型更像Java和Haskell, 会要求类型至少满足在泛型函数中使用到的操作. 所以其实上面的Python泛型函数其实是会在mypy中报错的:\nerror: Unsupported operand type for unary - (\u0026quot;T\u0026quot;) error: Unsupported operand types for \u0026gt; (\u0026quot;int\u0026quot; and \u0026quot;T\u0026quot;)  所以其实我们要这么写:\nT = TypeVar('T', int, float) def abs(n: T) -\u0026gt; T: return -n if n \u0026lt; 0 else n  TypeVar后面的参数限定了它只能取的类型, 这里就只能塞type对象, 而不能塞标注对象.\n所以如果你像做下面这种操作的话:\nExplain = TypeVar('Explain') DataWithExplain = TypeVar('DataWithExplain', Tuple[V, int], Tuple[V, str]) def extract_data(v: DataWithExplain) -\u0026gt; V: return v[0]  当然是不可以的. 得这样写:\nExplain = TypeVar('Explain', int, str) Data = TypeVar('Data') def extract_data(v: Tuple[Data, Explain]) -\u0026gt; Data: return v[0]  另外, 虽然TypeVar可以限制能取的类型, 但是不能限制不能取的类型; Python的typing项目里有一个issue是关于这个的有一个关于支持这项功能的issue.\n泛型与重载 (坑) 在C++里, 我们经常会玩带模板参数的模板偏特化.\ntemplate\u0026lt;typename T\u0026gt; list\u0026lt;T\u0026gt; as_list(T a) { return list(1, a) } template\u0026lt;typename T\u0026gt; list\u0026lt;T\u0026gt; as_list(list\u0026lt;T\u0026gt; a) { return a }  在Python里你可能会想这样写:\nT = TypeVar('T') @overload def as_list(l: List[T]) -\u0026gt; List[T]: ... @overload def as_list(l: T) -\u0026gt; List[T]: ... def as_list(l): if isinstance(l, list): return l return [l]   关于这种先写声明再写实现的Python重载写法, 可以参考这个PEP 0484\n简单来说就是对Python来讲, 后来的重名函数会直接覆盖前面函数的定义, 所以要把实现写在最后面, 然后手动isinstacne分配\n 这个代码本身是没有问题的\u0026hellip;但是就是某些情况下达不到目的罢了\n对具体类型已知的变量, 上面这个函数都能工作得很好, 比如:\nl = as_list([2, 3, 4]) # l: List[int] v = as_list(1) # v: List[int] a: Union[int, List[int]] = 1 # 此时a的类型会被规约为int, 所以虽然它被标注为Union, 但是其实它的类型是一个具体的int b = as_list(a) # b: List[int], 此时mypy还能选择合适的重载  但是不是所有Union类型的变量都能被规约到具体的类型, 比如在函数参数里的:\ndef f(c: Union[int, List[int]]) -\u0026gt; List[int]: t = as_list(c) # 这里的类型就会变成 Union[List[int], List[List[int]]]而不是List[int] return t  这时候mypy就不能选择到正确的类型. (写本文时用到的mypy版本是0.782)\n也许你会想为什么我们不能直接这样写:\ndef as_list(l: Union[T, List[T]]) -\u0026gt; List[T]: return l if isinstance(l, list) else [l]  但是这样子写出来mypy并不会优先匹配最好的, 甚至在确定的类型中也不能得到期望的结果\nl = as_list([2, 3, 4]) # 这里就会出问题: l: Union[List[List[int], int] v = as_list(1) # v: List[int] a: Union[int, List[int]] = 1 # 此时a的类型会被规约为int, 所以虽然它被标注为Union, 但是其实它的类型是一个具体的int b = as_list(a) # b: List[int], 此时mypy还能选择合适的重载 def f(c: Union[int, List[int]]) -\u0026gt; List[int]: t = as_list(c) # 这里的类型还是 Union[List[int], List[List[int]]]而不是List[int] return t  或者你会说为什么不重载f写成这个样子:\n@overload def f(c: int) -\u0026gt; List[int]: ... @overload def f(c: List[int]) -\u0026gt; List[int]: ...  但是这意味着每一个用到as_list的函数都需要这样写一次重载, 这样我还不如手动内联呢:(\n什么时候如果mypy能够优先选择匹配度高的函数重载或者可以限定类型变量T不取list类型这个问题就能被解决了.\n泛型类型 通过继承Generic[T, ...]来将T, ...绑定到class里面.\nX, Y = TypeVar('X'), TypeVar('Y') class Pair(Generic[X, Y]): # 构造函数的返回值是None; 所有对象方法的self都可以不用标注 def __init__(self, car: X, cdr: Y) -\u0026gt; None: self.car, self.cdr = car, cdr  需要注意的是, 类似于Java, 运行时的泛型参数类型会被擦除掉; 意思就是说:\na: Pair[int, int] = Pair(2, 3) isinstance(a, Pair[int, int]) # 这里会报错  或者你也可以这么认为, 泛型类型对象加上subscript之后就是标注对象(或者GenericAlias)说了.\n用带subscript的泛型类型来构造对象的话, 构造函数就是对应subscript的类型; 否则就是按类型变量决定之后构造出对象之后再确定对象的subscript.\nNNPair = Pair[int, int] # 可以起别名; 真的就只是缩写, 没有特别的 a: NNPair = NNPair(2, [2, 3]) # 这个会报错: [2, 3]的类型不符合Pair[int, int] b: NNPair = Pair(2, [2, 3]) # 这个会报错: Pair[int, List[int]]的类型不符合NNPair  协变, 逆变和\u0026hellip; 不变(?) 协变的英文短一点, 是Covariance, co-variance.\n逆变的英文长一点, 是Contravariance, contra-variance.\n不变的英文基本上不会跟上面两个混起来, 是irvariance, ir-variance.\n在Python里, 协变/逆变的属性是可调节的, 并且是绑定在类型变量上的. (好奇怪啊\u0026hellip;)\n范畴论理解 Python里的泛型类型F[T]可以看作一个Functor/反-Functor(是叫这名字吗\u0026hellip;?)/啥也不是. 如果对任意两类型a, b:\n当存在态射(a -\u0026gt; b), 总有态射(F[a] -\u0026gt; F[b])\n那么说T对F是协变的(Functor); 反之, 若:\n当存在态射(a -\u0026gt; b), 总有态射(F[b] -\u0026gt; F[a])\n那么说T对F是逆变的(反-Functor); 如果T对F既不是协变的也不是逆变的, 那它就是不变的.\nPython理解 如果如果a是b的子类型, 那么F[a]是F[b]的子类型为真, 那T就是协变的;\n如果如果a是b的子类型, 那么F[b]是F[a]的子类型为真, 那T就是逆变的;\n如果T不协变也不逆变, 那T就是不变的;\n例子  范畴论例子:\n一个函数(a -\u0026gt; b), 固定a以b为参数, 那么b就是协变的; 固定b以a为参数, 那么a就是逆变的.\n 让我们考虑列表. 假如B是A的子类型(你可以假定class B(A)), C也是A的子类型.\nclass A: pass class B(A): pass class C(A): pass  只读列表是协变的 # 只读列表是协变的 CoT = TypeVar('CoT', covariant=True) class RList(Generic[CoT]): def __init__(self, l: List[CoT]) -\u0026gt; None: self.l = l def get(self, idx: int) -\u0026gt; CoT: return self.l[idx] # 考虑 a: RList[A] b: RList[B] # 因为所有的B都是A, 所以如果我们从RList里读出来一个B, 也没有什么关系, 总之把它当成A就可以了 # 所以所有的RList[B]应该都是RList[A]的子类型, 也就是说T对RList是协变的  只写列表是逆变的 ContraT = TypeVar('ContraT', contravariant=True) class WList(Generic[ContraT]): def __init__(self, l: List[ContraT]) -\u0026gt; None: self.l = l def set(self, idx: int, val: ContraT) -\u0026gt; None: self.l[idx] = val # 考虑: a: WList[A] b: WList[B] # 假如我有一个WList[A], 我总能把它当作一个WList[B]; 因为我总可以把类型为B的对象往WList[A]里写进去; # 所以所有的WList[A]都应该是WList[B]的子类型, 也就是说T对WList是逆变的  可读可写的列表是不变的 IrT = TypeVar('IrT') class RWList(Generic[IrT]): def __init__(self, l: List[IrT]) -\u0026gt; None: self.l = l def set(self, idx: int, val: IrT) -\u0026gt; None: self.l[idx] = val def get(self, idx: int) -\u0026gt; IrT: return self.l[idx] # 考虑 a: RWList[A] b: RWList[B] # 我能把RWList[A]当作RWList[B]吗? 不能. 我不能保证RWList[A]读出来的对象一定是B, 它可能是C # 我能把RWList[B]当作RWList[A]吗? 不能. 我不能保证拿A往里面写时A的实际类型就一定是B, 它可能是C # 所以T对于RWList是不变的  总结 不懂也没关系, 说明您的应用场景还不需要用到协变/逆变的概念. 多用用自然就会懂了.\n杂项 循环引用? 如果我要在类里标注类自己这种类型怎么办?\n答: 直接用字符串就可以了\nclass A: def get_self(self) -\u0026gt; 'A': return self  同样的方法还可以用来定义递归类型\nValueType = Union[int, str, 'Procedure'] Procedure = Callable[[ValueType], ValueType]  模块与包? 当你有这样一个目录结构:\nproject └── code ├── main.py └── my_util.py  并且在main.py里想import util.py的时候, 你会发现一个很尴尬的事情.\n如果你这样来:\n# main.py import my_util  那么mypy会找不到my_util.py, 因为同目录的文件并不在mypy找文件的路径里; 然后自动补全就gg了.\n如果你这样来:\nimport .my_util  在你运行python -u main.py的时候又会报错:\nImportError: attempted relative import with no known parent package  这个错是因为当python直接执行某个文件的时候, 这个文件就会变成__main__模块的一部分. 那么如果你在这个文件里使用相对路径来引用的话, python就不知道你这个相对路径是相对于你目录还是__main__模块了, 所以就直接ban掉这种import了.\n那么怎么办呢?\n首先你需要先把代码目录弄到mypy的补全路径里去. 在VSCode的Pylance拓展中你需要加入这样一条设置:\n\u0026quot;python.analysis.extraPaths\u0026quot;: [ \u0026quot;code\u0026quot; // 直接写你代码目录的名字, 不用加路径 ]  其次你要解决这个相对路径的问题. 那你直接就用第一种写法就可以了. 只要你的文件不跟python标准库的重名, python在找完所有路径之后没发现这个名字就会去找同一目录下的文件, 问题就解决了.\n杂项 Type类型 如果你需要某种类型的类型对象怎么办? 你可以使用Type GenericAlias:\nT = TypeVar('T') def safe_cast(obj: Any, cls: Type[T]) -\u0026gt; T: if isinstance(obj, cls): return cast(obj, cls) raise RuntimeError(f'Type not match: given: {type(obj).__name__}, expect: {cls.__name__}')  IDE配置 VSCode 您可以使用PyRight扩展搭配基础的Python扩展使用. 也可以直接使用微软\u0026quot;次世代\u0026quot;的Python插件Pylance.\n如果您使用Pylance的话, 可能还需要去设置里开启:\n\u0026quot;python.analysis.typeCheckingMode\u0026quot;: \u0026quot;basic\u0026quot;  基本上都是开箱即用的.\nPyCharm 由于本人没有PyCharm, 所以略.\n","date":"2020-07-21","permalink":"https://blog.origami404.top/compiler-and-type-theory/2020-07-python-and-type-annotations/","tags":["编程","Python"],"title":"Python 与 Type Annotations"},{"content":"前言 \u0026amp; 介绍 Category Theory for Programmers, 顾名思义, 是一本关于范畴论的书, 但是偏向CS而非数学.\n书的$\\LaTeX$代码以GPL-3.0公布在GitHub, 有两个版本, 一个以C++作为辅助说明语言, 另一个是Scala.\n作为一个蒟蒻OI党当然是选择C++版啦.\n本文(如果不咕咕咕的话)会持续更新, 大概记录一些摘录或者感想或者我不知道的东西\u0026hellip;\nPreface  Category Theory \u0026ndash; rather than dealing with particulars \u0026ndash; deals with structure. It deals with the kind of structure that makes programs composable.\n  Functional programming is not only about composing functions and algebraic data structures — it makes concurrency composable — something that’s virtually impossible with other programming paradigms.\n  It’s not that side effects are inherently bad — it’s the fact that they are hidden from view that makes them impossible to manage at larger scales. Side effects don’t scale.\n  I hope future generations will be as admiring of the programming skills we’ve been displaying in building complex operating systems, web servers, and the internet infrastructure. (上文提到我们尽管中世纪的石头建筑在现在可以方便地用钢筋混凝土结构搭建, 但我们还是惊叹于中世纪的工匠们那将石质结构发挥到他们的极限的精巧工艺)\n Part I - Category: The Essence of Composition  A category consists of objects and arrows that go between them.\n Category的Wikipedia链接\n我的误解\u0026hellip; Native的我, 一直把范畴当成一种特殊的有向图. 这本身没什么大毛病, 问题在于受OI题的影响, 我默认:\n 边与边之间唯一的区别就是起点与终点  但是, 范畴并不是这样的, 不同边在本质上就是不同的东西, 就算他们起点终点相同; 事实上, 存在一些许多范畴, 有无限多的自边, 比如下面很快被提到的Monoid范畴.\n还有, 如果把morphism看作边, (对我来说)很难形象地构造出所谓的composition\u0026hellip;\n那范畴是什么呢? 说了这么多, 其实范畴$C$就是一个拥有:\n 对象集合, 即一堆对象组成的集合, 记作 $\\operatorname{ob}(C)$ 态射集合, 即一堆定义域和值域都是 $\\operatorname{ob}(C)$ 里的函数, 记作 $\\hom(C)$. 特别地, 给定$a, b \\in \\operatorname{ob}(C)$, 我们把定义域为$a$且值域为$b$的态射集合记为 $\\hom(a, b)$ 态射复合, 对于$a, b, c \\in \\operatorname{ob}(C)$, 态射复合$\\circ$是一个函数$\\hom(a, b) \\times \\hom(b, c) \\rarr \\hom(a, c)$  对于$f \\in \\hom(a, b)$, 我们顺带还把这句话记作: $f : a \\rarr b$\n并且 $C$ 和 $\\circ$ 还要满足:\n 存在单位元: 即对任意$a, b \\in \\operatorname{ob}(C)$, 存在$\\mathbf{id_a} : a \\rarr a$和$\\mathbf{id_b} : b \\rarr b$, 对任意$f : a \\rarr b$, 有: $$\\mathbf{id_a} \\circ f = f \\circ \\mathbf{id_b} = f$$ 满足结合律: 即对任意$f : a \\rarr b,\\quad g: b \\rarr c,\\quad h: c \\rarr d$ 有: $$(f \\circ g) \\circ h = f \\circ (g \\circ h) = f \\circ g \\circ h$$  态射(morphism)就是函数的好听的名字, 跟函数交错使用看起来特别错落有致(?).\nHaskell小课堂: 声明函数 \u0026amp; 复合函数 在Haskell中我们可以通过:\nf :: A -\u0026gt; B  来声明一个从类型A到类型B的函数, 以大写字母开头的类型名会被当成具体的类型.\n而使用小写字母名开头的类型名会被当成泛化类型, 类似C++中的模板类型参数:\ng :: b -\u0026gt; c  函数的复合记作.:\nf . g  Part I - What Are Types?  The simplest intuition for types is that they are sets of values.\n 换句话讲, 类型定义等价于某个集合定义. 当我们说某个东西是什么类型的时候, 我们其实是在说:\u0026ldquo;看! 这个东西的值只能是这个这个这个这个和这个\u0026hellip;!\u0026rdquo;\n因此, 对programmer而言, 我们可以把类型当作对象, 把类型之间的函数当作态射来研究范畴.\n我们先从最简单的类型开始看起, 那就是空集$\\emptyset$对应的类型Void和只有一个元素的集合().\n$\\emptyset$ 和 Void 简而言之, Void在C++中没有对应类型, 而()对应于C++的void类型.\n想象一下, 如果一个函数以Void为输入类型, 那你要怎么调用它呢 \u0026ndash; 显然没有任何一个值是属于Void的, 所以你不可能调用它.\nf :: Void -\u0026gt; a f = blabla f ????  同时, 这时候a是不受任何约束的\u0026ndash;也就是说它的返回值是多态(polymorphic)的. 显然这样的函数只能有一个, 标准库(preinclude)里把它定义为:\nabsurd :: Void -\u0026gt; a  荒谬可还行\n 作者还提到在Curry-Howard isomorphism下这个函数代表恒假命题(falsity), 但是这可能要到很久之后了\n 单集(singleton set) 和 () 那么C++里的void对应的是什么呢? 每一个以空参数为输入的函数都是可以调用的, 而且仅能用一种方式调用, 那就是f(). 这说明C++里的void类型对应的集合其实是一个只有一个元素的集合, 简称单集(singleton set或unit set)(这个中文翻译我乱蒙的\u0026hellip;).\n我们来看一些纯的C++函数:\n// the answer to life, the universe, and everything int f42() { return 42; } int square(int x) { return x * x; // 不要担心溢出什么鬼的啦! } int add(int a, int b) { return a + b; }  我们来研究一下他们的参数类型. square只有接受一个类型为int的参数, 它的参数类型显然就是int. 但是add呢? 难道我们要说它有两个参数类型吗? 回想一下我们对类型的\u0026quot;定义\u0026quot;: 取值范围的集合. 那么把add的类型定义为两个int之间的类似\u0026quot;集合间的笛卡尔积\u0026ldquo;的形式是合理的.\n有了这个认识, 那void对应的类型, 应该就是0个类型之间的\u0026quot;笛卡尔积\u0026quot;了.\n相似地, 在Haskell, 我们也用类似的形式定义一种\u0026quot;复合\u0026quot;类型:\nf42 :: () -\u0026gt; Integer f42 () = 42 square_like_cpp :: (Integer) -\u0026gt; Integer square_like_cpp (x) = x * x square_normal :: Integer -\u0026gt; Integer square_normal x = x * x add_like_cpp :: (Integer, Integer) -\u0026gt; Integer add_like_cpp (x, y) = x + y add_normal :: Integer -\u0026gt; Integer -\u0026gt; Integer add_normal x y = x + y   其实我们从这里可以看到一件事实\u0026ndash;一个接受多个参数的函数的可以被变成一个接受一个参数并且返回函数的高阶函数, 这叫做Currying(柯里化).\n 我们可以看到, 通过(类型1, 类型2, ...)可以通过类型间的笛卡尔积构造出新的复合类型, 类似于C++中的tuple(元组)\n这时候C++中的void自然就对应于Haskell中的(); Haskell也有一个构造()的函数:\nunit :: a -\u0026gt; () unit _ = ()  类似于absurd在输出类型上是多态的, unit在输入类型上也是多态的.\n只有两个元素的集合(二元集): Bool 只要学会如何在Haskell中定义类型. 一种定义方法很简单, 直接枚举类型所能包含的值就好了:\ndata Bool = True | False  Categories Great and Small 从这里开始, 我们就要认识一些简单的范畴了.\n空范畴 就是空的范畴.\n如果你硬要一个数学定义的话, 那么一个范畴$C$是空范畴当且仅当其满足:\n$$ \\operatorname{ob}(C) = \\emptyset \\\\ \\hom(C) = \\emptyset $$\n 其实没有对象自然就没有态射\u0026hellip;后一条不是必须的\n 简单图 我们可以简单地从一张有向图及其中节点的可达性生成一个范畴.\n更确切地, 对于一张有向图而言, 定义:\n 有向图中的节点定义为$\\operatorname{ob}(C)$ 若存在从节点$a$到节点$b$的路径, 那么就往$\\hom(C)$里加入态射$a \\rarr b$  显然我们的态射有单位元和结合性.\n这种构建方法叫free construction, 构建出来的范畴叫free category.\n 为啥叫free我也不知道\u0026hellip;.\n这种方法的特点就是从给定结构做出最小的扩展然后生成一个合法的范畴\n 序 Orders 首先来做点概念题. 请解析下面三个名词的区别:\n 预序(preorder) 偏序(partial order) 全序(total order)  以及严格序和非严格序\n(⊙﹏⊙)\n 序是定义在某个集合上的二元关系; 一个关系就是是一个谓词.\n 首先我们来抽象出一个定义在集合$A$上的序关系$\\backsim$能有什么关系. 令$a,; b,; c$为序上的对象,\n 自反性. $a \\backsim b \\lrArr b \\backsim a$ 传递性. $a \\backsim b \\land b \\backsim c \\rArr a \\backsim c$ ","date":"2020-04-16","permalink":"https://blog.origami404.top/compiler-and-type-theory/2020-04-notes-on-category-theory-for-programmers/","tags":["Haskell","读书笔记"],"title":"Category-theory-for-programmers 阅读笔记"},{"content":"前言 时隔半年再次开始学Haskell, 然后在配环境中度过了一个哭笑不得的下午\u0026hellip;\nHaskell环境是啥呢\u0026hellip;? 按我不完全的理解, 主要有:\n 一个编译器, 比如ghc; 它还附带一个REPL叫ghci 一个包管理器兼项目管理器stack 一个提供后台语言分析支持的Language Engine, 比如Haskell-Ide-Engine(HIE)  然后呢还有一个东西叫cabal, 是一个历史遗留下来的包管理器, 有一套自己的包系统啊blabla的, 也没多大关系了\u0026hellip;\n stack和cabal的更多信息: Why is stack not cabal?. ANNOUNCING: first public beta of stack. What is the difference between Cabal and Stack?\n 本来呢, 目标是把上面三个, 最主要是第三个搞好; 但是由于我太菜了, 直到本文写好为止, 都\u0026hellip;\nWSL 如果配好了stack, 那剩下两个基本上就是水到渠成了.\n第一反应当然是选择WSL配置!\nsudo pacman -S stack  装完, 主要参考了这里, 配了一波stack.yaml, 然后开始折腾三, 照着这里的做法,\ngit clone https://github.com/haskell/haskell-ide-engine cd haskell-ide-engine stack install  然后报错:\nCabal file info not found for apply-refact-0.7.0.0, updating Selected mirror https://s3.amazonaws.com/hackage.fpcomplete.com/ Downloading root Waiting to acquire cache lock on $HOME/.stack/pantry/hackage/hackage-security-lock fdLock: invalid argument (Invalid argument)  Google之后, 在这里发现这可能是WSL的一个bug, 并且看起来修不了\u0026hellip;\n然后我在Cabel的issue里发现了一种可能的解决方法: 在项目目录下的cabal.project做出如下修改:\nconstraints: lukko -ofd-locking  报错依旧, 可能这个方法只能修cabel-install. 由于我对Haskell的包管理体系还完全不熟悉, 所以不知道能不能把这个方法移植到stack上, 但这条路看起来是行不通了\u0026hellip;\n那万能的AUR呢? Google后发现果然有直接有HIE的包.\n然后熟练地输入\nsudo pikaur -S haskell-ide-engine  熟练地得到报错:\nTraceback (most recent call last): File \u0026quot;/usr/sbin/pikaur\u0026quot;, line 9, in \u0026lt;module\u0026gt; main() File \u0026quot;/usr/lib/python3.8/site-packages/pikaur/main.py\u0026quot;, line 401, in main create_dirs() File \u0026quot;/usr/lib/python3.8/site-packages/pikaur/main.py\u0026quot;, line 373, in create_dirs raise Exception(result) Exception: InteractiveSpawn returned 1: STDOUT: STDERR: System has not been booted with systemd as init system (PID 1). Can't operate. Failed to create bus connection: Host is down  经过Google发现WSL基本上不可能折腾出systemd出来, 遂放弃, 转而去装了个yay\n 后来发现我还是太菜了. 按照装包的惯性, 我加了sudo, 但是pikaur默认是不想带着root权限跑(怕恶意aur), 所以它会试着派生出一个普通权限的进程, 而这时用到了systemd. 所以只要不加sudo, 它就完全可以正常地在WSL上运行\u0026hellip;\n  然而我发现得太晚了\u0026hellip;\n 装好yay之后, 尝试安装那个AUR, 发现它其实就是手动做法, 把源码下下来然后stack install\u0026hellip;\n(o_ _)ﾉ\n我换Windows版总行了吧\u0026hellip; 下载win版安装, 然后stack setup, 报错:\n...(一些OS相关信息) (internalexception (handshakefailed (error_misc \u0026quot;network.socket.sendbuf: failed (no error)\u0026quot;)))  我\u0026hellip;迷惑\u0026hellip;\n啥玩意叫failed (no error)啊啊啊啊啊啊???\nGoogle之后发现完全没有相关的结果, 大家都有error就我没有\u0026hellip;遂怀疑是某堵墙的问题(因为它好像要从raw.githubcontent)那里下点什么东西\n然后去找了一会才找到powershell怎么给命令挂代理(好像win10自带的全局代理不可以\u0026hellip;), 本质上也是加环境变量:\n$Env:http_proxy=http://127.0.0.1:1080 $Env:https_proxy=http://127.0.0.1:1080  然后再跑就没问题了\u0026hellip; f**k GFW\n 这setup好像还顺路装了个msys2\u0026hellip;\n 好. 去HIE的目录下愉快地stack install吧!\n然后编译到一半报错:\n某个项目 \u0026gt; Registering library for 项目-版本.. terminateProcess: permission denied (Permission denied)  我有给管理员啊\u0026hellip;而且Ctrl+C重来后还在不一样的地方报错; 还不是所有包都会报这个错\u0026hellip;\n无奈Google, 发现了一个神奇的方法(这里):\nchcp 65001  把当前powershell代码页切换到UTF-8就好了\u0026hellip;\n什么鬼啊w(ﾟДﾟ)w\n然后又历经几次奇奇怪怪的报错, 多编译了几次, 总算把这200+的依赖编译完了, 一运行:\nhie.exe: could not detect mingw toolchain  Boom!\n气急败坏的我甚至跑去WSL里输了个hie.exe, 然后还是报错:\nhie.exe: 当前目录: getDirectoryContents:findFirstFile: permission denied ()   过一天重启之后再次在powershell里运行, 报的错跟WSL里的一样了\u0026hellip;\n 最后 发现了一个VSCode扩展Simple GHC (Haskell) Integration for VSCode, 只需要GHCi就可以运行就能提供的基本的补全, 对我这种轻度使用是完全ok了\u0026hellip;.\n所以我是白折腾了..?\n","date":"2020-04-14","permalink":"https://blog.origami404.top/post/2020-04-haskell-dev-in-win10/","tags":["折腾","Haskell","我会熟练地安装xxx系列"],"title":"Win10下Haskell开发环境的配置"},{"content":"前言 大概1月底, 辣鸡win10的更新就更不上去了, 然后我折腾了好久\u0026hellip;包括各种系统检查啊手动安装啊, 无果. 最后在3月决定干脆删了重装\u0026hellip;\n重装过程中遇到了大大小小的问题, 写个文章记录一下.\n3月的事拖到4月写, 咕咕咕实锤\nWSL \u0026amp; WIM 删系统之前要干吗呢? 当然是备份.\n现在都2020年了, 当然不能再用ghost了, 我们当然要选择简洁好用的dism++打一个wim镜像啦!\n作为世界上最大的Linux发行版, Win10这么能不装WSL呢? 同时因为更不上去的原因(其实主要是想要用安卓模拟器打游戏), 我还在用WSL1, 并且用这个repo换了Arch.\n然后问题就来了.\n恢复镜像的时候, 会在wsl的rootfs的某个文件报错: (具体记不住了, 反正就差不多这个)\n 0x00000005 拒绝访问\n 一开始完全没意识到是wsl的问题, 搜了我好久才发现是\u0026hellip;(我太菜了\u0026hellip;)\n关键是它打包的时候不会报错, 恢复的时候才会\u0026hellip;我的备份就这样炸了\u0026hellip;准备直接全新安装吧.\n安装过程 一开始也是标准操作, dism++释放映像等3分钟, 然后重启进系统, 然后\u0026hellip;\n windows 无法完成安装,若要在此计算机上安装windows,请重新启动安装 win10\n 我当场直接迷惑, 难不成我之前跑的不是Win10🐎?\n然后同样是折腾许久, 包括直接跳过这个调用msoobe(可以见这个blog), 然后就一直卡那里了\u0026hellip;\n最后我也不知道这么地就开始怀疑分区, 然后实锤了\u0026hellip;是一个叫MSR分区的玩意, 可以参考这里\n简单来讲, Win10会期望你的硬盘的分区表(gpt)长这样:\n|----ESP(\u0026gt;200M)----|----MSR(=128M)----|----Win10----|----随便----|  但是我之前, 把MSR分区删了.\n问题是这个分区啊, 它目前还没什么用, 删了win10照样给你跑得欢快, 然后我就把这茬子忘了\u0026hellip;\n但是, 如果你安装win10的时候没有这个分区, 那win10就直接不给你装了, 就会像上面一样报错\u0026hellip;\n 人间迷惑\u0026hellip;\n 然后新建了一个空空白白的整整128M不多不少的MSR分区, 就能装了\u0026hellip;\n 欲言又止, *龙门粗口*\n 总结  有Wsl的系统不能用Wim镜像备份 装Win10的时候记得在那个分区前新建一个128M的MSR分区 辣鸡Windows ","date":"2020-04-08","permalink":"https://blog.origami404.top/post/2020-04-win10-and-msr/","tags":["折腾","Windows","我会熟练地安装xxx系列"],"title":"Win10重装与MSR分区"},{"content":"在试卷现实生活中, 总是会碰到一些泛函上的最优化问题. 它们大多可以归为以下形式:\n在函数集合\n$$ \\left\\{ x(t) \\ \\Big| \\ x(t_1) = y_1, x(t_2) = y_2, x^{(k)} 存在 \\right\\} $$\n中, 求一个函数 $x(t)$ 使得泛函 $I[x(\\centerdot)]$ 的积分:\n$$ S = \\int_{t_1}^{t_2} I[x, x\u0026rsquo;, t] \\ \\mathrm{d}x $$\n有极值.\n我们知道, 一个连续函数 $x(t)$ 的在某个值 $t$ 有极值的必要条件是 $x\u0026rsquo;(t) = 0$, 这被称为费马引理 (强烈建议先去看看它的证明, 其证明的思想有助于理解下文).\n那么对于泛函, 这个必要条件是什么呢?\n在微积分中, 我们的一般思考方法是取极值附近的一个微元 $\\mathrm{d}x$, 然后利用函数的连续性去取得极值的必要条件, 在泛函中我们能否也去考虑一个极值函数附近的某种\u0026quot;微元\u0026quot;, 即对于对应极值函数的一个小小的偏移函数, 借此来研究极值函数符合的条件呢?\n我们来(随便)构造一个函数 $\\mathrm{\\eta}(t)$, 令其连续且存在 $k$ 次导数, 并且还要在两端点为 $0$, 不妨令:\n$$ \\eta(t) = (t - t_1)^{2k} (t - t_2)^{2k} $$\n$$let\\ (k=1, t_1=1, t_2=2)$$\n显然它符合我们的要求, 并且图像看起来就像肿了一个小包, 也挺符合我们对\u0026quot;偏移函数\u0026quot;的认知(大概?)\n有了偏移函数还不够, 我们在泛函中没办法搞到像在实数集一样的序性质, 也就没办法用费马引理的老路子, 那咋办啊?\n既然我们都已经有偏移函数了, 不妨引入一个实数 $\\alpha$, 它能控制\u0026quot;偏移的量\u0026quot;, 这就把泛函的偏移归结为实数的偏移,然后我们就能用费马引理愉快(?)地玩耍了.\n我们先随便找一个函数 $x_0$, 并令它偏移一下变成 $x = x_0 + \\alpha \\eta$, 然后我们的 $S$ 就从一个关于 $x$ 的泛函变成了一个关于 $\\alpha$ 的函数:\n$$ S(\\alpha) = \\int_{t_1}^{t_2} I[x_0 + \\alpha \\mathrm{\\eta}, x_0\u0026rsquo; + \\alpha \\mathrm{\\eta}, t]\\ \\mathrm{d}t $$\n当这个函数 $S(\\alpha)$ 有极值时我们必有: $\\mathrm{d}S/\\mathrm{d}\\alpha = 0$. 我们对 $\\alpha$ 求导, 有:\n$$ \\frac{\\mathrm{d}S}{\\mathrm{d}\\alpha} = \\int_{t_1}^{t_2} \\frac{\\mathrm{d}}{\\mathrm{d}\\alpha} I[x_0 + \\alpha \\mathrm{\\eta}, x_0\u0026rsquo; + \\alpha \\mathrm{\\eta}, t] \\ \\mathrm{d}t $$\n利用多元函数的全微分, 有:\n$$ \\frac{\\mathrm{d}I}{\\mathrm{d}\\alpha} = \\frac{\\partial I}{\\partial x} \\frac{\\mathrm{d}x}{\\mathrm{d}\\alpha} + \\frac{\\partial I}{\\partial x\u0026rsquo;} \\frac{\\mathrm{d}x\u0026rsquo;}{\\mathrm{d}\\alpha} + \\frac{\\partial I}{\\partial t} \\frac{\\mathrm{d}t}{\\mathrm{d}\\alpha} $$\n注意到最后一项中 $t$ 并不依赖于 $\\alpha$, 所以原式化为:\n$$ \\frac{\\mathrm{d} S}{\\mathrm{d} \\alpha} = \\int_{t_1}^{t_2} \\left( \\frac{\\partial I}{\\partial x} \\eta + \\frac{\\partial I}{\\partial x\u0026rsquo;} \\eta\u0026rsquo; \\right) \\ \\mathrm{d} t $$\n我们想办法把 $\\eta$ 凑出来, 由 $\\eta$ 的任意性逼着搞出某个玩意为0. 什么玩意能把 $\\eta\u0026rsquo;$ 变成 $\\eta$ 呢? 当然是我们可爱的分部积分. 于是我们把第二项拉出来分部积一下:\n$$\\int_{t_1}^{t_2} \\frac{\\partial I}{\\partial x\u0026#39;} \\eta\u0026#39; = \\frac{\\partial I}{\\partial x\u0026#39;} \\eta \\big|^{t_2}_{t_1} - \\int_{t_1}^{t_2} \\left( \\frac{\\mathrm{d}}{\\mathrm{d}t} \\frac{\\partial I}{\\partial x\u0026#39;} \\right) \\eta \\ \\mathrm{d}t$$ 代入回去, 并注意到我们在定义 $\\eta$ 时让两端点的 $\\eta$ 值为 $0$ 了, 所以把分部出来的第一项略去, 有:\n$$\\frac{\\mathrm{d} S}{\\mathrm{d} \\alpha} = \\int_{t_1}^{t_2} \\left( \\frac{\\partial I}{\\partial x} - \\frac{\\mathrm{d}}{\\mathrm{d}t} \\frac{\\partial I}{\\partial x\u0026#39;} \\right) \\eta \\, \\mathrm{d}t$$ 如果此时的函数 $x$ 令 $S$ 有了极值的话, 我们就会有 $\\mathrm{d}S/\\mathrm{d}\\alpha = 0$, 即:\n$$\\int_{t_1}^{t_2} \\left( \\frac{\\partial I}{\\partial x} - \\frac{\\mathrm{d}}{\\mathrm{d}t} \\frac{\\partial I}{\\partial x\u0026#39;} \\right) \\eta \\ \\mathrm{d}t = 0$$ 由 $\\eta$ 的任意性, 我们就必有:\n$$ \\frac{\\partial I}{\\partial x} - \\frac{\\mathrm{d}}{\\mathrm{d}t} \\frac{\\partial I}{\\partial x\u0026rsquo;} = 0 $$\n综上, 当函数 $x$ 使得\n$$ S = \\int_{t_1}^{t_2} I[x, x\u0026rsquo;, t]\\ \\mathrm{d}x $$\n有极值时, 此函数必然满足:\n$$ \\frac{\\partial I}{\\partial x} - \\frac{\\mathrm{d}}{\\mathrm{d}t} \\frac{\\partial I}{\\partial x\u0026rsquo;} = 0 $$\n此条件称为欧拉-拉格朗日方程.\n","date":"2020-01-31","permalink":"https://blog.origami404.top/post/2020-01-basic-of-calculus-of-variations/","tags":["理论物理","变分法"],"title":"变分学基本定理"},{"content":"应某人推荐, 终端模拟器使用了Alacritty, 特此记录.\noh-my-zsh主题用了ys\n主题使用了darcula\n注意, 因为我用的是Awesome WM, 不自带合成器效果, 需要安装compton之后, Alacritty的透明选项才会起作用.\n# Font configuration font: # Normal (roman) font face normal: # Font family # # Default: # - (macOS) Menlo # - (Linux/BSD) monospace # - (Windows) Consolas family: Fira Code # The `style` can be specified to pick a specific face. style: Regular # Bold font face bold: # Font family # # If the bold family is not specified, it will fall back to the # value specified for the normal font. family: Fira Code # The `style` can be specified to pick a specific face. style: Bold # Italic font face italic: # Font family # # If the italic family is not specified, it will fall back to the # value specified for the normal font. family: Fira Code # The `style` can be specified to pick a specific face. style: Italic # Bold italic font face bold_italic: # Font family # # If the bold italic family is not specified, it will fall back to the # value specified for the normal font. family: Fira Code # The `style` can be specified to pick a specific face. style: Bold Italic # Point size size: 7.0 # Colors (Tomorrow Night Bright) colors: # Default colors primary: background: '0x282a36' foreground: '0xf8f8f2' # Bright and dim foreground colors # # The dimmed foreground color is calculated automatically if it is not present. # If the bright foreground color is not set, or `draw_bold_text_with_bright_colors` # is `false`, the normal foreground color will be used. #dim_foreground: '0x9a9a9a' #bright_foreground: '0xffffff' # Cursor colors # # Colors which should be used to draw the terminal cursor. If these are unset, # the cursor color will be the inverse of the cell color. cursor: text: '0x44475a' cursor: '0xf8f8f2' # Normal colors normal: black: '0x000000' red: '0xff5555' green: '0x50fa7b' yellow: '0xf1fa8c' blue: '0xbd93f9' magenta: '0xff79c6' cyan: '0x8be9fd' white: '0xbfbfbf' # Bright colors bright: black: '0x4d4d4d' red: '0xff6e67' green: '0x5af78e' yellow: '0xf4f99d' blue: '0xcaa9fa' magenta: '0xff92d0' cyan: '0x9aedfe' white: '0xe6e6e6' # Dim colors # # If the dim colors are not set, they will be calculated automatically based # on the `normal` colors. dim: black: '0x14151b' red: '0xff2222' green: '0x1ef956' yellow: '0xebf85b' blue: '0x4d5b86' magenta: '0xff46b0' cyan: '0x59dffc' white: '0xe6e6d1' # Indexed Colors # # The indexed colors include all colors from 16 to 256. # When these are not set, they're filled with sensible defaults. # # Example: # `- { index: 16, color: '0xff00ff' }` # indexed_colors: [] # Background opacity # # Window opacity as a floating point number from `0.0` to `1.0`. # The value `0.0` is completely transparent and `1.0` is opaque. background_opacity: 0.5 cursor: # Cursor style # # Values for `style`: # - ▇ Block # - _ Underline # - | Beam style: Beam # If this is `true`, the cursor will be rendered as a hollow box when the # window is not focused. unfocused_hollow: true  截图:\n","date":"2020-01-29","permalink":"https://blog.origami404.top/linux-conf/2020-01-arch-alacritty/","tags":["折腾","Arch"],"title":"Arch Alacritty 配置"},{"content":"配个awesome.\n主要痛点有:\n 任务栏在上面, 并且有一堆很讨厌的东西, 比如什么启动菜单啊, 当前任务啊, 键盘键位等 默认layout居然是floating, 理解不能 tag居然是全部显示然后有东西就有个点, 这样看起来很累 快捷键不合我口味 壁纸有点丑啊\u0026hellip;  在~/.config下弄出这样的文件夹结构:\ntree -a ~ └── .config └── awesome ├── rc.lua └── theme.lua  其中themes.lua是从/usr/share/awesome/themes/default里搞来的.\n这个是rc.lua, 删掉了很多东西(备份注意!)\n-- include 一些东西, 留着 pcall(require, \u0026quot;luarocks.loader\u0026quot;) local gears = require(\u0026quot;gears\u0026quot;) local awful = require(\u0026quot;awful\u0026quot;) require(\u0026quot;awful.autofocus\u0026quot;) local wibox = require(\u0026quot;wibox\u0026quot;) local beautiful = require(\u0026quot;beautiful\u0026quot;) local naughty = require(\u0026quot;naughty\u0026quot;) local hotkeys_popup = require(\u0026quot;awful.hotkeys_popup\u0026quot;) require(\u0026quot;awful.hotkeys_popup.keys\u0026quot;) -- {{{ 错误处理 -- 这可以在rc.lua出错时通过通知的形式告诉你, 保留(当然如果你十分自信就可以删) if awesome.startup_errors then naughty.notify({ preset = naughty.config.presets.critical, title = \u0026quot;Oops, there were errors during startup!\u0026quot;, text = awesome.startup_errors }) end -- 处理启动之后的一些错误, 就是不是rc.lua的错 do local in_error = false awesome.connect_signal(\u0026quot;debug::error\u0026quot;, function (err) -- Make sure we don't go into an endless error loop if in_error then return end in_error = true naughty.notify({ preset = naughty.config.presets.critical, title = \u0026quot;Oops, an error happened!\u0026quot;, text = tostring(err) }) in_error = false end) end -- }}} -- {{{ 变量定义 -- 主题文件, 就是某某地方的themes.lua beautiful.init(\u0026quot;/home/origami/.config/awesome/theme.lua\u0026quot;) -- 默认的终端模拟器 terminal = \u0026quot;alacritty --config-file=/home/origami/.config/alacritty/alacritty.yml \u0026quot; editor = os.getenv(\u0026quot;EDITOR\u0026quot;) or \u0026quot;vim\u0026quot; editor_cmd = terminal .. \u0026quot; -e \u0026quot; .. editor -- modkey, 这里选了win键, 就是夹在Ctrl跟Alt中间的那个 modkey = \u0026quot;Mod4\u0026quot; -- 按顺序排的默认layout, 我喜欢平铺, 并且新窗口从右边出来 -- 所以layout要保留左边, 意思就是把旧窗口保留在左边 awful.layout.layouts = { awful.layout.suit.tile.left, awful.layout.suit.fair, } -- }}} -- {{{ Wibar -- 搞个时钟 widget. widget就是能摆在任务栏的一块区域 -- 可以参考一下这两篇文章 https://www.jianshu.com/p/76ac11863591, https://awesomewm.org/doc/api/classes/wibox.wi不拉dget.textclock.html -- 按照这个参数, 效果大概是: 2020/01/24 11:47:36 Fri mytextclock = wibox.widget.textclock(\u0026quot; %Y/%m/%d %X %a \u0026quot;, 1, \u0026quot;+08:00\u0026quot;) -- 让任务栏上每一个tag对应的wibox(就是一种小块)能让鼠标按, 并且在鼠标按时切换tag -- tag类似于windows上的一个虚拟桌面 -- 函数中的第二个参数, 那个蜜汁数字的意思是绑定鼠标上的哪个键 -- 1 -\u0026gt; 鼠标左键, 3 -\u0026gt; 鼠标右键, 4, 5 -\u0026gt; 滚轮上下 local taglist_buttons = gears.table.join( -- 我只需要点击切换就好了, 不需要那么多花里胡哨的玩意 awful.button({ }, 1, function(t) t:view_only() end) ) -- 设置墙纸, 主要是考虑到多显示器(screen)的情况才单独抽出一个函数, 我也懒得改了 local function set_wallpaper(s) -- Wallpaper if beautiful.wallpaper then local wallpaper = beautiful.wallpaper -- If wallpaper is a function, call it with the screen if type(wallpaper) == \u0026quot;function\u0026quot; then wallpaper = wallpaper(s) end gears.wallpaper.maximized(wallpaper, s, true) end end -- Re-set wallpaper when a screen's geometry changes (e.g. different resolution) screen.connect_signal(\u0026quot;property::geometry\u0026quot;, set_wallpaper) -- 对每一个显示器 awful.screen.connect_for_each_screen(function(s) -- 首先壁纸安排上 set_wallpaper(s) -- 然后加上tag 1~9, 我不习惯给tag一个有意义的名字, 所以就直接数字了. 最后一个参数是默认layout awful.tag({ \u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;5\u0026quot;, \u0026quot;6\u0026quot;, \u0026quot;7\u0026quot;, \u0026quot;8\u0026quot;, \u0026quot;9\u0026quot; }, s, awful.layout.layouts[1]) -- prompt是一个类似启动器一样的玩意, 按Modkey+r就能出来, 能spawn程序 s.mypromptbox = awful.widget.prompt() -- 创建一个taglist widget s.mytaglist = awful.widget.taglist { screen = s, -- 过滤器, 原版配置文件是全部都显示上, 我的习惯是只显示非空的tag filter = awful.widget.taglist.filter.noempty, buttons = taglist_buttons } -- Create the wibox -- 把任务栏放到底下去 s.mywibox = awful.wibar({ position = \u0026quot;bottom\u0026quot;, screen = s }) -- 任务栏上的widget怎么放 s.mywibox:setup { layout = wibox.layout.align.horizontal, { -- 左边 layout = wibox.layout.fixed.horizontal, -- 辣鸡启动菜单给爷爬 -- 放taglist s.mytaglist, -- 放启动器 s.mypromptbox, }, { -- 中间 -- 啥也不放, 但是要占个位置, 防止右边跑到中间来 layout = wibox.layout.align.horizontal }, { -- 右边 layout = wibox.layout.fixed.horizontal, -- 这有点类似于windows下面的任务栏, 可以放一些应用图标, 比如输入法的小键盘 wibox.widget.systray(), -- 放个钟 mytextclock, }, } end) -- }}} -- {{{ 不知道是干嘛的, 放着 root.buttons(gears.table.join( awful.button({ }, 3, function () mymainmenu:toggle() end), awful.button({ }, 4, awful.tag.viewnext), awful.button({ }, 5, awful.tag.viewprev) )) -- }}} -- {{{ 键位绑定, 这里是全局按键, 就是按下键之后要干什么不依赖于当前焦点应用的 globalkeys = gears.table.join( -- 显示一张快捷键表 awful.key({ modkey, \u0026quot;Shift\u0026quot; }, \u0026quot;s\u0026quot;, hotkeys_popup.show_help, {description=\u0026quot;show help\u0026quot;, group=\u0026quot;awesome\u0026quot;}), -- 让它像输入法一样可以通过-/=键来前后切换tag(虽然我好像没用过) awful.key({ modkey, }, \u0026quot;-\u0026quot;, awful.tag.viewprev, {description = \u0026quot;view previous\u0026quot;, group = \u0026quot;tag\u0026quot;}), awful.key({ modkey, }, \u0026quot;=\u0026quot;, awful.tag.viewnext, {description = \u0026quot;view next\u0026quot;, group = \u0026quot;tag\u0026quot;}), -- 改变layout, 就是把当前tag中的几个窗口挪来挪去 awful.key({ modkey, \u0026quot;Shift\u0026quot; }, \u0026quot;j\u0026quot;, function () awful.client.swap.byidx( 1) end, {description = \u0026quot;swap with next client by index\u0026quot;, group = \u0026quot;client\u0026quot;}), awful.key({ modkey, \u0026quot;Shift\u0026quot; }, \u0026quot;k\u0026quot;, function () awful.client.swap.byidx( -1) end, {description = \u0026quot;swap with previous client by index\u0026quot;, group = \u0026quot;client\u0026quot;}), -- Modkey+回车 出终端, Modkey+Shift+r 重启awesome awful.key({ modkey, }, \u0026quot;Return\u0026quot;, function () awful.spawn(terminal) end, {description = \u0026quot;open a terminal\u0026quot;, group = \u0026quot;launcher\u0026quot;}), awful.key({ modkey, \u0026quot;Shift\u0026quot; }, \u0026quot;r\u0026quot;, awesome.restart, {description = \u0026quot;reload awesome\u0026quot;, group = \u0026quot;awesome\u0026quot;}), -- Modkey+r 调用启动器 awful.key({ modkey }, \u0026quot;r\u0026quot;, function () awful.screen.focused().mypromptbox:run() end, {description = \u0026quot;run prompt\u0026quot;, group = \u0026quot;launcher\u0026quot;}), -- 人活着不能没有浏览器和编辑器啊! awful.key({ modkey, \u0026quot;Alt\u0026quot; }, \u0026quot;v\u0026quot;, function () awesome.spawn(\u0026quot;code\u0026quot;) end, {description = \u0026quot;start vscode\u0026quot;, group = \u0026quot;Custom App\u0026quot;}), awful.key({ modkey, \u0026quot;Alt\u0026quot; }, \u0026quot;c\u0026quot;, function () awesome.spawn(\u0026quot;chromium\u0026quot;) end, {description = \u0026quot;start chromium\u0026quot;, group = \u0026quot;Custom App\u0026quot;}) ) -- 依赖于当前焦点应用的快捷键绑定 clientkeys = gears.table.join( -- 全屏 awful.key({ modkey, }, \u0026quot;f\u0026quot;, function (c) c.fullscreen = not c.fullscreen c:raise() end, {description = \u0026quot;toggle fullscreen\u0026quot;, group = \u0026quot;client\u0026quot;}), -- 退出 awful.key({ modkey, \u0026quot;Shift\u0026quot; }, \u0026quot;q\u0026quot;, function (c) c:kill() end, {description = \u0026quot;close\u0026quot;, group = \u0026quot;client\u0026quot;}) ) -- 给每一个tag绑定Modkey+1/2/3/4/5/6/7/8/9 -- 显然不写循环会看起来很傻 for i = 1, 9 do globalkeys = gears.table.join(globalkeys, -- 据说是使用了黑魔法来保证在不同键盘上绑定的键都是1到9, 不要动就对了 awful.key({ modkey }, \u0026quot;#\u0026quot; .. i + 9, function () local screen = awful.screen.focused() local tag = screen.tags[i] -- 我想要让它跟i3一样, 如果我现在在2 tag, 我再按Modkey+2就给我切换到上一个我访问过的tag去 (方便抄代码) -- 获得我当前的tag local now_tag = screen.selected_tag if tag then -- 如果当前的tag就是我现在在看着的tag if tag == now_tag then -- 回到上一次我访问的tag那里去 awful.tag.history.restore(screen) else tag:view_only() end -- 如果不是就切换到要去的tag end end, {description = \u0026quot;view tag #\u0026quot;..i, group = \u0026quot;tag\u0026quot;}), -- 移动应用去到对应tag awful.key({ modkey, \u0026quot;Shift\u0026quot; }, \u0026quot;#\u0026quot; .. i + 9, function () if client.focus then local tag = client.focus.screen.tags[i] if tag then client.focus:move_to_tag(tag) end end end, {description = \u0026quot;move focused client to tag #\u0026quot;..i, group = \u0026quot;tag\u0026quot;}) ) end -- 保证你鼠标在的应用是焦点应用 clientbuttons = gears.table.join( awful.button({ }, 1, function (c) c:emit_signal(\u0026quot;request::activate\u0026quot;, \u0026quot;mouse_click\u0026quot;, {raise = true}) end), awful.button({ modkey }, 1, function (c) c:emit_signal(\u0026quot;request::activate\u0026quot;, \u0026quot;mouse_click\u0026quot;, {raise = true}) awful.mouse.client.move(c) end), awful.button({ modkey }, 3, function (c) c:emit_signal(\u0026quot;request::activate\u0026quot;, \u0026quot;mouse_click\u0026quot;, {raise = true}) awful.mouse.client.resize(c) end) ) -- 使快捷键生效 root.keys(globalkeys) -- }}} -- {{{ 这里是让一些特殊应用使用特殊布局的地方, 放着 -- blabla..... -- }}}  这个是themes.lua, 同样删除了很多东西~~(任务栏要什么图标)~~\nlocal theme_assets = require(\u0026quot;beautiful.theme_assets\u0026quot;) local xresources = require(\u0026quot;beautiful.xresources\u0026quot;) local dpi = xresources.apply_dpi -- local gfs = require(\u0026quot;gears.filesystem\u0026quot;) local themes_path = \u0026quot;/home/origami/.config/awesome/themes\u0026quot; local theme = {} -- Fira Code 大法好, 后面的数字定字号 theme.font = \u0026quot;Fira Code 9\u0026quot; theme.bg_normal = \u0026quot;#222222AA\u0026quot; theme.bg_focus = \u0026quot;#535d6cCC\u0026quot; theme.bg_urgent = \u0026quot;#ff0000\u0026quot; theme.bg_minimize = \u0026quot;#444444\u0026quot; theme.bg_systray = theme.bg_normal theme.fg_normal = \u0026quot;#aaaaaa\u0026quot; theme.fg_focus = \u0026quot;#ffffff\u0026quot; theme.fg_urgent = \u0026quot;#ffffff\u0026quot; theme.fg_minimize = \u0026quot;#ffffff\u0026quot; theme.useless_gap = dpi(0) -- 这是两个应用之间的间隔的宽度 theme.border_width = dpi(1) -- 这是应用边框的宽度 theme.border_normal = \u0026quot;#000000\u0026quot; theme.border_focus = \u0026quot;#535d6c\u0026quot; theme.border_marked = \u0026quot;#91231c\u0026quot; theme.menu_height = dpi(15) theme.menu_width = dpi(100) -- 墙纸挑一张喜欢的就好 theme.wallpaper = \u0026quot;/home/origami/pictures/new_bg/03.jpg\u0026quot; return theme  最后放截图:\n壁纸是p站的, 原链接\n","date":"2020-01-29","permalink":"https://blog.origami404.top/linux-conf/2020-01-arch-awesome-wm/","tags":["折腾","Arch"],"title":"Arch AwesomeWM 配置"},{"content":"接着上文, 记录一些常用的CLI工具\n首先装sudo并新建用户\npacman -S sudo useradd -m -g wheel origami  安装一堆工具\npacman -S base-devel git cmake  装个v2ray并启动, ss实在太容易被ban了. proxychains可以通过替换动态链接库的方法来强迫某个命令行应用走代理, 也一并装上. 装完之后可以在/etc/proxychains.conf中配置, 一般把最底下改改就好.\n注意每次改完v2ray配置文件之后都要reenable+restart.\npacman -S v2ray proxychains systemctl enable v2ray systemctl start v2ray  然后使用pikaur管理AUR, 因为它适配pacman的语法(这时候proxychains就有用了)\ngit clone https://github.com/actionless/pikaur  然后是zsh, 曾经激情满满想手写zsh配置, 最后还是oh-my-zsh真香\npacman -S zsh sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot;  CLI工具要配置的不多, 接下来就是GUI工具了\n","date":"2020-01-29","permalink":"https://blog.origami404.top/linux-conf/2020-01-arch-install-cli/","tags":["折腾","Arch"],"title":"Arch CLI工具 安装记录"},{"content":"安装 桌面环境这次选择了X+awesome, wayland现在还是太折腾了, 并且还有输入法这一个大坑. 用过i3之后对浮动式wm就再也提不起兴趣, 同时因为用了一阵子i3, 决定换个口味, 试试配一个awesome.\ndm用的是lightdm, greeter用了lightdm-webkit2-greeter(因为好看2333), 主题选择了这一个.\n终端模拟器用了alacritty, 主题选了这一个\n首先pacman一波操作(scrot可以在CLI下截图)\nsudo pacman -S xorg compton scrot  然后想办法搞到一些字体. 我选了Sarasa Mono CL + Fira Code.\n然后就是一堆配置了.\n  Awesome配置\n  Alacritty配置\n  LightDM配置\n  输入法配置 未完成\n  Nvidia闭源驱动 \u0026amp; 色彩\n  最后放截图:\n","date":"2020-01-29","permalink":"https://blog.origami404.top/linux-conf/2020-01-arch-install-gui/","tags":["折腾","Arch"],"title":"Arch GUI 配置"},{"content":"简要名词介绍  WM: Windows Manager, 用于登录之后管理窗口的玩意 DM: Display Manager, 提供登录之前跟登录界面 Greeter: 用来提供登录界面, 依赖于特定的DM  安装 LightDM sudo pacman -S lightdm lightdm-webkit2-greeter  安装完编辑/etc/lightdm/lightdm.conf文件, 先找到[Seat:*], 在它下面找到greeter-session, 改为lightdm-webkit2-greeter. 类似这样:\n# ...... [Seat:*] # ...... greeter-session=lightdm-webkit2-greeter  配置 LightDM-Webkit2-Greeter 选择了这一个主题\n在Arch下可以直接按它README来搞, 一条pacman搞定:\nsudo pacman -S lightdm-webkit-theme-litarvan ","date":"2020-01-29","permalink":"https://blog.origami404.top/linux-conf/2020-01-arch-lightdm/","tags":["折腾","Arch"],"title":"Arch LightDM 配置"},{"content":"其实开源驱动已经很好了, 但是颜色看起来总是怪怪的\u0026hellip;\n白色跟浅浅的黄白之间的交界简直awful\u0026hellip;令人窒息, 特别是每次打开google都得看一次, 辣眼睛.\n一开始以为是颜色深度的问题, 因为win下是32位, 开源驱动下是24位, 但是怎么搞都搞不上32位, 遂放弃.\n后来一狠心, 装了闭源驱动, 发现并不是颜色深度的问题, 而是一个叫Color Range的玩意的问题, 于是特此记录.\n安装 sudo pacman -S nvidia nvidia-settings  不知道为什么, 这装nvidia-lts会炸, 我这GTX 1050Ti 不应该新到不能用lts才对啊\u0026hellip;\nnvidia-setttings是接下来调color range用的.\n装完之后去/etc/mkinitcpio.conf里, 把MODULES里的nouveau去掉. 然后跑一个:\nsudo mkinitcpio -p linux  然后做好显示爆炸的准备重启. 如果好了, 那这闭源nv驱动就算装好了.\n我们在终端里输入nvidia-settings打开它, 选择如下界面, 在我鼠标指着的地方那个选项, 选择limited, 即可获得一个不刺眼的白色.\n然而\u0026hellip; 这玩意重启就没了\u0026hellip;\n我们把它写到xprofile里去.\necho \u0026quot;nvidia-settings -l\u0026quot; \u0026gt;\u0026gt; ~/.xprofile  最后  f*ck nvidia.\n","date":"2020-01-29","permalink":"https://blog.origami404.top/linux-conf/2020-01-arch-nvidia/","tags":["折腾","Arch"],"title":"Arch Nvidia 闭源驱动 配置"},{"content":"简单记录一下安装arch时需要的命令. (虽然install.txt里都有了)\ninstall.txt复读机\n 如果你还不知道Arch是什么, 可以戳这里看看维基\n 打开作弊指南 install.txt 为了方便安装, 在启动完arch镜像后, /root下有一个install.txt, 打开就是安装所需的大部分步骤, 然后就可以一边看着一边抄了.\n一开始我用Ctrl+Alt+F2开多一个虚拟终端然后在F1和F2之间切换着抄, 后来vim支持虚拟终端之后就直接vim抄美滋滋.\n具体做法是用vim打开install.txt之后, 在normal模式下键入:term就可以打开一个终端. 然后按Ctrl+Shift+h/j/k/l就可以挪终端位置, 挪到喜欢的位置就可以开抄(?)了.\n正常流程: 准备(pre-installtion) 村通网 看看网络通不通, 可以ping一下baidu.com什么的.\n如果你是有线网络并且支持dhcp, 那就好办, 啥都不用设置.\n如果你是有线网络但是需要设置ip, 可以参考这里. 大概就是:\n 看看自己有什么网络接口(network interface)可以用(这玩意就大概类似于win下的网络适配器一样的东西吧). 运行: ip link show dev  就可以看到一堆. 其中lo是本地loopback接口, 没个卵用. 真正有用的是类似于eth0或者enp3s0之类的东西, 记着, 下面用\u0026lt;dev\u0026gt;引用 然后需要对特定的interface添加ip地址: ip address add \u0026lt;address/prefix_len\u0026gt; broadcast + dev \u0026lt;dev\u0026gt;  \u0026lt;address/prefix_len\u0026gt;那里可以填诸如192.168.0.234/24之类的东西. 添加网关(gateway, 或者叫router) ip route add default via \u0026lt;address\u0026gt; dev \u0026lt;dev\u0026gt;    然后就大概行了.\n实在不行, 可以直接写配置文件/etc/rc.conf\n# Static IP example interface=eth0 address=192.168.0.2 netmask=255.255.255.0 broadcast=192.168.0.255 gateway=192.168.0.1  广播地址怎么填是由掩码和网关决定的, 可以自己google\nDNS也可以在/etc/resolv.conf设置\nnameserver 8.8.8.8 nameserver 8.8.4.4  如果你是无线网络比如wifi, 可以直接用wifi-menu设置\n对时 直接设网络校准.\ntimedatectl set-ntp true  分区 \u0026amp; 格式化 这一块装双系统的话建议windows下搞或者用pe. 单系统无所谓, 随便搞.\n关于fdisk怎么用, 可以看这里.\n通常内存大于等于8G并且不是经常跑内存负载大的应用的用户, 可以不用设swap分区(比如我)\n分好区之后使用\nmkfs.ext4 /dev/sdX?  来格式化分区为ext4.\n安装 首先为了网速, 选择一个镜像(mirror). 编辑/etc/pacman.d/mirrorlist(安利清华源), 把所需的镜像网站丢最上面即可.\nTips: vim中normal模式输入/tuna可以查找tuna, v可以进入visual模式选择, d可以剪切, y可以复制, p可以粘贴\n挂载分区, 然后把一切丢给pacman, 去喝杯爪哇咖啡. (700多M东西, 要多久自己可以算算)\nmount /dev/sdX? /mnt pacstrap /mnt base linux linux-firmware  基础配置 生成fstab(用于管理挂载的文件系统的文件, 怪怪的)\ngenfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab  滚进新装的系统里打滚 chroot到新的系统\narch-chroot /mnt  现在你可以认为你已经在新系统里了.\n设置时区(如果你在看这篇中文文章, 一般您会在中国, 可以选择上海时区), 并把硬件时钟设置为系统时间\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime hwclock --systoh  设置localization\n编辑/etc/locale.gen, 去掉en_US.UTF-8跟zh_CN.UTF-8(或者你也可以顺路去掉HK跟TW的)的注释, 然后\nlocale-gen  驱动 \u0026amp; bootloader \u0026amp; dhcpcd 这里选择grub2作为bootloader. 同时因为我还要用windows打游戏, 顺路把windows的引导解决掉\n先装个微码跟ntfs的驱动\npacman -S \u0026lt;micro-code\u0026gt; ntfs-3g fuse  cpu为intel的, 装intel-ucode; 为amd的装amd-ucode, 不知道的或者装Arch在u盘四处插的可以两个都装.\n然后装grub2跟os-prober, 如果是uefi的还(可能)要装个efibootmgr\npacman -S grub2 os-prober efibootmgr  如果你已经装过windows了, 硬盘里一般会有一个efi分区, 可以通过fdisk -l查看, 一般就200来M的样子. 如果没有就google一下自己建一个分区.\n找到分区后挂载到/boot/efi上:\nmount /dev/sdX? /boot/efi  然后把bootloader装到硬盘里. 如果有什么报错可以先看看有没有/boot/grub这个文件夹, 没有可以先mkdir一个\nos-prober grub-mkconfig -o /boot/grub/grub.cfg grub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=GRUB  记得装dhcpcd, 要不然就等着重启断网吧\npacman -S dhcpcd systemctl enable dhcpcd  重启, 应该就能进入系统了.\n接下的配置可以看这里.\n","date":"2020-01-29","permalink":"https://blog.origami404.top/linux-conf/2020-01-arch-install-basic/","tags":["折腾","Arch"],"title":"Arch 安装记录"},{"content":"前言 忽然想建个blog来记录自己没填的坑了\u0026hellip;\n使用hexo搭建, 主题为new-vno, 托管于github-pages.\n搭建hexo 在你的平台上安装好nodejs, 然后使用npm安装hexo-cli\nsudo npm install -g hexo-cli\r 随后创建一个文件夹并初始化hexo\nmkdir hexo-blog \u0026amp;\u0026amp; cd hexo-blog \u0026amp;\u0026amp; hexo init\r 网站标题, 描述, 信息等可以在_config.yml修改, 参数具体配置见hexo文档\n在GitHub上clone主题至themes/文件夹, 安装一些依赖, 并修改_config.yml的theme选项\ngit clone https://github.com/monniya/hexo-theme-new-vno.git themes/new-vno\rnpm install hexo-generator-feed --save # RSS插件, 不用可以不装\r 主题的配置一般在themes/\u0026lt;主题名\u0026gt;/_config.yml处配置, new-vno的可配置项在此\n我还去new-vno的hexo-blog/themes/new-vno/source/css/vno.styl那里修改了字体(那个文件貌似是一个语法扩展的css文件), 使用Fira Code和Sarasa Mono CL.\n使用GitHub-pages 注册GitHub账号, 新建仓库, 仓库名要带后缀.github.io\n安装hexo的扩展, 将仓库地址放在_config.yml处\nnpm install hexo-deployer-git --save\r deploy:\rtype: git\rrepo: \u0026lt;仓库地址, 可以为https或者ssh\u0026gt;\rbranch: master\r Git在不知道那次更新后, https也能push上去了, 但是每次都要输入GitHub的账号密码, 如果嫌烦可以使用ssh上传或者保存密码(!!!于服务器文件明文保存!!!), 参考\n写作 用你喜欢的markdown编辑器写完, 上传到服务器的hexo-blog/source/_posts/下, 然后使用命令部署即可\nhexo g -d\r","date":"2019-07-20","permalink":"https://blog.origami404.top/post/2019-07-blog-init/","tags":["折腾"],"title":"Blog 搭建"}]